************* Module agent_s3.auth

************* Module agent_s3.planner
agent_s3/planner.py:36:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
agent_s3/planner.py:41:4: R0913: Too many arguments (12/5) (too-many-arguments)
agent_s3/planner.py:41:4: R0917: Too many positional arguments (12/5) (too-many-positional-arguments)
agent_s3/planner.py:41:71: W0613: Unused argument 'progress_tracker' (unused-argument)
agent_s3/planner.py:42:17: W0613: Unused argument 'task_state_manager' (unused-argument)
agent_s3/planner.py:42:42: W0613: Unused argument 'code_analysis_tool' (unused-argument)
agent_s3/planner.py:41:0: W0613: Unused argument 'kwargs' (unused-argument)
agent_s3/planner.py:315:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner.py:297:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner.py:316:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:336:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner.py:323:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner.py:337:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:386:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner.py:362:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner.py:388:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:392:20: C0415: Import outside toplevel (time) (import-outside-toplevel)
agent_s3/planner.py:395:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:400:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/planner.py:412:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:507:16: W0707: Consider explicitly re-raising using 'raise PlanningError(f'Invalid JSON in architecture review: {e}') from e' (raise-missing-from)
agent_s3/planner.py:516:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner.py:517:12: W0707: Consider explicitly re-raising using 'raise PlanningError(f'Failed to generate architecture review: {str(e)}') from e' (raise-missing-from)
agent_s3/planner.py:519:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/planner.py:544:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner.py:604:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner.py:519:4: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/planner.py:593:28: W0612: Unused variable 'test_idx' (unused-variable)
agent_s3/planner.py:12:0: W0611: Unused import re (unused-import)
agent_s3/planner.py:13:0: W0611: Unused import os (unused-import)
agent_s3/planner.py:14:0: W0611: Unused import traceback (unused-import)
agent_s3/planner.py:16:0: W0611: Unused List imported from typing (unused-import)
agent_s3/planner.py:16:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/planner.py:17:0: W0611: Unused datetime imported from datetime (unused-import)
agent_s3/planner.py:20:0: W0611: Unused PrePlanningError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/planner.py:22:0: W0611: Unused validate_and_repair_json imported from agent_s3.json_utils (unused-import)
agent_s3/planner.py:32:0: W0611: Unused validate_pre_planning_output imported from agent_s3.pre_planner_json_enforced (unused-import)
************* Module agent_s3.coordinator

agent_s3/coordinator.py:421:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/coordinator.py:884:0: C0305: Trailing newlines (trailing-newlines)
agent_s3/coordinator.py:665:0: R1707: Disallow trailing comma tuple (trailing-comma-tuple)
agent_s3/coordinator.py:55:0: R0902: Too many instance attributes (37/7) (too-many-instance-attributes)
agent_s3/coordinator.py:108:12: W0621: Redefining name 'CommandProcessor' from outer scope (line 35) (redefined-outer-name)
agent_s3/coordinator.py:119:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:108:12: W0404: Reimport 'CommandProcessor' (imported line 35) (reimported)
agent_s3/coordinator.py:108:12: C0415: Import outside toplevel (agent_s3.command_processor.CommandProcessor) (import-outside-toplevel)
agent_s3/coordinator.py:128:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/coordinator.py:205:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:136:12: C0415: Import outside toplevel (agent_s3.tools.context_management.context_registry.ContextRegistry) (import-outside-toplevel)
agent_s3/coordinator.py:137:12: C0415: Import outside toplevel (agent_s3.tools.context_management.context_manager.ContextManager) (import-outside-toplevel)
agent_s3/coordinator.py:142:12: C0415: Import outside toplevel (agent_s3.tools.code_analysis_tool.CodeAnalysisTool) (import-outside-toplevel)
agent_s3/coordinator.py:143:12: C0415: Import outside toplevel (agent_s3.tools.file_tool.FileTool) (import-outside-toplevel)
agent_s3/coordinator.py:147:12: C0415: Import outside toplevel (agent_s3.tools.git_tool.GitTool) (import-outside-toplevel)
agent_s3/coordinator.py:166:12: C0415: Import outside toplevel (agent_s3.tools.memory_manager.MemoryManager) (import-outside-toplevel)
agent_s3/coordinator.py:167:12: C0415: Import outside toplevel (agent_s3.tools.embedding_client.EmbeddingClient) (import-outside-toplevel)
agent_s3/coordinator.py:179:16: W0212: Access to a protected member _start_background_optimization of a client class (protected-access)
agent_s3/coordinator.py:191:12: C0415: Import outside toplevel (agent_s3.tools.test_frameworks.TestFrameworks) (import-outside-toplevel)
agent_s3/coordinator.py:193:12: C0415: Import outside toplevel (agent_s3.tools.test_critic.TestCritic) (import-outside-toplevel)
agent_s3/coordinator.py:196:12: C0415: Import outside toplevel (agent_s3.tools.error_context_manager.ErrorContextManager) (import-outside-toplevel)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'config' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'bash_tool' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'file_tool' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'code_analysis_tool' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'git_tool' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:197:41: E1123: Unexpected keyword argument 'scratchpad' in constructor call (unexpected-keyword-arg)
agent_s3/coordinator.py:283:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:236:12: C0415: Import outside toplevel (agent_s3.feature_group_processor.FeatureGroupProcessor) (import-outside-toplevel)
agent_s3/coordinator.py:259:12: C0415: Import outside toplevel (agent_s3.design_manager.DesignManager) (import-outside-toplevel)
agent_s3/coordinator.py:260:12: C0415: Import outside toplevel (agent_s3.implementation_manager.ImplementationManager) (import-outside-toplevel)
agent_s3/coordinator.py:261:12: C0415: Import outside toplevel (agent_s3.deployment_manager.DeploymentManager) (import-outside-toplevel)
agent_s3/coordinator.py:262:12: C0415: Import outside toplevel (agent_s3.database_manager.DatabaseManager) (import-outside-toplevel)
agent_s3/coordinator.py:349:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:348:20: E1101: Instance of 'ContextManager' has no 'stop_background_optimization' member; maybe '_stop_background_optimization'? (no-member)
agent_s3/coordinator.py:354:16: W0212: Access to a protected member _save_memory of a client class (protected-access)
agent_s3/coordinator.py:358:16: W0212: Access to a protected member _save_state of a client class (protected-access)
agent_s3/coordinator.py:372:19: E1101: Instance of 'ContextRegistry' has no 'get_current_context_snapshot' member (no-member)
agent_s3/coordinator.py:447:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:441:40: C0321: More than one statement on a single line (multiple-statements)
agent_s3/coordinator.py:443:47: C0321: More than one statement on a single line (multiple-statements)
agent_s3/coordinator.py:445:34: C0321: More than one statement on a single line (multiple-statements)
agent_s3/coordinator.py:519:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/coordinator.py:532:4: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/coordinator.py:559:12: C0415: Import outside toplevel (agent_s3.tools.static_plan_checker.StaticPlanChecker) (import-outside-toplevel)
agent_s3/coordinator.py:569:16: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/coordinator.py:628:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:581:24: C0415: Import outside toplevel (agent_s3.planner_json_enforced.regenerate_consolidated_plan_with_modifications) (import-outside-toplevel)
agent_s3/coordinator.py:581:24: E0611: No name 'regenerate_consolidated_plan_with_modifications' in module 'agent_s3.planner_json_enforced' (no-name-in-module)
agent_s3/coordinator.py:562:12: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/coordinator.py:657:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/coordinator.py:532:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/coordinator.py:532:4: R0915: Too many statements (57/50) (too-many-statements)
agent_s3/coordinator.py:685:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:701:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:730:56: W0613: Unused argument 'skip_planning' (unused-argument)
agent_s3/coordinator.py:755:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:773:8: W0613: Unused argument 'from_design' (unused-argument)
agent_s3/coordinator.py:829:12: E1123: Unexpected keyword argument 'plan' in method call (unexpected-keyword-arg)
agent_s3/coordinator.py:829:12: E1123: Unexpected keyword argument 'validation_output' in method call (unexpected-keyword-arg)
agent_s3/coordinator.py:829:12: E1120: No value for argument 'error_message' in method call (no-value-for-parameter)
agent_s3/coordinator.py:829:12: E1120: No value for argument 'traceback_text' in method call (no-value-for-parameter)
agent_s3/coordinator.py:842:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:862:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:877:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/coordinator.py:872:12: W0644: Possible unbalanced dict unpacking with self.test_runner_tool.run_tests(): left side has 2 labels, right side has 3 values (unbalanced-dict-unpacking)
agent_s3/coordinator.py:870:12: W0612: Unused variable 'activate_cmd' (unused-variable)
agent_s3/coordinator.py:871:12: W0612: Unused variable 'runner' (unused-variable)
agent_s3/coordinator.py:881:29: W0613: Unused argument 'changes' (unused-argument)
agent_s3/coordinator.py:11:0: C0411: standard import "typing.Optional" should be placed before first party import "agent_s3.enhanced_scratchpad_manager.LogLevel"  (wrong-import-order)
agent_s3/coordinator.py:12:0: C0411: standard import "traceback" should be placed before first party import "agent_s3.enhanced_scratchpad_manager.LogLevel"  (wrong-import-order)
agent_s3/coordinator.py:13:0: C0411: standard import "pathlib.Path" should be placed before first party import "agent_s3.enhanced_scratchpad_manager.LogLevel"  (wrong-import-order)
agent_s3/coordinator.py:14:0: C0411: standard import "datetime.datetime" should be placed before first party import "agent_s3.enhanced_scratchpad_manager.LogLevel"  (wrong-import-order)
agent_s3/coordinator.py:15:0: C0411: standard import "re" should be placed before first party import "agent_s3.enhanced_scratchpad_manager.LogLevel"  (wrong-import-order)
agent_s3/coordinator.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/coordinator.py:13:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/coordinator.py:14:0: W0611: Unused datetime imported from datetime (unused-import)
agent_s3/coordinator.py:35:0: W0611: Unused CommandProcessor imported from agent_s3.command_processor (unused-import)
agent_s3/coordinator.py:36:0: W0611: Unused PlanningWorkflow imported from agent_s3.workflows (unused-import)
agent_s3/coordinator.py:36:0: W0611: Unused ImplementationWorkflow imported from agent_s3.workflows (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused AgentError imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused CoordinationError imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused PlanningError imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused GenerationError imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused JSONPlanningError imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused ErrorCategory imported from agent_s3.errors (unused-import)
agent_s3/coordinator.py:39:0: W0611: Unused ErrorContext imported from agent_s3.errors (unused-import)
************* Module agent_s3.complexity_analyzer
agent_s3/complexity_analyzer.py:50:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/complexity_analyzer.py:50:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/complexity_analyzer.py:50:4: R0915: Too many statements (57/50) (too-many-statements)
agent_s3/complexity_analyzer.py:51:24: W0613: Unused argument 'context' (unused-argument)
agent_s3/complexity_analyzer.py:15:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/complexity_analyzer.py:9:0: W0611: Unused List imported from typing (unused-import)
************* Module agent_s3.schema_validator
agent_s3/schema_validator.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/schema_validator.py:127:0: C0413: Import "import logging" should be placed at the top of the module (wrong-import-position)
agent_s3/schema_validator.py:128:0: C0413: Import "import json" should be placed at the top of the module (wrong-import-position)
agent_s3/schema_validator.py:129:0: C0413: Import "import re" should be placed at the top of the module (wrong-import-position)
agent_s3/schema_validator.py:130:0: C0413: Import "from typing import Dict, List, Any, Optional, Union, TypeVar, Type, Generic, Callable" should be placed at the top of the module (wrong-import-position)
agent_s3/schema_validator.py:131:0: C0413: Import "from pydantic import BaseModel, Field, ValidationError" should be placed at the top of the module (wrong-import-position)
agent_s3/schema_validator.py:263:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/schema_validator.py:348:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/schema_validator.py:353:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/schema_validator.py:354:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/schema_validator.py:355:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/schema_validator.py:407:4: R0911: Too many return statements (13/6) (too-many-return-statements)
agent_s3/schema_validator.py:407:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/schema_validator.py:469:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/schema_validator.py:493:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/schema_validator.py:486:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/schema_validator.py:549:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/schema_validator.py:507:16: C0415: Import outside toplevel (agent_s3.llm_utils.cached_call_llm) (import-outside-toplevel)
agent_s3/schema_validator.py:538:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/schema_validator.py:469:4: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/schema_validator.py:130:0: W0611: Unused Generic imported from typing (unused-import)
************* Module agent_s3.test_generator
agent_s3/test_generator.py:24:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/test_generator.py:498:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/test_generator.py:498:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/test_generator.py:498:0: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/test_generator.py:597:12: C0415: Import outside toplevel (tools.test_implementation_validator.validate_test_implementations, tools.test_implementation_validator.repair_test_implementations) (import-outside-toplevel)
agent_s3/test_generator.py:612:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_generator.py:617:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_generator.py:637:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_generator.py:638:12: W0707: Consider explicitly re-raising using 'raise TestGenerationError(f'Invalid JSON response: {e}') from e' (raise-missing-from)
agent_s3/test_generator.py:640:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_generator.py:641:12: W0707: Consider explicitly re-raising using 'raise TestGenerationError(f'Invalid response structure: {e}') from e' (raise-missing-from)
agent_s3/test_generator.py:644:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_generator.py:646:8: W0707: Consider explicitly re-raising using 'raise TestGenerationError(f'Error generating test implementations: {e}') from e' (raise-missing-from)
agent_s3/test_generator.py:12:0: W0611: Unused List imported from typing (unused-import)
agent_s3/test_generator.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/test_generator.py:13:0: W0611: Unused datetime imported from datetime (unused-import)
agent_s3/test_generator.py:14:0: W0611: Unused import uuid (unused-import)
agent_s3/test_generator.py:16:0: W0611: Unused defaultdict imported from collections (unused-import)
************* Module agent_s3.config
agent_s3/config.py:20:0: C0103: Constant name "_config_instance" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/config.py:118:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:123:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:128:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:132:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:137:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:144:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:154:0: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:219:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/config.py:219:4: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/config.py:223:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/config.py:295:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/config.py:294:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:296:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:307:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/config.py:308:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:357:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/config.py:354:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:356:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:358:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/config.py:375:8: C0415: Import outside toplevel (random) (import-outside-toplevel)
agent_s3/config.py:376:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/config.py:390:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/config.py:405:4: W0603: Using the global statement (global-statement)
agent_s3/config.py:410:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/config.py:412:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module agent_s3.debugging_manager
agent_s3/debugging_manager.py:1:0: C0302: Too many lines in module (2345/1000) (too-many-lines)
agent_s3/debugging_manager.py:63:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
agent_s3/debugging_manager.py:118:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/debugging_manager.py:212:8: C0103: Attribute name "MAX_GENERATOR_ATTEMPTS" doesn't conform to snake_case naming style (invalid-name)
agent_s3/debugging_manager.py:215:8: C0103: Attribute name "MAX_DEBUGGER_ATTEMPTS" doesn't conform to snake_case naming style (invalid-name)
agent_s3/debugging_manager.py:218:8: C0103: Attribute name "MAX_RESTART_ATTEMPTS" doesn't conform to snake_case naming style (invalid-name)
agent_s3/debugging_manager.py:162:0: R0902: Too many instance attributes (19/7) (too-many-instance-attributes)
agent_s3/debugging_manager.py:316:4: R0913: Too many arguments (9/5) (too-many-arguments)
agent_s3/debugging_manager.py:316:4: R0917: Too many positional arguments (9/5) (too-many-positional-arguments)
agent_s3/debugging_manager.py:316:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/debugging_manager.py:358:42: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:361:24: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/debugging_manager.py:363:24: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:370:24: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:379:28: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:392:32: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:395:40: E1101: Class 'Section' has no 'WARNING' member (no-member)
agent_s3/debugging_manager.py:316:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/debugging_manager.py:316:4: R0915: Too many statements (69/50) (too-many-statements)
agent_s3/debugging_manager.py:575:12: W0621: Redefining name 'field' from outer scope (line 14) (redefined-outer-name)
agent_s3/debugging_manager.py:560:16: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/debugging_manager.py:581:4: R0913: Too many arguments (9/5) (too-many-arguments)
agent_s3/debugging_manager.py:581:4: R0917: Too many positional arguments (9/5) (too-many-positional-arguments)
agent_s3/debugging_manager.py:604:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:605:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/debugging_manager.py:623:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:672:8: C0415: Import outside toplevel (difflib.SequenceMatcher) (import-outside-toplevel)
agent_s3/debugging_manager.py:713:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:815:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:802:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:675:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/debugging_manager.py:829:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/debugging_manager.py:867:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1001:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:988:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:969:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/debugging_manager.py:829:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/debugging_manager.py:1052:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/debugging_manager.py:1170:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1271:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1283:4: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/debugging_manager.py:1519:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1502:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1283:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/debugging_manager.py:1283:4: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/debugging_manager.py:1283:4: R0915: Too many statements (61/50) (too-many-statements)
agent_s3/debugging_manager.py:1531:4: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/debugging_manager.py:1637:4: R0914: Too many local variables (32/15) (too-many-locals)
agent_s3/debugging_manager.py:1684:36: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/debugging_manager.py:1705:40: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/debugging_manager.py:1715:44: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/debugging_manager.py:1679:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/debugging_manager.py:1679:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/debugging_manager.py:1637:4: R0912: Too many branches (28/12) (too-many-branches)
agent_s3/debugging_manager.py:1637:4: R0915: Too many statements (75/50) (too-many-statements)
agent_s3/debugging_manager.py:1815:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/debugging_manager.py:1881:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1878:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1882:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/debugging_manager.py:1828:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/debugging_manager.py:1910:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:1917:8: W0621: Redefining name 're' from outer scope (line 9) (redefined-outer-name)
agent_s3/debugging_manager.py:1917:8: W0404: Reimport 're' (imported line 9) (reimported)
agent_s3/debugging_manager.py:1917:8: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/debugging_manager.py:1941:8: W0621: Redefining name 're' from outer scope (line 9) (redefined-outer-name)
agent_s3/debugging_manager.py:1941:8: W0404: Reimport 're' (imported line 9) (reimported)
agent_s3/debugging_manager.py:1941:8: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/debugging_manager.py:1978:8: W0621: Redefining name 're' from outer scope (line 9) (redefined-outer-name)
agent_s3/debugging_manager.py:1978:8: W0404: Reimport 're' (imported line 9) (reimported)
agent_s3/debugging_manager.py:1978:8: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/debugging_manager.py:1996:8: W0621: Redefining name 'json' from outer scope (line 10) (redefined-outer-name)
agent_s3/debugging_manager.py:1997:8: W0621: Redefining name 're' from outer scope (line 9) (redefined-outer-name)
agent_s3/debugging_manager.py:1996:8: W0404: Reimport 'json' (imported line 10) (reimported)
agent_s3/debugging_manager.py:1996:8: C0415: Import outside toplevel (json) (import-outside-toplevel)
agent_s3/debugging_manager.py:1997:8: W0404: Reimport 're' (imported line 9) (reimported)
agent_s3/debugging_manager.py:1997:8: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/debugging_manager.py:2021:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/debugging_manager.py:2059:4: R0913: Too many arguments (8/5) (too-many-arguments)
agent_s3/debugging_manager.py:2059:4: R0917: Too many positional arguments (8/5) (too-many-positional-arguments)
agent_s3/debugging_manager.py:2335:24: W0612: Unused variable 'phase_count' (unused-variable)
agent_s3/debugging_manager.py:2335:37: W0612: Unused variable 'phase_successes' (unused-variable)
************* Module agent_s3.progress_tracker
agent_s3/progress_tracker.py:129:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/progress_tracker.py:130:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/progress_tracker.py:131:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/progress_tracker.py:132:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/progress_tracker.py:133:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/progress_tracker.py:188:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/progress_tracker.py:189:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/progress_tracker.py:114:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/progress_tracker.py:115:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:146:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:153:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/progress_tracker.py:155:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:193:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/progress_tracker.py:188:13: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:191:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:194:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:214:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/progress_tracker.py:209:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:212:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:215:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:223:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/progress_tracker.py:222:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:224:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/progress_tracker.py:259:0: C0413: Import "from agent_s3.config import Config" should be placed at the top of the module (wrong-import-position)
agent_s3/progress_tracker.py:264:7: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module agent_s3.design_manager
agent_s3/design_manager.py:27:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
agent_s3/design_manager.py:70:19: E1101: Instance of 'RouterAgent' has no 'call_llm_agent' member (no-member)
agent_s3/design_manager.py:108:19: E1101: Instance of 'RouterAgent' has no 'call_llm_agent' member (no-member)
agent_s3/design_manager.py:205:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/design_manager.py:329:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/design_manager.py:325:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/design_manager.py:330:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/design_manager.py:397:4: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/design_manager.py:430:28: E1101: Instance of 'RouterAgent' has no 'call_llm_agent' member (no-member)
agent_s3/design_manager.py:468:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/design_manager.py:442:15: R1716: Simplify chained comparison between the operands (chained-comparison)
agent_s3/design_manager.py:453:16: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/design_manager.py:469:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/design_manager.py:478:20: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/design_manager.py:481:47: E1136: Value 'current_feature' is unsubscriptable (unsubscriptable-object)
agent_s3/design_manager.py:486:24: E1137: 'current_feature' does not support item assignment (unsupported-assignment-operation)
agent_s3/design_manager.py:491:28: E1136: Value 'current_feature' is unsubscriptable (unsubscriptable-object)
agent_s3/design_manager.py:397:4: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/design_manager.py:542:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/design_manager.py:670:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/design_manager.py:630:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/design_manager.py:671:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/design_manager.py:674:4: R0914: Too many local variables (28/15) (too-many-locals)
agent_s3/design_manager.py:674:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/design_manager.py:748:16: W0612: Unused variable 'level2_id' (unused-variable)
agent_s3/design_manager.py:16:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/design_manager.py:17:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/design_manager.py:21:0: W0611: Unused CodeGenerator imported from agent_s3.code_generator (unused-import)
agent_s3/design_manager.py:22:0: W0611: Unused DeploymentManager imported from agent_s3.deployment_manager (unused-import)
************* Module agent_s3.test_spec_validator
agent_s3/test_spec_validator.py:22:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/test_spec_validator.py:105:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/test_spec_validator.py:216:0: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/test_spec_validator.py:216:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/test_spec_validator.py:446:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/test_spec_validator.py:419:8: C0415: Import outside toplevel (json_utils.get_openrouter_json_params, json_utils.extract_json_from_text) (import-outside-toplevel)
agent_s3/test_spec_validator.py:447:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:451:0: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/test_spec_validator.py:549:0: R0914: Too many local variables (28/15) (too-many-locals)
agent_s3/test_spec_validator.py:597:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/test_spec_validator.py:598:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:579:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/test_spec_validator.py:617:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:619:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:629:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:637:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:549:0: R0912: Too many branches (22/12) (too-many-branches)
agent_s3/test_spec_validator.py:660:0: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/test_spec_validator.py:734:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:738:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:752:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:761:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/test_spec_validator.py:761:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/test_spec_validator.py:761:0: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/test_spec_validator.py:807:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/test_spec_validator.py:855:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module agent_s3.workspace_initializer
agent_s3/workspace_initializer.py:11:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
agent_s3/workspace_initializer.py:14:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/workspace_initializer.py:14:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/workspace_initializer.py:66:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:83:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:92:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:101:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:110:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/workspace_initializer.py:37:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/workspace_initializer.py:37:4: R0915: Too many statements (52/50) (too-many-statements)
agent_s3/workspace_initializer.py:99:16: W0612: Unused variable 'llm_status' (unused-variable)
agent_s3/workspace_initializer.py:203:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:236:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:262:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:248:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/workspace_initializer.py:456:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/workspace_initializer.py:6:0: W0611: Unused import os (unused-import)
agent_s3/workspace_initializer.py:9:0: W0611: Unused Dict imported from typing (unused-import)
agent_s3/workspace_initializer.py:9:0: W0611: Unused Any imported from typing (unused-import)
agent_s3/workspace_initializer.py:9:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.prompt_moderator
agent_s3/prompt_moderator.py:473:0: C0325: Unnecessary parens after 'if' keyword (superfluous-parens)
agent_s3/prompt_moderator.py:1:0: C0302: Too many lines in module (1419/1000) (too-many-lines)
agent_s3/prompt_moderator.py:104:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:117:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:120:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/prompt_moderator.py:190:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:229:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:257:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:273:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/prompt_moderator.py:120:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/prompt_moderator.py:120:4: R0915: Too many statements (86/50) (too-many-statements)
agent_s3/prompt_moderator.py:401:24: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/prompt_moderator.py:416:23: E1101: Instance of 'PromptModerator' has no '_extract_plan_sections' member (no-member)
agent_s3/prompt_moderator.py:452:20: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:486:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:386:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/prompt_moderator.py:386:4: R0912: Too many branches (23/12) (too-many-branches)
agent_s3/prompt_moderator.py:386:4: R0915: Too many statements (54/50) (too-many-statements)
agent_s3/prompt_moderator.py:416:12: W0612: Unused variable 'sections' (unused-variable)
agent_s3/prompt_moderator.py:503:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/prompt_moderator.py:562:36: E1101: Instance of 'PromptModerator' has no '_extract_before_after_content' member (no-member)
agent_s3/prompt_moderator.py:582:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/prompt_moderator.py:606:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:503:4: R0912: Too many branches (22/12) (too-many-branches)
agent_s3/prompt_moderator.py:503:4: R0915: Too many statements (52/50) (too-many-statements)
agent_s3/prompt_moderator.py:617:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/prompt_moderator.py:670:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/prompt_moderator.py:639:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/prompt_moderator.py:628:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/prompt_moderator.py:628:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/prompt_moderator.py:628:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/prompt_moderator.py:617:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/prompt_moderator.py:690:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:717:27: E0602: Undefined variable 'json' (undefined-variable)
agent_s3/prompt_moderator.py:768:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/prompt_moderator.py:786:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:855:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:866:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/prompt_moderator.py:940:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/prompt_moderator.py:866:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/prompt_moderator.py:866:4: R0915: Too many statements (60/50) (too-many-statements)
agent_s3/prompt_moderator.py:1011:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/prompt_moderator.py:1027:8: C0104: Disallowed name "bar" (disallowed-name)
agent_s3/prompt_moderator.py:1039:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/prompt_moderator.py:1127:14: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/prompt_moderator.py:1132:16: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/prompt_moderator.py:1194:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/prompt_moderator.py:1194:4: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/prompt_moderator.py:1194:4: R0915: Too many statements (69/50) (too-many-statements)
agent_s3/prompt_moderator.py:1306:39: W0613: Unused argument 'plan' (unused-argument)
agent_s3/prompt_moderator.py:56:50: E0203: Access to member '_preferred_editor' before its definition line 79 (access-member-before-definition)
agent_s3/prompt_moderator.py:57:19: E0203: Access to member '_preferred_editor' before its definition line 79 (access-member-before-definition)
agent_s3/prompt_moderator.py:79:8: W0201: Attribute '_preferred_editor' defined outside __init__ (attribute-defined-outside-init)
agent_s3/prompt_moderator.py:13:0: R0904: Too many public methods (26/20) (too-many-public-methods)
agent_s3/prompt_moderator.py:5:0: W0611: Unused import re (unused-import)
agent_s3/prompt_moderator.py:9:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.database_manager
agent_s3/database_manager.py:40:0: C0305: Trailing newlines (trailing-newlines)
************* Module agent_s3.planner_json_enforced
agent_s3/planner_json_enforced.py:1:0: C0302: Too many lines in module (2908/1000) (too-many-lines)
agent_s3/planner_json_enforced.py:23:0: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/planner_json_enforced.py:23:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/planner_json_enforced.py:113:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:113:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:94:0: R0912: Too many branches (30/12) (too-many-branches)
agent_s3/planner_json_enforced.py:94:0: R0915: Too many statements (63/50) (too-many-statements)
agent_s3/planner_json_enforced.py:297:0: C0413: Import "from agent_s3.tools.implementation_validator import validate_implementation_plan, repair_implementation_plan" should be placed at the top of the module (wrong-import-position)
agent_s3/planner_json_enforced.py:303:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/planner_json_enforced.py:328:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:310:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner_json_enforced.py:329:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:349:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:336:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner_json_enforced.py:350:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1009:0: R0914: Too many local variables (40/15) (too-many-locals)
agent_s3/planner_json_enforced.py:1185:12: W0621: Redefining name 'extract_json_from_text' from outer scope (line 21) (redefined-outer-name)
agent_s3/planner_json_enforced.py:1185:12: W0621: Redefining name 'repair_json_structure' from outer scope (line 94) (redefined-outer-name)
agent_s3/planner_json_enforced.py:1029:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1035:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:1099:4: C0415: Import outside toplevel (json_utils.get_openrouter_json_params) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1134:12: C0415: Import outside toplevel (test_spec_validator.validate_and_repair_test_specifications) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1161:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1163:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1182:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1185:12: W0404: Reimport 'extract_json_from_text' (imported line 21) (reimported)
agent_s3/planner_json_enforced.py:1185:12: C0415: Import outside toplevel (json_utils.extract_json_from_text, json_utils.repair_json_structure) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1209:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:1210:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1212:12: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Invalid JSON response: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1215:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1216:12: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Invalid response structure: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1219:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1220:8: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Error generating refined test specifications: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1009:0: R0912: Too many branches (34/12) (too-many-branches)
agent_s3/planner_json_enforced.py:1009:0: R0915: Too many statements (89/50) (too-many-statements)
agent_s3/planner_json_enforced.py:1060:4: W0612: Unused variable 'input_data' (unused-variable)
agent_s3/planner_json_enforced.py:1441:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/planner_json_enforced.py:1441:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/planner_json_enforced.py:1456:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:1457:8: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'LLM call failed after retries: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1441:101: W0613: Unused argument 'retries' (unused-argument)
agent_s3/planner_json_enforced.py:1441:119: W0613: Unused argument 'initial_backoff' (unused-argument)
agent_s3/planner_json_enforced.py:1459:0: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/planner_json_enforced.py:1469:8: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Invalid JSON received from LLM: {e}\nResponse Text: {response_text[:500]}...') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1459:0: R0912: Too many branches (31/12) (too-many-branches)
agent_s3/planner_json_enforced.py:1459:0: R0915: Too many statements (67/50) (too-many-statements)
agent_s3/planner_json_enforced.py:1459:49: W0613: Unused argument 'schema' (unused-argument)
agent_s3/planner_json_enforced.py:1737:0: R0913: Too many arguments (8/5) (too-many-arguments)
agent_s3/planner_json_enforced.py:1737:0: R0917: Too many positional arguments (8/5) (too-many-positional-arguments)
agent_s3/planner_json_enforced.py:1737:0: R0914: Too many local variables (63/15) (too-many-locals)
agent_s3/planner_json_enforced.py:1773:4: W0621: Redefining name 'validate_implementation_plan' from outer scope (line 297) (redefined-outer-name)
agent_s3/planner_json_enforced.py:1770:4: C0415: Import outside toplevel (test_spec_validator.validate_and_repair_test_specifications) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1771:4: C0415: Import outside toplevel (tools.phase_validator.validate_security_concerns) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1772:4: C0415: Import outside toplevel (tools.test_implementation_validator.validate_test_implementations) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1773:4: W0404: Reimport 'validate_implementation_plan' (imported line 297) (reimported)
agent_s3/planner_json_enforced.py:1773:4: C0415: Import outside toplevel (tools.implementation_validator.validate_implementation_plan, tools.implementation_validator._validate_implementation_quality, tools.implementation_validator._validate_implementation_security, tools.implementation_validator._validate_implementation_test_alignment, tools.implementation_validator._calculate_implementation_metrics) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:1831:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:2073:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2079:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2080:12: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Invalid JSON in semantic validation: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:2083:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2084:8: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Error performing semantic validation: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:1737:0: R0912: Too many branches (52/12) (too-many-branches)
agent_s3/planner_json_enforced.py:1737:0: R0915: Too many statements (104/50) (too-many-statements)
agent_s3/planner_json_enforced.py:1867:16: W0641: Possibly unused variable 'test_type' (possibly-unused-variable)
agent_s3/planner_json_enforced.py:1905:12: W0641: Possibly unused variable 'file_path' (possibly-unused-variable)
agent_s3/planner_json_enforced.py:1980:4: W0612: Unused variable 'validation_input' (unused-variable)
agent_s3/planner_json_enforced.py:2184:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/planner_json_enforced.py:2184:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/planner_json_enforced.py:2184:0: R0914: Too many local variables (118/15) (too-many-locals)
agent_s3/planner_json_enforced.py:2481:16: W0621: Redefining name 'validate_implementation_plan' from outer scope (line 297) (redefined-outer-name)
agent_s3/planner_json_enforced.py:2481:16: W0621: Redefining name 'repair_implementation_plan' from outer scope (line 297) (redefined-outer-name)
agent_s3/planner_json_enforced.py:2793:16: W0621: Redefining name 'extract_json_from_text' from outer scope (line 21) (redefined-outer-name)
agent_s3/planner_json_enforced.py:2793:16: W0621: Redefining name 'repair_json_structure' from outer scope (line 94) (redefined-outer-name)
agent_s3/planner_json_enforced.py:2257:4: C0415: Import outside toplevel (json_utils.get_openrouter_json_params) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:2288:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:2274:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2285:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2291:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2294:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2295:20: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'LLM call failed after {max_retries + 1} attempts: {str(last_error)}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:2299:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2321:23: E0601: Using variable 'extract_json_from_text' before assignment (used-before-assignment)
agent_s3/planner_json_enforced.py:2348:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2357:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2373:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2394:31: E1121: Too many positional arguments for function call (too-many-function-args)
agent_s3/planner_json_enforced.py:2397:31: E1121: Too many positional arguments for function call (too-many-function-args)
agent_s3/planner_json_enforced.py:2417:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:2406:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2414:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2418:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2427:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2450:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2455:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2469:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2477:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2481:16: W0404: Reimport 'validate_implementation_plan' (imported line 297) (reimported)
agent_s3/planner_json_enforced.py:2481:16: W0404: Reimport 'repair_implementation_plan' (imported line 297) (reimported)
agent_s3/planner_json_enforced.py:2481:16: C0415: Import outside toplevel (tools.implementation_validator.validate_implementation_plan, tools.implementation_validator.repair_implementation_plan, tools.implementation_validator._validate_implementation_quality, tools.implementation_validator._validate_implementation_security, tools.implementation_validator._validate_implementation_test_alignment, tools.implementation_validator._calculate_implementation_metrics) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:2490:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2491:16: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Implementation validation tools unavailable: {import_error}') from import_error' (raise-missing-from)
agent_s3/planner_json_enforced.py:2532:12: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:2555:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2562:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2564:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2570:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2573:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2600:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2674:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:2664:39: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/planner_json_enforced.py:2675:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2686:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2763:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:2717:42: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/planner_json_enforced.py:2690:12: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/planner_json_enforced.py:2764:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2769:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2782:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2786:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2793:16: W0404: Reimport 'extract_json_from_text' (imported line 21) (reimported)
agent_s3/planner_json_enforced.py:2793:16: C0415: Import outside toplevel (json_utils.extract_json_from_text, json_utils.repair_json_structure) (import-outside-toplevel)
agent_s3/planner_json_enforced.py:2812:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2851:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/planner_json_enforced.py:2836:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2839:28: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/planner_json_enforced.py:2849:32: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2852:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2898:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2899:16: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Failed to extract or repair JSON: {e}  {extract_error}') from extract_error' (raise-missing-from)
agent_s3/planner_json_enforced.py:2902:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2903:12: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Invalid response structure: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:2906:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/planner_json_enforced.py:2907:8: W0707: Consider explicitly re-raising using 'raise JSONPlannerError(f'Error generating implementation plan: {e}') from e' (raise-missing-from)
agent_s3/planner_json_enforced.py:2184:0: R0912: Too many branches (80/12) (too-many-branches)
agent_s3/planner_json_enforced.py:2184:0: R0915: Too many statements (298/50) (too-many-statements)
agent_s3/planner_json_enforced.py:16:0: W0611: Unused import os (unused-import)
agent_s3/planner_json_enforced.py:18:0: W0611: Unused import warnings (unused-import)
agent_s3/planner_json_enforced.py:297:0: W0611: Unused validate_implementation_plan imported from agent_s3.tools.implementation_validator (unused-import)
agent_s3/planner_json_enforced.py:297:0: W0611: Unused repair_implementation_plan imported from agent_s3.tools.implementation_validator (unused-import)
************* Module agent_s3.task_resumer
agent_s3/task_resumer.py:73:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/task_resumer.py:174:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_resumer.py:198:55: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/task_resumer.py:270:16: W0212: Access to a protected member _execute_changes of a client class (protected-access)
agent_s3/task_resumer.py:249:8: W0612: Unused variable 'code_context' (unused-variable)
agent_s3/task_resumer.py:309:20: W0212: Access to a protected member _create_pr of a client class (protected-access)
agent_s3/task_resumer.py:331:20: W0212: Access to a protected member _execute_changes_atomically of a client class (protected-access)
agent_s3/task_resumer.py:338:20: W0212: Access to a protected member _run_tests_after_changes of a client class (protected-access)
agent_s3/task_resumer.py:345:20: W0212: Access to a protected member _analyze_test_results of a client class (protected-access)
agent_s3/task_resumer.py:350:24: W0212: Access to a protected member _run_tests_after_changes of a client class (protected-access)
agent_s3/task_resumer.py:357:20: W0212: Access to a protected member _execute_changes of a client class (protected-access)
agent_s3/task_resumer.py:278:4: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/task_resumer.py:278:4: R0915: Too many statements (56/50) (too-many-statements)
agent_s3/task_resumer.py:287:8: W0612: Unused variable 'test_results' (unused-variable)
agent_s3/task_resumer.py:396:20: W0212: Access to a protected member _create_pr_branch of a client class (protected-access)
agent_s3/task_resumer.py:397:20: W0212: Access to a protected member _stage_pr_changes of a client class (protected-access)
agent_s3/task_resumer.py:398:20: W0212: Access to a protected member _commit_pr_changes of a client class (protected-access)
agent_s3/task_resumer.py:399:20: W0212: Access to a protected member _push_pr_branch of a client class (protected-access)
agent_s3/task_resumer.py:400:20: W0212: Access to a protected member _submit_pr of a client class (protected-access)
agent_s3/task_resumer.py:407:20: W0212: Access to a protected member _commit_pr_changes of a client class (protected-access)
agent_s3/task_resumer.py:408:20: W0212: Access to a protected member _push_pr_branch of a client class (protected-access)
agent_s3/task_resumer.py:409:20: W0212: Access to a protected member _submit_pr of a client class (protected-access)
agent_s3/task_resumer.py:416:20: W0212: Access to a protected member _push_pr_branch of a client class (protected-access)
agent_s3/task_resumer.py:417:20: W0212: Access to a protected member _submit_pr of a client class (protected-access)
agent_s3/task_resumer.py:424:20: W0212: Access to a protected member _submit_pr of a client class (protected-access)
agent_s3/task_resumer.py:431:20: W0212: Access to a protected member _create_pr of a client class (protected-access)
agent_s3/task_resumer.py:361:4: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/task_resumer.py:361:4: R0915: Too many statements (53/50) (too-many-statements)
agent_s3/task_resumer.py:375:8: W0612: Unused variable 'commit_sha' (unused-variable)
agent_s3/task_resumer.py:6:0: W0611: Unused import os (unused-import)
agent_s3/task_resumer.py:9:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/task_resumer.py:11:0: W0611: Unused Dict imported from typing (unused-import)
agent_s3/task_resumer.py:11:0: W0611: Unused Any imported from typing (unused-import)
agent_s3/task_resumer.py:11:0: W0611: Unused List imported from typing (unused-import)
agent_s3/task_resumer.py:11:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.deployment_manager
agent_s3/deployment_manager.py:1:0: C0302: Too many lines in module (1471/1000) (too-many-lines)
agent_s3/deployment_manager.py:25:4: R0913: Too many arguments (8/5) (too-many-arguments)
agent_s3/deployment_manager.py:25:4: R0917: Too many positional arguments (8/5) (too-many-positional-arguments)
agent_s3/deployment_manager.py:79:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/deployment_manager.py:116:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
agent_s3/deployment_manager.py:119:4: R0913: Too many arguments (12/5) (too-many-arguments)
agent_s3/deployment_manager.py:119:4: R0917: Too many positional arguments (12/5) (too-many-positional-arguments)
agent_s3/deployment_manager.py:204:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/deployment_manager.py:227:36: W0613: Unused argument 'design_file' (unused-argument)
agent_s3/deployment_manager.py:398:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:333:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/deployment_manager.py:457:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:420:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/deployment_manager.py:408:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/deployment_manager.py:500:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:488:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/deployment_manager.py:587:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:531:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/deployment_manager.py:557:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/deployment_manager.py:530:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/deployment_manager.py:518:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/deployment_manager.py:518:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/deployment_manager.py:621:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:610:31: W0612: Unused variable 'output' (unused-variable)
agent_s3/deployment_manager.py:666:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:701:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:752:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/deployment_manager.py:863:19: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/deployment_manager.py:1162:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:1147:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/deployment_manager.py:1159:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/deployment_manager.py:1183:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:1181:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/deployment_manager.py:1197:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:1195:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/deployment_manager.py:1213:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:1211:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/deployment_manager.py:1236:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:1369:4: R0914: Too many local variables (28/15) (too-many-locals)
agent_s3/deployment_manager.py:1468:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/deployment_manager.py:14:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/deployment_manager.py:15:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/deployment_manager.py:16:0: W0611: Unused urlparse imported from urllib.parse (unused-import)
************* Module agent_s3.router_agent
agent_s3/router_agent.py:38:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/router_agent.py:38:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/router_agent.py:38:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/router_agent.py:56:8: W0707: Consider explicitly re-raising using 'raise ValueError(f'llm.json entry {index} validation error at {path}: {e.message}') from e' (raise-missing-from)
agent_s3/router_agent.py:65:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:67:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/router_agent.py:84:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:87:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:89:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:94:8: W0707: Consider explicitly re-raising using 'raise ValueError(f'Error decoding llm.json: {e}') from e' (raise-missing-from)
agent_s3/router_agent.py:96:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:108:8: W0603: Using the global statement (global-statement)
agent_s3/router_agent.py:140:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:146:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:160:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:167:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:180:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/router_agent.py:172:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:175:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:181:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:183:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/router_agent.py:186:4: R0913: Too many arguments (10/5) (too-many-arguments)
agent_s3/router_agent.py:186:4: R0917: Too many positional arguments (10/5) (too-many-positional-arguments)
agent_s3/router_agent.py:186:4: R0914: Too many local variables (29/15) (too-many-locals)
agent_s3/router_agent.py:308:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/router_agent.py:347:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/router_agent.py:186:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/router_agent.py:186:4: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/router_agent.py:186:4: R0915: Too many statements (66/50) (too-many-statements)
agent_s3/router_agent.py:356:4: R0913: Too many arguments (14/5) (too-many-arguments)
agent_s3/router_agent.py:356:4: R0917: Too many positional arguments (14/5) (too-many-positional-arguments)
agent_s3/router_agent.py:356:4: R0914: Too many local variables (101/15) (too-many-locals)
agent_s3/router_agent.py:520:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/router_agent.py:684:8: E0102: function already defined line 482 (function-redefined)
agent_s3/router_agent.py:730:12: W0707: Consider explicitly re-raising using 'except Exception as exc' and 'raise TimeoutError(f'API call to {model_name} timed out.') from exc' (raise-missing-from)
agent_s3/router_agent.py:737:12: W0707: Consider explicitly re-raising using 'raise ConnectionError(error_msg) from e' (raise-missing-from)
agent_s3/router_agent.py:743:12: W0707: Consider explicitly re-raising using 'raise ValueError(error_msg) from e' (raise-missing-from)
agent_s3/router_agent.py:356:4: R0912: Too many branches (56/12) (too-many-branches)
agent_s3/router_agent.py:356:4: R0915: Too many statements (216/50) (too-many-statements)
agent_s3/router_agent.py:754:8: W0603: Using the global statement (global-statement)
agent_s3/router_agent.py:860:4: C0103: Constant name "plan_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:865:4: C0103: Constant name "gen_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:870:4: C0103: Constant name "scaffold_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:875:4: C0103: Constant name "missing_role_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:880:4: C0103: Constant name "invalid_role_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:884:4: C0103: Constant name "large_query" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/router_agent.py:10:0: C0411: standard import "traceback" should be placed before third party import "requests" (wrong-import-order)
agent_s3/router_agent.py:11:0: C0411: standard import "typing.Dict" should be placed before third party import "requests" (wrong-import-order)
************* Module agent_s3.cli
agent_s3/cli.py:104:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/cli.py:87:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/cli.py:102:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/cli.py:150:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/cli.py:169:8: C0415: Import outside toplevel (agent_s3.command_processor.CommandProcessor) (import-outside-toplevel)
agent_s3/cli.py:183:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/cli.py:185:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/cli.py:188:0: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/cli.py:306:12: W0621: Redefining name 'Path' from outer scope (line 8) (redefined-outer-name)
agent_s3/cli.py:226:8: C0415: Import outside toplevel (agent_s3.auth.authenticate_user) (import-outside-toplevel)
agent_s3/cli.py:261:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/cli.py:262:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/cli.py:261:4: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/cli.py:332:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/cli.py:272:8: W0404: Reimport 'json' (imported line 6) (reimported)
agent_s3/cli.py:272:8: C0415: Import outside toplevel (json) (import-outside-toplevel)
agent_s3/cli.py:278:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/cli.py:300:16: E1101: Instance of 'Coordinator' has no 'execute_terminal_command' member (no-member)
agent_s3/cli.py:306:12: W0404: Reimport 'Path' (imported line 8) (reimported)
agent_s3/cli.py:306:12: C0415: Import outside toplevel (pathlib.Path) (import-outside-toplevel)
agent_s3/cli.py:307:12: C0415: Import outside toplevel (glob) (import-outside-toplevel)
agent_s3/cli.py:314:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/cli.py:188:0: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/cli.py:188:0: R0915: Too many statements (75/50) (too-many-statements)
agent_s3/cli.py:9:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/cli.py:9:0: W0611: Unused List imported from typing (unused-import)
agent_s3/cli.py:9:0: W0611: Unused Dict imported from typing (unused-import)
agent_s3/cli.py:9:0: W0611: Unused Any imported from typing (unused-import)
************* Module agent_s3.llm_utils
agent_s3/llm_utils.py:14:7: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:13:4: E0401: Unable to import 'supabase' (import-error)
agent_s3/llm_utils.py:15:4: C0103: Constant name "create_client" doesn't conform to UPPER_CASE naming style (invalid-name)
agent_s3/llm_utils.py:47:0: C0413: Import "from agent_s3.cache.helpers import read_cache, write_cache" should be placed at the top of the module (wrong-import-position)
agent_s3/llm_utils.py:48:0: C0413: Import "from agent_s3.progress_tracker import progress_tracker" should be placed at the top of the module (wrong-import-position)
agent_s3/llm_utils.py:51:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/llm_utils.py:124:0: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/llm_utils.py:152:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:147:12: C0415: Import outside toplevel (agent_s3.auth.load_token) (import-outside-toplevel)
agent_s3/llm_utils.py:153:12: W0127: Assigning the same variable 'github_token' to itself (self-assigning-variable)
agent_s3/llm_utils.py:163:12: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/llm_utils.py:171:12: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/llm_utils.py:174:12: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/llm_utils.py:220:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/llm_utils.py:231:8: E1128: Assigning result of a function call, where the function returns None (assignment-from-none)
agent_s3/llm_utils.py:238:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:239:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/llm_utils.py:124:0: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/llm_utils.py:124:0: R0912: Too many branches (19/12) (too-many-branches)
agent_s3/llm_utils.py:124:0: R0915: Too many statements (51/50) (too-many-statements)
agent_s3/llm_utils.py:250:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/llm_utils.py:250:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/llm_utils.py:250:0: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/llm_utils.py:280:12: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/llm_utils.py:281:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/llm_utils.py:279:8: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/llm_utils.py:301:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:362:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:420:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:376:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/llm_utils.py:435:18: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/llm_utils.py:250:0: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/llm_utils.py:250:0: R0915: Too many statements (69/50) (too-many-statements)
agent_s3/llm_utils.py:440:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/llm_utils.py:467:8: C0415: Import outside toplevel (agent_s3.config) (import-outside-toplevel)
agent_s3/llm_utils.py:539:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/llm_utils.py:529:24: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/llm_utils.py:509:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/llm_utils.py:440:0: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/llm_utils.py:440:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/llm_utils.py:16:0: C0411: standard import "json" should be placed before third party import "requests" (wrong-import-order)
agent_s3/llm_utils.py:17:0: C0411: standard import "os" should be placed before third party import "requests" (wrong-import-order)
agent_s3/llm_utils.py:18:0: C0411: standard import "threading" should be placed before third party import "requests" (wrong-import-order)
agent_s3/llm_utils.py:20:0: C0411: standard import "logging" should be placed before third party imports "requests", "numpy" (wrong-import-order)
agent_s3/llm_utils.py:8:0: W0611: Unused Callable imported from typing (unused-import)
agent_s3/llm_utils.py:8:0: W0611: Unused Type imported from typing (unused-import)
agent_s3/llm_utils.py:8:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/llm_utils.py:8:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/llm_utils.py:17:0: W0611: Unused import os (unused-import)
agent_s3/llm_utils.py:18:0: W0611: Unused import threading (unused-import)
agent_s3/llm_utils.py:19:0: W0611: Unused numpy imported as np (unused-import)
************* Module agent_s3.user_config
agent_s3/user_config.py:19:11: W0718: Catching too general exception Exception (broad-exception-caught)
************* Module agent_s3.task_state_manager
agent_s3/task_state_manager.py:192:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
agent_s3/task_state_manager.py:195:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/task_state_manager.py:195:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/task_state_manager.py:244:0: R0902: Too many instance attributes (11/7) (too-many-instance-attributes)
agent_s3/task_state_manager.py:310:0: R0902: Too many instance attributes (13/7) (too-many-instance-attributes)
agent_s3/task_state_manager.py:313:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/task_state_manager.py:313:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/task_state_manager.py:461:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:450:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/task_state_manager.py:459:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:462:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:479:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:499:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:483:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/task_state_manager.py:487:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:494:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:497:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:500:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:554:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:530:94: W0640: Cell variable task_dir defined in loop (cell-var-from-loop)
agent_s3/task_state_manager.py:547:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:535:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/task_state_manager.py:548:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:555:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:570:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:583:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:581:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:584:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:630:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:628:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:631:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:633:4: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/task_state_manager.py:647:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:716:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/task_state_manager.py:652:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/task_state_manager.py:677:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:688:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/task_state_manager.py:699:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:711:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:714:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/task_state_manager.py:717:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module agent_s3.command_processor
agent_s3/command_processor.py:1:0: C0302: Too many lines in module (1155/1000) (too-many-lines)
agent_s3/command_processor.py:74:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:103:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:99:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:81:35: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:184:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:171:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:243:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:199:4: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
agent_s3/command_processor.py:294:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:280:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:258:36: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:355:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:335:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/command_processor.py:392:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:371:39: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:418:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:397:41: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:466:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:449:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:456:16: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/command_processor.py:423:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/command_processor.py:516:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:495:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:508:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:471:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/command_processor.py:573:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:545:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:564:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:521:4: R0911: Too many return statements (10/6) (too-many-return-statements)
agent_s3/command_processor.py:521:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/command_processor.py:660:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:595:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/command_processor.py:599:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:578:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/command_processor.py:578:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/command_processor.py:702:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:752:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:732:37: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:773:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:769:12: C0415: Import outside toplevel (agent_s3.router_agent.RouterAgent) (import-outside-toplevel)
agent_s3/command_processor.py:757:48: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:794:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:791:22: W0212: Access to a protected member _gather_context of a client class (protected-access)
agent_s3/command_processor.py:778:38: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:817:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:854:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:822:36: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:899:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:885:16: C0415: Import outside toplevel (agent_s3.prompt_moderator.PromptModerator) (import-outside-toplevel)
agent_s3/command_processor.py:891:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:939:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/command_processor.py:935:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/command_processor.py:945:31: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:955:31: W0613: Unused argument 'args' (unused-argument)
agent_s3/command_processor.py:1115:12: W0212: Access to a protected member _log of a client class (protected-access)
agent_s3/command_processor.py:1119:12: C0415: Import outside toplevel (agent_s3.enhanced_scratchpad_manager.LogLevel) (import-outside-toplevel)
agent_s3/command_processor.py:1146:16: C0415: Import outside toplevel (agent_s3.enhanced_scratchpad_manager.LogLevel) (import-outside-toplevel)
agent_s3/command_processor.py:11:0: W0611: Unused Dict imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused Any imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused List imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/command_processor.py:11:0: W0611: Unused Callable imported from typing (unused-import)
************* Module agent_s3.planning_helper
agent_s3/planning_helper.py:27:24: E1101: Module 'agent_s3.pre_planner_json_enforced' has no 'pre_planning_workflow' member (no-member)
agent_s3/planning_helper.py:5:0: W0611: Unused FeatureGroupProcessor imported from feature_group_processor (unused-import)
************* Module agent_s3.pre_planner_json_enforced
agent_s3/pre_planner_json_enforced.py:909:0: C0304: Final newline missing (missing-final-newline)
agent_s3/pre_planner_json_enforced.py:156:0: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/pre_planner_json_enforced.py:223:0: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/pre_planner_json_enforced.py:242:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planner_json_enforced.py:236:8: C0415: Import outside toplevel (agent_s3.pre_planner_json_validator.PrePlannerJsonValidator) (import-outside-toplevel)
agent_s3/pre_planner_json_enforced.py:255:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planner_json_enforced.py:247:8: C0415: Import outside toplevel (agent_s3.tools.plan_validator.validate_pre_plan) (import-outside-toplevel)
agent_s3/pre_planner_json_enforced.py:264:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planner_json_enforced.py:260:8: C0415: Import outside toplevel (agent_s3.planner_json_enforced.validate_pre_planning_for_planner) (import-outside-toplevel)
agent_s3/pre_planner_json_enforced.py:260:8: E0611: No name 'validate_pre_planning_for_planner' in module 'agent_s3.planner_json_enforced' (no-name-in-module)
agent_s3/pre_planner_json_enforced.py:238:41: W0612: Unused variable 'validated_data' (unused-variable)
agent_s3/pre_planner_json_enforced.py:269:0: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/pre_planner_json_enforced.py:291:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/pre_planner_json_enforced.py:291:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:388:8: C0415: Import outside toplevel (agent_s3.complexity_analyzer.ComplexityAnalyzer) (import-outside-toplevel)
agent_s3/pre_planner_json_enforced.py:269:0: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/pre_planner_json_enforced.py:444:12: W1201: Use lazy % formatting in logging functions (logging-not-lazy)
agent_s3/pre_planner_json_enforced.py:481:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/pre_planner_json_enforced.py:485:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_enforced.py:493:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planner_json_enforced.py:487:23: E1120: No value for argument 'schema' in function call (no-value-for-parameter)
agent_s3/pre_planner_json_enforced.py:489:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/pre_planner_json_enforced.py:419:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/pre_planner_json_enforced.py:419:36: W0613: Unused argument 'original_request' (unused-argument)
agent_s3/pre_planner_json_enforced.py:488:23: W0612: Unused variable 'validation_msg2' (unused-variable)
agent_s3/pre_planner_json_enforced.py:493:8: W0612: Unused variable 'repair_e' (unused-variable)
agent_s3/pre_planner_json_enforced.py:496:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/pre_planner_json_enforced.py:548:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_enforced.py:560:32: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_enforced.py:516:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:516:4: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:585:40: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_enforced.py:516:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:516:4: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:607:40: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_enforced.py:496:0: R0912: Too many branches (29/12) (too-many-branches)
agent_s3/pre_planner_json_enforced.py:496:0: R0915: Too many statements (58/50) (too-many-statements)
agent_s3/pre_planner_json_enforced.py:516:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_enforced.py:567:32: W0612: Unused variable 'test_idx' (unused-variable)
agent_s3/pre_planner_json_enforced.py:846:0: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/pre_planner_json_enforced.py:862:4: C0415: Import outside toplevel (traceback) (import-outside-toplevel)
agent_s3/pre_planner_json_enforced.py:900:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planner_json_enforced.py:890:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/pre_planner_json_enforced.py:906:4: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/pre_planner_json_enforced.py:17:0: W0611: Unused import re (unused-import)
agent_s3/pre_planner_json_enforced.py:19:0: W0611: Unused import sys (unused-import)
agent_s3/pre_planner_json_enforced.py:20:0: W0611: Unused import functools (unused-import)
agent_s3/pre_planner_json_enforced.py:21:0: W0611: Unused List imported from typing (unused-import)
agent_s3/pre_planner_json_enforced.py:21:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused AgentS3BaseError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused ValidationError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused SchemaError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused ComplexityError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused RepairError imported from agent_s3.pre_planning_errors (unused-import)
agent_s3/pre_planner_json_enforced.py:23:0: W0611: Unused handle_pre_planning_errors imported from agent_s3.pre_planning_errors (unused-import)
************* Module agent_s3.pre_planner_json_validator
agent_s3/pre_planner_json_validator.py:198:0: C0325: Unnecessary parens after 'not' keyword (superfluous-parens)
agent_s3/pre_planner_json_validator.py:29:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
agent_s3/pre_planner_json_validator.py:133:12: W0621: Redefining name 'field' from outer scope (line 20) (redefined-outer-name)
agent_s3/pre_planner_json_validator.py:162:12: W0621: Redefining name 'field' from outer scope (line 20) (redefined-outer-name)
agent_s3/pre_planner_json_validator.py:190:12: W0621: Redefining name 'field' from outer scope (line 20) (redefined-outer-name)
agent_s3/pre_planner_json_validator.py:227:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:205:4: R0912: Too many branches (26/12) (too-many-branches)
agent_s3/pre_planner_json_validator.py:315:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/pre_planner_json_validator.py:361:20: W0621: Redefining name 'field' from outer scope (line 20) (redefined-outer-name)
agent_s3/pre_planner_json_validator.py:338:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:338:8: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:387:8: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:315:4: R0912: Too many branches (32/12) (too-many-branches)
agent_s3/pre_planner_json_validator.py:387:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:420:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/pre_planner_json_validator.py:474:42: W0613: Unused argument 'data' (unused-argument)
agent_s3/pre_planner_json_validator.py:524:4: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/pre_planner_json_validator.py:573:40: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_validator.py:544:8: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:594:48: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_validator.py:544:8: R1702: Too many nested blocks (10/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:611:40: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_validator.py:611:52: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/pre_planner_json_validator.py:544:8: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/pre_planner_json_validator.py:617:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planner_json_validator.py:524:4: R0912: Too many branches (30/12) (too-many-branches)
agent_s3/pre_planner_json_validator.py:19:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/pre_planner_json_validator.py:19:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/pre_planner_json_validator.py:21:0: W0611: Unused datetime imported from datetime (unused-import)
agent_s3/pre_planner_json_validator.py:23:0: W0611: Unused JSONValidationError imported from agent_s3.pre_planner_json_enforced (unused-import)
************* Module agent_s3.signature_normalizer
agent_s3/signature_normalizer.py:330:0: W0301: Unnecessary semicolon (unnecessary-semicolon)
agent_s3/signature_normalizer.py:332:0: W0301: Unnecessary semicolon (unnecessary-semicolon)
agent_s3/signature_normalizer.py:334:0: W0301: Unnecessary semicolon (unnecessary-semicolon)
agent_s3/signature_normalizer.py:336:0: W0301: Unnecessary semicolon (unnecessary-semicolon)
agent_s3/signature_normalizer.py:57:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/signature_normalizer.py:69:16: W0612: Unused variable 'feature_log_prefix' (unused-variable)
agent_s3/signature_normalizer.py:101:43: W0613: Unused argument 'element_idx' (unused-argument)
agent_s3/signature_normalizer.py:143:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/signature_normalizer.py:143:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/signature_normalizer.py:144:48: W0613: Unused argument 'group_name' (unused-argument)
agent_s3/signature_normalizer.py:267:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/signature_normalizer.py:293:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/signature_normalizer.py:297:57: W0613: Unused argument 'name' (unused-argument)
agent_s3/signature_normalizer.py:319:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/signature_normalizer.py:329:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/signature_normalizer.py:313:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/signature_normalizer.py:343:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/signature_normalizer.py:21:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/signature_normalizer.py:13:0: W0611: Unused List imported from typing (unused-import)
agent_s3/signature_normalizer.py:13:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/signature_normalizer.py:13:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/signature_normalizer.py:17:0: W0611: Unused validate_code_syntax imported from agent_s3.tools.plan_validator (unused-import)
************* Module agent_s3.file_history_analyzer
agent_s3/file_history_analyzer.py:27:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/file_history_analyzer.py:90:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/file_history_analyzer.py:57:16: C0415: Import outside toplevel (zoneinfo.ZoneInfo) (import-outside-toplevel)
agent_s3/file_history_analyzer.py:61:16: C0415: Import outside toplevel (datetime.timezone) (import-outside-toplevel)
agent_s3/file_history_analyzer.py:88:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/file_history_analyzer.py:6:0: W0611: Unused import os (unused-import)
agent_s3/file_history_analyzer.py:10:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.pre_planning_validator
agent_s3/pre_planning_validator.py:167:32: W0612: Unused variable 'prev_index' (unused-variable)
agent_s3/pre_planning_validator.py:208:12: W0612: Unused variable 'i' (unused-variable)
agent_s3/pre_planning_validator.py:209:16: W0612: Unused variable 'j' (unused-variable)
agent_s3/pre_planning_validator.py:8:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/pre_planning_validator.py:10:0: W0611: Unused ValidationError imported from agent_s3.pre_planning_errors (unused-import)
************* Module agent_s3.error_handler
agent_s3/error_handler.py:38:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/error_handler.py:38:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/error_handler.py:41:8: W0621: Redefining name 'logger' from outer scope (line 23) (redefined-outer-name)
agent_s3/error_handler.py:62:4: R0913: Too many arguments (9/5) (too-many-arguments)
agent_s3/error_handler.py:62:4: R0917: Too many positional arguments (9/5) (too-many-positional-arguments)
agent_s3/error_handler.py:62:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/error_handler.py:122:12: C0415: Import outside toplevel (agent_s3.errors.PlanningError, agent_s3.errors.GenerationError, agent_s3.errors.CoordinationError, agent_s3.errors.AuthenticationError, agent_s3.errors.NetworkError, agent_s3.errors.DatabaseError, agent_s3.errors.DebuggingError) (import-outside-toplevel)
agent_s3/error_handler.py:154:12: E0704: The raise statement is not inside an except clause (misplaced-bare-raise)
agent_s3/error_handler.py:62:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/error_handler.py:158:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/error_handler.py:158:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/error_handler.py:187:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/error_handler.py:212:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/error_handler.py:212:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/error_handler.py:235:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/error_handler.py:247:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/error_handler.py:247:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/error_handler.py:250:4: W0621: Redefining name 'logger' from outer scope (line 23) (redefined-outer-name)
agent_s3/error_handler.py:284:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/error_handler.py:289:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/error_handler.py:301:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/error_handler.py:307:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/error_handler.py:277:8: R1710: Either all return statements in a function should return an expression, or none of them should. (inconsistent-return-statements)
agent_s3/error_handler.py:10:0: W0611: Unused import traceback (unused-import)
agent_s3/error_handler.py:14:0: W0611: Unused categorize_exception imported from agent_s3.errors (unused-import)
agent_s3/error_handler.py:14:0: W0611: Unused log_exception imported from agent_s3.errors (unused-import)
************* Module agent_s3.feature_group_processor
agent_s3/feature_group_processor.py:33:4: R0914: Too many local variables (44/15) (too-many-locals)
agent_s3/feature_group_processor.py:274:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:257:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:90:20: C0415: Import outside toplevel (planner.Planner) (import-outside-toplevel)
agent_s3/feature_group_processor.py:91:20: C0415: Import outside toplevel (planner_json_enforced.generate_architecture_review) (import-outside-toplevel)
agent_s3/feature_group_processor.py:91:20: E0611: No name 'generate_architecture_review' in module 'agent_s3.planner_json_enforced' (no-name-in-module)
agent_s3/feature_group_processor.py:116:20: C0415: Import outside toplevel (planner_json_enforced.generate_refined_test_specifications) (import-outside-toplevel)
agent_s3/feature_group_processor.py:141:20: C0415: Import outside toplevel (planner_json_enforced.generate_test_implementations) (import-outside-toplevel)
agent_s3/feature_group_processor.py:141:20: E0611: No name 'generate_test_implementations' in module 'agent_s3.planner_json_enforced' (no-name-in-module)
agent_s3/feature_group_processor.py:171:20: C0415: Import outside toplevel (planner_json_enforced.generate_implementation_plan) (import-outside-toplevel)
agent_s3/feature_group_processor.py:219:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:49:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/feature_group_processor.py:198:24: C0415: Import outside toplevel (planner_json_enforced.validate_planning_semantic_coherence) (import-outside-toplevel)
agent_s3/feature_group_processor.py:33:4: R0915: Too many statements (83/50) (too-many-statements)
agent_s3/feature_group_processor.py:151:20: W0612: Unused variable 'test_strategy' (unused-variable)
agent_s3/feature_group_processor.py:90:20: W0611: Unused Planner imported from planner (unused-import)
agent_s3/feature_group_processor.py:281:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/feature_group_processor.py:391:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:297:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/feature_group_processor.py:373:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:386:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:281:4: R0912: Too many branches (28/12) (too-many-branches)
agent_s3/feature_group_processor.py:281:4: R0915: Too many statements (62/50) (too-many-statements)
agent_s3/feature_group_processor.py:373:20: W0612: Unused variable 'e' (unused-variable)
agent_s3/feature_group_processor.py:399:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/feature_group_processor.py:399:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/feature_group_processor.py:401:8: W0621: Redefining name 'uuid' from outer scope (line 9) (redefined-outer-name)
agent_s3/feature_group_processor.py:401:8: W0404: Reimport 'uuid' (imported line 9) (reimported)
agent_s3/feature_group_processor.py:401:8: C0415: Import outside toplevel (uuid) (import-outside-toplevel)
agent_s3/feature_group_processor.py:399:168: W0613: Unused argument 'task_description' (unused-argument)
agent_s3/feature_group_processor.py:440:4: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/feature_group_processor.py:451:65: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/feature_group_processor.py:571:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/feature_group_processor.py:455:12: C0415: Import outside toplevel (planner_json_enforced.regenerate_consolidated_plan_with_modifications) (import-outside-toplevel)
agent_s3/feature_group_processor.py:455:12: E0611: No name 'regenerate_consolidated_plan_with_modifications' in module 'agent_s3.planner_json_enforced' (no-name-in-module)
agent_s3/feature_group_processor.py:457:12: C0415: Import outside toplevel (agent_s3.tools.implementation_validator.validate_implementation_plan) (import-outside-toplevel)
agent_s3/feature_group_processor.py:466:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/feature_group_processor.py:480:16: C0415: Import outside toplevel (agent_s3.test_spec_validator.extract_element_ids_from_system_design) (import-outside-toplevel)
agent_s3/feature_group_processor.py:453:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/feature_group_processor.py:440:4: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/feature_group_processor.py:440:4: R0915: Too many statements (55/50) (too-many-statements)
agent_s3/feature_group_processor.py:609:8: W0612: Unused variable 'results' (unused-variable)
agent_s3/feature_group_processor.py:6:0: W0611: Unused import json (unused-import)
agent_s3/feature_group_processor.py:8:0: W0611: Unused import os (unused-import)
agent_s3/feature_group_processor.py:11:0: W0611: Unused List imported from typing (unused-import)
agent_s3/feature_group_processor.py:11:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.errors
agent_s3/errors.py:57:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
agent_s3/errors.py:141:38: E1101: Module 'traceback' has no 'exc_info' member (no-member)
agent_s3/errors.py:183:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/errors.py:305:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/errors.py:305:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/errors.py:328:30: E1101: Module 'traceback' has no 'exc_info' member (no-member)
agent_s3/errors.py:372:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/errors.py:380:0: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/errors.py:380:0: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/errors.py:382:4: W0621: Redefining name 'logger' from outer scope (line 18) (redefined-outer-name)
agent_s3/errors.py:429:8: E0704: The raise statement is not inside an except clause (misplaced-bare-raise)
agent_s3/errors.py:8:0: W0611: Unused import enum (unused-import)
agent_s3/errors.py:10:0: W0611: Unused import os (unused-import)
agent_s3/errors.py:16:0: W0611: Unused List imported from typing (unused-import)
agent_s3/errors.py:16:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.vscode_integration
agent_s3/vscode_integration.py:38:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
agent_s3/vscode_integration.py:127:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:144:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:148:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:161:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:171:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:173:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:208:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:240:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:130:4: R0915: Too many statements (62/50) (too-many-statements)
agent_s3/vscode_integration.py:269:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:292:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:281:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/vscode_integration.py:286:16: C0415: Import outside toplevel (stat) (import-outside-toplevel)
agent_s3/vscode_integration.py:289:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:293:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:320:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:321:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:340:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:341:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:382:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/vscode_integration.py:380:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:383:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/vscode_integration.py:458:4: W0102: Dangerous default value [] as argument (dangerous-default-value)
agent_s3/vscode_integration.py:10:0: C0411: standard import "asyncio" should be placed before third party import "websockets" (wrong-import-order)
agent_s3/vscode_integration.py:11:0: C0411: standard import "queue.Queue" should be placed before third party import "websockets" (wrong-import-order)
agent_s3/vscode_integration.py:12:0: C0411: standard import "uuid" should be placed before third party import "websockets" (wrong-import-order)
agent_s3/vscode_integration.py:13:0: C0411: standard import "atexit" should be placed before third party import "websockets" (wrong-import-order)
************* Module agent_s3.tool_definitions
agent_s3/tool_definitions.py:22:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tool_definitions.py:207:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:341:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tool_definitions.py:298:45: E1123: Unexpected keyword argument 'token' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:307:45: E1123: Unexpected keyword argument 'token' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:315:53: E1123: Unexpected keyword argument 'store_path' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:315:53: E1123: Unexpected keyword argument 'dim' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:315:53: E1123: Unexpected keyword argument 'top_k' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:315:53: E1123: Unexpected keyword argument 'eviction_threshold' in constructor call (unexpected-keyword-arg)
agent_s3/tool_definitions.py:323:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tool_definitions.py:339:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:342:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:343:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:239:4: R0911: Too many return statements (12/6) (too-many-return-statements)
agent_s3/tool_definitions.py:239:4: R0912: Too many branches (19/12) (too-many-branches)
agent_s3/tool_definitions.py:360:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:362:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:369:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:371:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:373:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:449:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tool_definitions.py:450:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:463:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tool_definitions.py:465:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tool_definitions.py:10:0: W0611: Unused import re (unused-import)
************* Module agent_s3.json_utils
agent_s3/json_utils.py:17:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/json_utils.py:147:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/json_utils.py:125:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/json_utils.py:200:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/json_utils.py:293:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/json_utils.py:287:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/json_utils.py:250:4: W0613: Unused argument 'original_request' (unused-argument)
agent_s3/json_utils.py:318:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/json_utils.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/json_utils.py:316:4: W0611: Unused validate_json_schema imported from agent_s3.planner_json_enforced (unused-import)
************* Module agent_s3.implementation_manager
agent_s3/implementation_manager.py:99:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/implementation_manager.py:96:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/implementation_manager.py:121:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/implementation_manager.py:118:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/implementation_manager.py:162:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/implementation_manager.py:146:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/implementation_manager.py:187:12: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/implementation_manager.py:178:8: W0612: Unused variable 'current_section' (unused-variable)
agent_s3/implementation_manager.py:272:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/implementation_manager.py:308:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/implementation_manager.py:404:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/implementation_manager.py:12:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/implementation_manager.py:13:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.terminal_executor
agent_s3/terminal_executor.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/terminal_executor.py:8:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/terminal_executor.py:36:12: C0415: Import outside toplevel (logging) (import-outside-toplevel)
agent_s3/terminal_executor.py:61:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/terminal_executor.py:73:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/terminal_executor.py:78:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/terminal_executor.py:87:8: C0415: Import outside toplevel (time) (import-outside-toplevel)
agent_s3/terminal_executor.py:92:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/terminal_executor.py:160:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/terminal_executor.py:163:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/terminal_executor.py:78:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/terminal_executor.py:118:19: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/terminal_executor.py:224:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/terminal_executor.py:191:12: C0415: Import outside toplevel (uuid) (import-outside-toplevel)
agent_s3/terminal_executor.py:205:23: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/terminal_executor.py:226:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/terminal_executor.py:245:8: C0415: Import outside toplevel (time) (import-outside-toplevel)
agent_s3/terminal_executor.py:290:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/terminal_executor.py:229:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/terminal_executor.py:267:19: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/terminal_executor.py:245:8: W0611: Unused import time (unused-import)
agent_s3/terminal_executor.py:6:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/terminal_executor.py:6:0: W0611: Unused Any imported from typing (unused-import)
************* Module agent_s3.enhanced_scratchpad_manager
agent_s3/enhanced_scratchpad_manager.py:101:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
agent_s3/enhanced_scratchpad_manager.py:163:8: C0115: Missing class docstring (missing-class-docstring)
agent_s3/enhanced_scratchpad_manager.py:218:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:257:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:281:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:308:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:342:8: C0415: Import outside toplevel (base64) (import-outside-toplevel)
agent_s3/enhanced_scratchpad_manager.py:351:8: C0415: Import outside toplevel (base64) (import-outside-toplevel)
agent_s3/enhanced_scratchpad_manager.py:367:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:368:19: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/enhanced_scratchpad_manager.py:396:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/enhanced_scratchpad_manager.py:400:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/enhanced_scratchpad_manager.py:400:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/enhanced_scratchpad_manager.py:524:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/enhanced_scratchpad_manager.py:524:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/enhanced_scratchpad_manager.py:524:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/enhanced_scratchpad_manager.py:614:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/enhanced_scratchpad_manager.py:614:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/enhanced_scratchpad_manager.py:754:16: E1137: 'current_entry' does not support item assignment (unsupported-assignment-operation)
agent_s3/enhanced_scratchpad_manager.py:816:8: W0621: Redefining name 're' from outer scope (line 9) (redefined-outer-name)
agent_s3/enhanced_scratchpad_manager.py:816:8: W0404: Reimport 're' (imported line 9) (reimported)
agent_s3/enhanced_scratchpad_manager.py:816:8: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/enhanced_scratchpad_manager.py:11:0: W0611: Unused import time (unused-import)
agent_s3/enhanced_scratchpad_manager.py:13:0: W0611: Unused import shutil (unused-import)
agent_s3/enhanced_scratchpad_manager.py:18:0: W0611: Unused Iterator imported from typing (unused-import)
agent_s3/enhanced_scratchpad_manager.py:18:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tech_stack_detector
agent_s3/tech_stack_detector.py:70:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tech_stack_detector.py:41:12: C0415: Import outside toplevel (agent_s3.tools.tech_stack_manager.TechStackManager) (import-outside-toplevel)
agent_s3/tech_stack_detector.py:45:42: E1123: Unexpected keyword argument 'config' in constructor call (unexpected-keyword-arg)
agent_s3/tech_stack_detector.py:45:42: E1123: Unexpected keyword argument 'file_tool' in constructor call (unexpected-keyword-arg)
agent_s3/tech_stack_detector.py:60:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tech_stack_detector.py:6:0: W0611: Unused import os (unused-import)
agent_s3/tech_stack_detector.py:9:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.pre_planning_errors
agent_s3/pre_planning_errors.py:16:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/pre_planning_errors.py:110:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/pre_planning_errors.py:71:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:79:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:87:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:95:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:103:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:111:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/pre_planning_errors.py:67:4: R0911: Too many return statements (7/6) (too-many-return-statements)
************* Module agent_s3.code_generator
agent_s3/code_generator.py:867:0: C0305: Trailing newlines (trailing-newlines)
agent_s3/code_generator.py:25:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
agent_s3/code_generator.py:45:50: W0613: Unused argument 'tech_stack' (unused-argument)
agent_s3/code_generator.py:109:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:114:4: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/code_generator.py:144:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:187:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:201:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:191:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/code_generator.py:114:4: R0912: Too many branches (26/12) (too-many-branches)
agent_s3/code_generator.py:114:4: R0915: Too many statements (65/50) (too-many-statements)
agent_s3/code_generator.py:230:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/code_generator.py:330:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/code_generator.py:515:15: R0916: Too many boolean expressions in if statement (6/5) (too-many-boolean-expressions)
agent_s3/code_generator.py:644:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:659:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:678:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:698:24: C3001: Lambda expression assigned to a variable. Define a function using the "def" keyword instead. (unnecessary-lambda-assignment)
agent_s3/code_generator.py:736:14: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/code_generator.py:725:39: W0613: Unused argument 'file_path' (unused-argument)
agent_s3/code_generator.py:759:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:754:25: W0613: Unused argument 'file_path' (unused-argument)
agent_s3/code_generator.py:754:41: W0613: Unused argument 'generated_code' (unused-argument)
agent_s3/code_generator.py:859:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/code_generator.py:12:0: W0611: Unused import subprocess (unused-import)
agent_s3/code_generator.py:13:0: W0611: Unused import time (unused-import)
agent_s3/code_generator.py:14:0: W0611: Unused import traceback (unused-import)
agent_s3/code_generator.py:16:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/code_generator.py:17:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/code_generator.py:18:0: W0611: Unused import threading (unused-import)
agent_s3/code_generator.py:21:0: W0611: Unused TestType imported from tools.test_critic.core (unused-import)
agent_s3/code_generator.py:21:0: W0611: Unused TestVerdict imported from tools.test_critic.core (unused-import)
************* Module agent_s3.tools.tech_stack_manager
agent_s3/tools/tech_stack_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/tech_stack_manager.py:81:12: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:98:16: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:93:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:112:16: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:106:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:125:16: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:120:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:144:16: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:138:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:71:4: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/tech_stack_manager.py:71:4: R0915: Too many statements (57/50) (too-many-statements)
agent_s3/tools/tech_stack_manager.py:147:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/tech_stack_manager.py:168:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/tech_stack_manager.py:153:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:169:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/tech_stack_manager.py:198:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/tech_stack_manager.py:174:16: C0415: Import outside toplevel (toml) (import-outside-toplevel)
agent_s3/tools/tech_stack_manager.py:175:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:199:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/tech_stack_manager.py:172:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/tech_stack_manager.py:228:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/tech_stack_manager.py:205:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:214:16: C0103: Variable name "devDependencies" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/tech_stack_manager.py:229:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/tech_stack_manager.py:147:4: R0912: Too many branches (27/12) (too-many-branches)
agent_s3/tools/tech_stack_manager.py:147:4: R0915: Too many statements (60/50) (too-many-statements)
agent_s3/tools/tech_stack_manager.py:285:20: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:281:29: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/tech_stack_manager.py:308:12: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/tech_stack_manager.py:305:16: C0415: Import outside toplevel (importlib.metadata) (import-outside-toplevel)
agent_s3/tools/tech_stack_manager.py:288:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/tech_stack_manager.py:485:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/tech_stack_manager.py:485:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/tech_stack_manager.py:1:0: W0611: Unused import os (unused-import)
agent_s3/tools/tech_stack_manager.py:5:0: W0611: Unused List imported from typing (unused-import)
agent_s3/tools/tech_stack_manager.py:5:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/tech_stack_manager.py:8:0: W0611: Unused datetime imported from datetime (unused-import)
************* Module agent_s3.tools.git_tool
agent_s3/tools/git_tool.py:48:8: C0103: Attribute name "ERROR_CATEGORIES" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/git_tool.py:17:0: R0902: Too many instance attributes (13/7) (too-many-instance-attributes)
agent_s3/tools/git_tool.py:116:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/git_tool.py:107:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:121:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:89:30: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/git_tool.py:152:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/git_tool.py:152:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/git_tool.py:152:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/tools/git_tool.py:290:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/git_tool.py:217:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:223:16: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/git_tool.py:236:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:251:20: R1724: Unnecessary "else" after "continue", remove the "else" and de-indent the code inside it (no-else-continue)
agent_s3/tools/git_tool.py:252:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:266:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:276:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:284:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:295:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:152:4: R0911: Too many return statements (15/6) (too-many-return-statements)
agent_s3/tools/git_tool.py:152:4: R0912: Too many branches (31/12) (too-many-branches)
agent_s3/tools/git_tool.py:152:4: R0915: Too many statements (88/50) (too-many-statements)
agent_s3/tools/git_tool.py:359:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:361:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:364:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:364:36: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/git_tool.py:372:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:377:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:392:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:396:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:346:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/git_tool.py:360:27: W0612: Unused variable 'checkout_output' (unused-variable)
agent_s3/tools/git_tool.py:422:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:430:4: R0911: Too many return statements (10/6) (too-many-return-statements)
agent_s3/tools/git_tool.py:515:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/git_tool.py:518:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:483:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/tools/git_tool.py:483:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/git_tool.py:571:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:596:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:607:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:648:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:650:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:654:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:657:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/git_tool.py:657:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/git_tool.py:698:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/git_tool.py:700:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:704:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:717:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/git_tool.py:737:12: W1201: Use lazy % formatting in logging functions (logging-not-lazy)
agent_s3/tools/git_tool.py:5:0: W0611: Unused import json (unused-import)
agent_s3/tools/git_tool.py:14:0: W0611: Unused RequestException imported from requests.exceptions (unused-import)
************* Module agent_s3.tools.dependency_impact_analyzer 3
agent_s3/tools/dependency_impact_analyzer 3.py:1:0: C0103: Module name "dependency_impact_analyzer 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/dependency_impact_analyzer 3.py:37:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/dependency_impact_analyzer 3.py:114:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_impact_analyzer 3.py:113:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_impact_analyzer 3.py:115:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_impact_analyzer 3.py:37:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/dependency_impact_analyzer 3.py:211:20: R1730: Consider using 'min_distance = min(min_distance, distance)' instead of unnecessary if block (consider-using-min-builtin)
agent_s3/tools/dependency_impact_analyzer 3.py:11:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/dependency_impact_analyzer 3.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/dependency_impact_analyzer 3.py:11:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.database_tool
agent_s3/tools/database_tool.py:230:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:268:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:269:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:271:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:335:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:338:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:339:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:342:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:344:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:345:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:346:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:354:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:356:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:543:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:544:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:546:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:547:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:574:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:602:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:628:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:629:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:630:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:632:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:720:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:721:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:739:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:740:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:753:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:754:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:755:0: W0311: Bad indentation. Found 18 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:756:0: W0311: Bad indentation. Found 18 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:757:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:795:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:796:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:830:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:831:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/database_tool.py:858:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:859:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:860:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/database_tool.py:157:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:155:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:158:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:203:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/database_tool.py:212:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/database_tool.py:221:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:224:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:228:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:230:17: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:236:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:245:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:253:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:256:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:274:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:293:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:319:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:343:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:332:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:335:17: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:349:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:358:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:354:17: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:356:17: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:300:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/database_tool.py:382:31: E1101: Instance of 'DatabaseTool' has no '_parse_sqlalchemy_results' member (no-member)
agent_s3/tools/database_tool.py:387:18: E1124: Argument 'statement' passed by position and keyword in constructor call (redundant-keyword-arg)
agent_s3/tools/database_tool.py:389:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/database_tool.py:407:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:427:31: E1101: Instance of 'DatabaseTool' has no '_clean_csv_output' member (no-member)
agent_s3/tools/database_tool.py:435:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:389:50: W0613: Unused argument 'params' (unused-argument)
agent_s3/tools/database_tool.py:479:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/database_tool.py:545:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:519:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/database_tool.py:520:16: C0415: Import outside toplevel (csv) (import-outside-toplevel)
agent_s3/tools/database_tool.py:521:16: C0415: Import outside toplevel (io.StringIO) (import-outside-toplevel)
agent_s3/tools/database_tool.py:530:16: C0415: Import outside toplevel (csv) (import-outside-toplevel)
agent_s3/tools/database_tool.py:531:16: C0415: Import outside toplevel (io.StringIO) (import-outside-toplevel)
agent_s3/tools/database_tool.py:539:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:543:13: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:546:13: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:578:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/database_tool.py:594:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:592:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/database_tool.py:604:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:627:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:612:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:625:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:635:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:637:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:652:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:660:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/database_tool.py:674:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:707:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:705:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:708:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:712:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:793:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:796:13: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:660:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/database_tool.py:660:4: R0915: Too many statements (56/50) (too-many-statements)
agent_s3/tools/database_tool.py:828:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:830:13: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:857:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:846:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:854:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:859:17: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:863:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:884:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/database_tool.py:867:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/database_tool.py:870:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:877:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/database_tool.py:882:40: E0606: Possibly using variable 'sqlalchemy_error' before assignment (possibly-used-before-assignment)
agent_s3/tools/database_tool.py:886:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module agent_s3.tools.test_runner_tool
agent_s3/tools/test_runner_tool.py:21:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_runner_tool.py:28:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_runner_tool.py:33:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/test_runner_tool.py:150:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_runner_tool.py:145:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_runner_tool.py:154:4: R0914: Too many local variables (41/15) (too-many-locals)
agent_s3/tools/test_runner_tool.py:154:4: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/test_runner_tool.py:154:4: R0915: Too many statements (77/50) (too-many-statements)
agent_s3/tools/test_runner_tool.py:339:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_runner_tool.py:348:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_runner_tool.py:325:4: R0911: Too many return statements (17/6) (too-many-return-statements)
agent_s3/tools/test_runner_tool.py:325:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/test_runner_tool.py:384:8: W0612: Unused variable 'details' (unused-variable)
agent_s3/tools/test_runner_tool.py:386:8: W0612: Unused variable 'test_file' (unused-variable)
agent_s3/tools/test_runner_tool.py:7:0: W0611: Unused import subprocess (unused-import)
agent_s3/tools/test_runner_tool.py:9:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tools.memory_manager
agent_s3/tools/memory_manager.py:487:9: W0511: TODO: Replace with real chunking logic (fixme)
agent_s3/tools/memory_manager.py:26:0: E0611: No name 'SummarizationPromptGenerator' in module 'agent_s3.llm_prompts.summarization_prompts' (no-name-in-module)
agent_s3/tools/memory_manager.py:50:0: R0902: Too many instance attributes (31/7) (too-many-instance-attributes)
agent_s3/tools/memory_manager.py:53:23: W0621: Redefining name 'config' from outer scope (line 25) (redefined-outer-name)
agent_s3/tools/memory_manager.py:78:8: C0415: Import outside toplevel (concurrent.futures.ThreadPoolExecutor) (import-outside-toplevel)
agent_s3/tools/memory_manager.py:96:8: C0415: Import outside toplevel (collections.OrderedDict) (import-outside-toplevel)
agent_s3/tools/memory_manager.py:125:8: E1101: Instance of 'MemoryManager' has no '_verify_manifest' member (no-member)
agent_s3/tools/memory_manager.py:127:8: E1101: Instance of 'MemoryManager' has no '_update_manifest' member (no-member)
agent_s3/tools/memory_manager.py:146:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:148:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:152:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:171:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:181:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:182:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:184:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:192:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:194:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:207:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:209:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:242:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:245:4: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/tools/memory_manager.py:262:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:263:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:271:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:274:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:325:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:326:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:333:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:245:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/memory_manager.py:398:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:381:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/memory_manager.py:382:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:390:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:395:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:399:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:410:8: C0103: Variable name "LANG_MAP" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/memory_manager.py:446:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:444:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:447:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:478:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/memory_manager.py:450:12: C0415: Import outside toplevel (agent_s3.ast_tools.python_units.extract_units) (import-outside-toplevel)
agent_s3/tools/memory_manager.py:451:12: C0415: Import outside toplevel (agent_s3.ast_tools.summariser.summarise_unit, agent_s3.ast_tools.summariser.merge_summaries) (import-outside-toplevel)
agent_s3/tools/memory_manager.py:456:20: E1123: Unexpected keyword argument 'language' in function call (unexpected-keyword-arg)
agent_s3/tools/memory_manager.py:459:26: E1121: Too many positional arguments for function call (too-many-function-args)
agent_s3/tools/memory_manager.py:469:29: E1121: Too many positional arguments for function call (too-many-function-args)
agent_s3/tools/memory_manager.py:479:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/memory_manager.py:481:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/memory_manager.py:481:97: W0613: Unused argument 'preserve_sections' (unused-argument)
agent_s3/tools/memory_manager.py:533:24: E1101: Instance of 'MemoryManager' has no '_create_summary_system_prompt' member (no-member)
agent_s3/tools/memory_manager.py:534:22: E1101: Instance of 'MemoryManager' has no '_create_summary_user_prompt' member (no-member)
agent_s3/tools/memory_manager.py:9:0: W0611: Unused import re (unused-import)
agent_s3/tools/memory_manager.py:11:0: W0611: Unused import hashlib (unused-import)
agent_s3/tools/memory_manager.py:15:0: W0611: Unused deepcopy imported from copy (unused-import)
agent_s3/tools/memory_manager.py:20:0: W0611: Unused import tiktoken (unused-import)
agent_s3/tools/memory_manager.py:23:0: W0611: Unused cached_call_llm imported from agent_s3.llm_utils (unused-import)
agent_s3/tools/memory_manager.py:28:0: W0611: Unused SummaryValidationConfig imported from agent_s3.tools.summarization.validation_config (unused-import)
agent_s3/tools/memory_manager.py:29:0: W0611: Unused SummarizationPromptFactory imported from agent_s3.tools.summarization.prompt_factory (unused-import)
agent_s3/tools/memory_manager.py:30:0: W0611: Unused SummaryRefiner imported from agent_s3.tools.summarization.summary_refiner (unused-import)
agent_s3/tools/memory_manager.py:31:0: W0611: Unused SummaryCache imported from agent_s3.tools.summarization.summary_cache (unused-import)
************* Module agent_s3.tools.embedding_client
agent_s3/tools/embedding_client.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/embedding_client.py:20:0: R0902: Too many instance attributes (16/7) (too-many-instance-attributes)
agent_s3/tools/embedding_client.py:68:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:67:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:69:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:72:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:73:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:103:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:81:43: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/embedding_client.py:83:40: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/embedding_client.py:95:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:104:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:61:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/embedding_client.py:98:24: W0612: Unused variable 'key' (unused-variable)
agent_s3/tools/embedding_client.py:131:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:130:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:132:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:145:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:147:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:149:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/embedding_client.py:172:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:175:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:239:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:236:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:240:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:149:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/embedding_client.py:267:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:326:8: C0415: Import outside toplevel (asyncio) (import-outside-toplevel)
agent_s3/tools/embedding_client.py:330:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/embedding_client.py:345:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:455:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:369:16: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/embedding_client.py:370:20: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/embedding_client.py:372:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:369:16: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/embedding_client.py:396:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:398:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:402:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:417:36: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:405:16: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/embedding_client.py:439:32: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:442:73: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:443:36: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:452:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:456:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:484:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/embedding_client.py:462:12: C0415: Import outside toplevel (agent_s3.config) (import-outside-toplevel)
agent_s3/tools/embedding_client.py:463:12: C0415: Import outside toplevel (agent_s3.llm_utils.get_embedding) (import-outside-toplevel)
agent_s3/tools/embedding_client.py:470:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:473:57: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:474:20: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:485:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/embedding_client.py:491:49: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:492:12: E1101: Instance of 'EmbeddingClient' has no '_metrics' member (no-member)
agent_s3/tools/embedding_client.py:330:4: R0912: Too many branches (22/12) (too-many-branches)
agent_s3/tools/embedding_client.py:330:4: R0915: Too many statements (72/50) (too-many-statements)
agent_s3/tools/embedding_client.py:462:12: W0611: Unused config imported from agent_s3 as app_config (unused-import)
agent_s3/tools/embedding_client.py:4:0: C0411: standard import "json" should be placed before third party import "faiss" (wrong-import-order)
agent_s3/tools/embedding_client.py:6:0: C0411: standard import "logging" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:7:0: C0411: standard import "shutil" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:8:0: C0411: standard import "time" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:9:0: C0411: standard import "gzip" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:10:0: C0411: standard import "textwrap" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:11:0: C0411: standard import "pathlib.Path" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:12:0: C0411: standard import "typing.List" should be placed before third party imports "faiss", "numpy" (wrong-import-order)
agent_s3/tools/embedding_client.py:1:0: W0611: Unused import os (unused-import)
agent_s3/tools/embedding_client.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tools.incremental_indexing_adapter
agent_s3/tools/incremental_indexing_adapter.py:21:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/tools/incremental_indexing_adapter.py:79:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:80:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:116:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:117:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:177:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:158:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:146:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:159:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:170:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter.py:172:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:175:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:178:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:197:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:198:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:269:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:228:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:231:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter.py:245:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:254:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:256:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter.py:270:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:277:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/incremental_indexing_adapter.py:358:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:300:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/incremental_indexing_adapter.py:301:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:359:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:277:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/incremental_indexing_adapter.py:383:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:384:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:406:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter.py:407:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter.py:11:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter.py:13:0: W0611: Unused FileChangeTracker imported from agent_s3.tools.file_change_tracker (unused-import)
agent_s3/tools/incremental_indexing_adapter.py:14:0: W0611: Unused DependencyImpactAnalyzer imported from agent_s3.tools.dependency_impact_analyzer (unused-import)
agent_s3/tools/incremental_indexing_adapter.py:16:0: W0611: Unused IndexPartitionManager imported from agent_s3.tools.index_partition_manager (unused-import)
************* Module agent_s3.tools.dependency_impact_analyzer
agent_s3/tools/dependency_impact_analyzer.py:37:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/dependency_impact_analyzer.py:114:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_impact_analyzer.py:113:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_impact_analyzer.py:115:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_impact_analyzer.py:37:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/dependency_impact_analyzer.py:211:20: R1730: Consider using 'min_distance = min(min_distance, distance)' instead of unnecessary if block (consider-using-min-builtin)
agent_s3/tools/dependency_impact_analyzer.py:11:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/dependency_impact_analyzer.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/dependency_impact_analyzer.py:11:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.file_change_tracker 3
agent_s3/tools/file_change_tracker 3.py:1:0: C0103: Module name "file_change_tracker 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/file_change_tracker 3.py:61:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:56:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_change_tracker 3.py:60:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:62:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:86:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:80:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_change_tracker 3.py:85:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:87:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:109:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:110:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:153:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:154:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:195:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:196:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:226:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:227:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:260:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker 3.py:261:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker 3.py:14:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/tools/file_change_tracker 3.py:15:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/file_change_tracker 3.py:15:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/file_change_tracker 3.py:15:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.incremental_indexing_adapter 3
agent_s3/tools/incremental_indexing_adapter 3.py:1:0: C0103: Module name "incremental_indexing_adapter 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/incremental_indexing_adapter 3.py:21:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/tools/incremental_indexing_adapter 3.py:79:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:80:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:116:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:117:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:177:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:158:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:146:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:159:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:170:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter 3.py:172:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:175:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:178:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:197:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:198:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:269:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:228:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:231:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter 3.py:245:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:254:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:256:16: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/incremental_indexing_adapter 3.py:270:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:277:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/incremental_indexing_adapter 3.py:358:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:300:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/incremental_indexing_adapter 3.py:301:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:359:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:277:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/incremental_indexing_adapter 3.py:383:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:384:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:406:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexing_adapter 3.py:407:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexing_adapter 3.py:11:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter 3.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter 3.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/incremental_indexing_adapter 3.py:13:0: W0611: Unused FileChangeTracker imported from agent_s3.tools.file_change_tracker (unused-import)
agent_s3/tools/incremental_indexing_adapter 3.py:14:0: W0611: Unused DependencyImpactAnalyzer imported from agent_s3.tools.dependency_impact_analyzer (unused-import)
agent_s3/tools/incremental_indexing_adapter 3.py:16:0: W0611: Unused IndexPartitionManager imported from agent_s3.tools.index_partition_manager (unused-import)
************* Module agent_s3.tools.system_design_validator
agent_s3/tools/system_design_validator.py:1:0: C0302: Too many lines in module (1195/1000) (too-many-lines)
agent_s3/tools/system_design_validator.py:20:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/system_design_validator.py:268:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:382:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:552:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/system_design_validator.py:552:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:664:30: W0612: Unused variable 'strength' (unused-variable)
agent_s3/tools/system_design_validator.py:677:4: W0613: Unused argument 'components' (unused-argument)
agent_s3/tools/system_design_validator.py:729:0: R0914: Too many local variables (28/15) (too-many-locals)
agent_s3/tools/system_design_validator.py:782:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:729:0: R0912: Too many branches (29/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:729:0: R0915: Too many statements (63/50) (too-many-statements)
agent_s3/tools/system_design_validator.py:905:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:905:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:893:0: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:905:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:1044:0: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/system_design_validator.py:1068:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
agent_s3/tools/system_design_validator.py:1054:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:1054:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:1044:0: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/system_design_validator.py:1044:0: R0915: Too many statements (51/50) (too-many-statements)
agent_s3/tools/system_design_validator.py:1056:8: W0612: Unused variable 'components' (unused-variable)
agent_s3/tools/system_design_validator.py:1086:16: W0612: Unused variable 'from_elements' (unused-variable)
agent_s3/tools/system_design_validator.py:1087:16: W0612: Unused variable 'to_elements' (unused-variable)
agent_s3/tools/system_design_validator.py:1159:28: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/system_design_validator.py:1152:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator.py:12:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.repository_event_system 3
agent_s3/tools/repository_event_system 3.py:1:0: C0103: Module name "repository_event_system 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/repository_event_system 3.py:26:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system 3.py:27:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:28:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system 3.py:28:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:29:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system 3.py:29:25: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:30:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system 3.py:30:24: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:31:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system 3.py:31:24: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:33:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system 3.py:34:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system 3.py:34:35: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system 3.py:33:4: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/repository_event_system 3.py:36:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system 3.py:36:4: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/tools/repository_event_system 3.py:48:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
agent_s3/tools/repository_event_system 3.py:82:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/repository_event_system 3.py:180:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system 3.py:181:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system 3.py:198:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/tools/repository_event_system 3.py:198:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/tools/repository_event_system 3.py:259:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system 3.py:257:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system 3.py:260:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system 3.py:306:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system 3.py:307:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system 3.py:280:16: W0612: Unused variable 'i' (unused-variable)
agent_s3/tools/repository_event_system 3.py:316:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system 3.py:317:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system 3.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/repository_event_system 3.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/repository_event_system 3.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/repository_event_system 3.py:12:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/repository_event_system 3.py:13:0: W0611: Unused Path imported from pathlib (unused-import)
************* Module agent_s3.tools.bash_tool
agent_s3/tools/bash_tool.py:19:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
agent_s3/tools/bash_tool.py:22:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/bash_tool.py:22:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/bash_tool.py:107:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:110:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/bash_tool.py:202:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:129:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/bash_tool.py:154:20: C0415: Import outside toplevel (socket) (import-outside-toplevel)
agent_s3/tools/bash_tool.py:122:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/bash_tool.py:236:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:209:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/bash_tool.py:110:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/bash_tool.py:219:26: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/bash_tool.py:295:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:257:26: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:270:36: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:279:31: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:288:16: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:300:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/bash_tool.py:301:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/bash_tool.py:239:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/bash_tool.py:359:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:344:16: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:349:16: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:371:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:391:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:383:16: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:389:38: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:390:20: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:397:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:400:4: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/tools/bash_tool.py:484:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:416:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/bash_tool.py:439:16: C0415: Import outside toplevel (socket) (import-outside-toplevel)
agent_s3/tools/bash_tool.py:413:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/bash_tool.py:465:22: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:480:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:481:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/bash_tool.py:524:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/bash_tool.py:507:22: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/bash_tool.py:11:0: W0611: Unused import json (unused-import)
agent_s3/tools/bash_tool.py:15:0: W0611: Unused Path imported from pathlib (unused-import)
************* Module agent_s3.tools.error_pattern_learner
agent_s3/tools/error_pattern_learner.py:37:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_pattern_learner.py:43:8: W0612: Unused variable 'data' (unused-variable)
agent_s3/tools/error_pattern_learner.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/error_pattern_learner.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module agent_s3.tools.test_implementation_validator
agent_s3/tools/test_implementation_validator.py:21:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_implementation_validator.py:24:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/test_implementation_validator.py:130:4: W0613: Unused argument 'architecture_review' (unused-argument)
agent_s3/tools/test_implementation_validator.py:246:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/test_implementation_validator.py:246:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/test_implementation_validator.py:252:4: W0613: Unused argument 'refined_test_specs' (unused-argument)
agent_s3/tools/test_implementation_validator.py:365:27: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/test_implementation_validator.py:376:4: W0613: Unused argument 'refined_test_specs' (unused-argument)
agent_s3/tools/test_implementation_validator.py:382:4: W0612: Unused variable 'arch_issue_ids' (unused-variable)
agent_s3/tools/test_implementation_validator.py:473:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/test_implementation_validator.py:479:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_implementation_validator.py:479:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/test_implementation_validator.py:528:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_implementation_validator.py:553:28: R1731: Consider using 'import_end = max(import_end, line_end)' instead of unnecessary if block (consider-using-max-builtin)
agent_s3/tools/test_implementation_validator.py:528:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/test_implementation_validator.py:528:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_implementation_validator.py:568:11: E0602: Undefined variable 'difflib' (undefined-variable)
agent_s3/tools/test_implementation_validator.py:13:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.dependency_analyzer
agent_s3/tools/dependency_analyzer.py:47:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_analyzer.py:45:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:48:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:66:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_analyzer.py:64:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:67:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:81:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_analyzer.py:78:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:82:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:85:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:51:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/dependency_analyzer.py:154:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_analyzer.py:138:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/dependency_analyzer.py:144:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/dependency_analyzer.py:155:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:186:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/dependency_analyzer.py:177:25: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/dependency_analyzer.py:182:40: E0602: Undefined variable 're' (undefined-variable)
agent_s3/tools/dependency_analyzer.py:187:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:225:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/dependency_analyzer.py:17:0: C0411: standard import "subprocess" should be placed before third party import "pkg_resources" (wrong-import-order)
agent_s3/tools/dependency_analyzer.py:9:0: W0611: Unused import ast (unused-import)
agent_s3/tools/dependency_analyzer.py:10:0: W0611: Unused import importlib (unused-import)
agent_s3/tools/dependency_analyzer.py:14:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tools.test_frameworks
agent_s3/tools/test_frameworks.py:79:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:80:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:108:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:85:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_frameworks.py:109:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:190:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:206:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:198:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:199:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:204:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:207:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_frameworks.py:254:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:300:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:291:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_frameworks.py:319:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:352:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:259:4: R0912: Too many branches (24/12) (too-many-branches)
agent_s3/tools/test_frameworks.py:259:4: R0915: Too many statements (57/50) (too-many-statements)
agent_s3/tools/test_frameworks.py:360:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/test_frameworks.py:441:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:446:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:451:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:456:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:462:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:434:4: R0911: Too many return statements (10/6) (too-many-return-statements)
agent_s3/tools/test_frameworks.py:434:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/test_frameworks.py:533:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:558:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:584:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:611:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:530:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/tools/test_frameworks.py:644:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:673:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:702:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:736:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:641:4: R0911: Too many return statements (9/6) (too-many-return-statements)
agent_s3/tools/test_frameworks.py:808:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_frameworks.py:788:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_frameworks.py:793:20: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:802:20: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_frameworks.py:810:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/test_frameworks.py:784:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/tools/test_frameworks.py:8:0: W0611: Unused import inspect (unused-import)
agent_s3/tools/test_frameworks.py:11:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/test_frameworks.py:11:0: W0611: Unused Callable imported from typing (unused-import)
agent_s3/tools/test_frameworks.py:11:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.coherence_validator
agent_s3/tools/coherence_validator.py:59:0: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/coherence_validator.py:59:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/coherence_validator.py:165:0: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/tools/coherence_validator.py:288:31: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/coherence_validator.py:165:0: R0912: Too many branches (24/12) (too-many-branches)
agent_s3/tools/coherence_validator.py:165:0: R0915: Too many statements (64/50) (too-many-statements)
agent_s3/tools/coherence_validator.py:309:0: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/coherence_validator.py:399:31: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/coherence_validator.py:309:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/coherence_validator.py:409:0: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/coherence_validator.py:528:31: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/coherence_validator.py:409:0: R0912: Too many branches (27/12) (too-many-branches)
agent_s3/tools/coherence_validator.py:409:0: R0915: Too many statements (63/50) (too-many-statements)
agent_s3/tools/coherence_validator.py:551:4: W0612: Unused variable 'naming_issues' (unused-variable)
agent_s3/tools/coherence_validator.py:555:4: W0612: Unused variable 'error_issues' (unused-variable)
agent_s3/tools/coherence_validator.py:559:4: W0612: Unused variable 'api_issues' (unused-variable)
agent_s3/tools/coherence_validator.py:563:4: W0612: Unused variable 'flow_issues' (unused-variable)
agent_s3/tools/coherence_validator.py:13:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/coherence_validator.py:13:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/coherence_validator.py:13:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/coherence_validator.py:14:0: W0611: Unused defaultdict imported from collections (unused-import)
************* Module agent_s3.tools.feature_flags
agent_s3/tools/feature_flags.py:67:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/feature_flags.py:51:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:62:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/feature_flags.py:65:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:68:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:92:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/feature_flags.py:87:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/feature_flags.py:90:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:93:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:129:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/feature_flags.py:130:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/feature_flags.py:15:0: W0611: Unused import time (unused-import)
************* Module agent_s3.tools.incremental_indexer
agent_s3/tools/incremental_indexer.py:22:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
agent_s3/tools/incremental_indexer.py:30:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/incremental_indexer.py:30:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/incremental_indexer.py:87:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/incremental_indexer.py:87:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/incremental_indexer.py:87:4: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/tools/incremental_indexer.py:229:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:142:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:132:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:130:28: C0415: Import outside toplevel (agent_s3.tools.tech_stack_manager.TechStackManager) (import-outside-toplevel)
agent_s3/tools/incremental_indexer.py:133:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:143:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:193:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:194:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:201:34: W0212: Access to a protected member _file_state of a client class (protected-access)
agent_s3/tools/incremental_indexer.py:206:34: W0212: Access to a protected member _file_state of a client class (protected-access)
agent_s3/tools/incremental_indexer.py:226:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:230:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:87:4: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/tools/incremental_indexer.py:87:4: R0915: Too many statements (77/50) (too-many-statements)
agent_s3/tools/incremental_indexer.py:318:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:294:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:295:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:315:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:319:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:376:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:360:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:361:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:366:34: W0212: Access to a protected member _file_state of a client class (protected-access)
agent_s3/tools/incremental_indexer.py:377:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:434:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:435:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:438:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/incremental_indexer.py:499:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:500:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:438:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/incremental_indexer.py:481:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/incremental_indexer.py:565:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:566:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:585:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:581:12: C0415: Import outside toplevel (fnmatch.fnmatch) (import-outside-toplevel)
agent_s3/tools/incremental_indexer.py:609:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:610:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:645:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:677:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/incremental_indexer.py:678:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/incremental_indexer.py:685:8: C0415: Import outside toplevel (multiprocessing.Process) (import-outside-toplevel)
agent_s3/tools/incremental_indexer.py:12:0: W0611: Unused import json (unused-import)
agent_s3/tools/incremental_indexer.py:13:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/incremental_indexer.py:13:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/incremental_indexer.py:13:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.file_change_tracker
agent_s3/tools/file_change_tracker.py:61:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:56:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_change_tracker.py:60:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:62:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:86:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:80:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_change_tracker.py:85:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:87:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:109:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:110:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:153:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:154:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:195:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:196:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:226:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:227:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:260:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_change_tracker.py:261:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_change_tracker.py:14:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/tools/file_change_tracker.py:15:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/file_change_tracker.py:15:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/file_change_tracker.py:15:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.static_plan_checker
agent_s3/tools/static_plan_checker.py:50:12: C0206: Consider iterating with .items() (consider-using-dict-items)
agent_s3/tools/static_plan_checker.py:96:34: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/static_plan_checker.py:82:8: W0612: Unused variable 'original_ids' (unused-variable)
agent_s3/tools/static_plan_checker.py:135:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:135:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:198:8: C0206: Consider iterating with .items() (consider-using-dict-items)
agent_s3/tools/static_plan_checker.py:213:4: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/tools/static_plan_checker.py:227:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:227:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:213:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/static_plan_checker.py:281:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/static_plan_checker.py:294:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:335:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/static_plan_checker.py:358:8: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/static_plan_checker.py:335:4: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/tools/static_plan_checker.py:358:12: W0612: Unused variable 'group_idx' (unused-variable)
agent_s3/tools/static_plan_checker.py:363:16: W0612: Unused variable 'feature_idx' (unused-variable)
agent_s3/tools/static_plan_checker.py:18:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/static_plan_checker.py:9:0: W0611: Unused import json (unused-import)
agent_s3/tools/static_plan_checker.py:10:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/static_plan_checker.py:11:0: W0611: Unused SequenceMatcher imported from difflib (unused-import)
agent_s3/tools/static_plan_checker.py:14:0: W0611: Unused validate_user_modifications imported from agent_s3.tools.phase_validator (unused-import)
************* Module agent_s3.tools.repository_event_system
agent_s3/tools/repository_event_system.py:26:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system.py:27:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:28:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system.py:28:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:29:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system.py:29:25: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:30:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system.py:30:24: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:31:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system.py:31:24: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:33:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system.py:34:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/repository_event_system.py:34:35: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/repository_event_system.py:33:4: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/repository_event_system.py:36:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/tools/repository_event_system.py:36:4: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/tools/repository_event_system.py:48:0: R0902: Too many instance attributes (8/7) (too-many-instance-attributes)
agent_s3/tools/repository_event_system.py:82:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/repository_event_system.py:180:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system.py:181:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system.py:198:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/tools/repository_event_system.py:198:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/tools/repository_event_system.py:259:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system.py:257:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system.py:260:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system.py:306:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system.py:307:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system.py:280:16: W0612: Unused variable 'i' (unused-variable)
agent_s3/tools/repository_event_system.py:316:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/repository_event_system.py:317:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/repository_event_system.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/repository_event_system.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/repository_event_system.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/repository_event_system.py:12:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/repository_event_system.py:13:0: W0611: Unused Path imported from pathlib (unused-import)
************* Module agent_s3.tools.system_design_validator 3
agent_s3/tools/system_design_validator 3.py:1:0: C0302: Too many lines in module (1195/1000) (too-many-lines)
agent_s3/tools/system_design_validator 3.py:1:0: C0103: Module name "system_design_validator 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/system_design_validator 3.py:20:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/system_design_validator 3.py:268:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:382:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:552:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/system_design_validator 3.py:552:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:664:30: W0612: Unused variable 'strength' (unused-variable)
agent_s3/tools/system_design_validator 3.py:677:4: W0613: Unused argument 'components' (unused-argument)
agent_s3/tools/system_design_validator 3.py:729:0: R0914: Too many local variables (28/15) (too-many-locals)
agent_s3/tools/system_design_validator 3.py:782:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:729:0: R0912: Too many branches (29/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:729:0: R0915: Too many statements (63/50) (too-many-statements)
agent_s3/tools/system_design_validator 3.py:905:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:905:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:893:0: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:905:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:1044:0: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/system_design_validator 3.py:1068:12: C0200: Consider using enumerate instead of iterating with range and len (consider-using-enumerate)
agent_s3/tools/system_design_validator 3.py:1054:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:1054:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:1044:0: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/system_design_validator 3.py:1044:0: R0915: Too many statements (51/50) (too-many-statements)
agent_s3/tools/system_design_validator 3.py:1056:8: W0612: Unused variable 'components' (unused-variable)
agent_s3/tools/system_design_validator 3.py:1086:16: W0612: Unused variable 'from_elements' (unused-variable)
agent_s3/tools/system_design_validator 3.py:1087:16: W0612: Unused variable 'to_elements' (unused-variable)
agent_s3/tools/system_design_validator 3.py:1159:28: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/system_design_validator 3.py:1152:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/system_design_validator 3.py:12:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.security_validator 3
agent_s3/tools/security_validator 3.py:1:0: C0103: Module name "security_validator 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/security_validator 3.py:35:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/security_validator 3.py:63:8: W0612: Unused variable 'file_path' (unused-variable)
agent_s3/tools/security_validator 3.py:94:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/security_validator 3.py:157:22: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
agent_s3/tools/security_validator 3.py:127:16: W0612: Unused variable 'arch_message' (unused-variable)
agent_s3/tools/security_validator 3.py:356:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/security_validator 3.py:395:4: W0613: Unused argument 'implementation_plan' (unused-argument)
agent_s3/tools/security_validator 3.py:525:31: W0613: Unused argument 'implementation_plan' (unused-argument)
agent_s3/tools/security_validator 3.py:539:45: W0613: Unused argument 'patterns' (unused-argument)
agent_s3/tools/security_validator 3.py:602:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/security_validator 3.py:631:8: W0612: Unused variable 'aspect' (unused-variable)
agent_s3/tools/security_validator 3.py:705:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/security_validator 3.py:23:0: W0611: Unused import re (unused-import)
agent_s3/tools/security_validator 3.py:24:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.static_analyzer
agent_s3/tools/static_analyzer.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/static_analyzer.py:49:4: R0914: Too many local variables (32/15) (too-many-locals)
agent_s3/tools/static_analyzer.py:100:36: E1101: Instance of 'StaticAnalyzer' has no '_resolve_python_import_path' member (no-member)
agent_s3/tools/static_analyzer.py:107:36: E1101: Instance of 'StaticAnalyzer' has no '_resolve_js_import_path' member (no-member)
agent_s3/tools/static_analyzer.py:114:36: E1101: Instance of 'StaticAnalyzer' has no '_resolve_php_import_path' member (no-member)
agent_s3/tools/static_analyzer.py:80:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_analyzer.py:163:29: E1101: Instance of 'StaticAnalyzer' has no '_resolve_php_target' member (no-member)
agent_s3/tools/static_analyzer.py:193:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:80:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_analyzer.py:80:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_analyzer.py:219:31: E0606: Possibly using variable 'top_level' before assignment (possibly-used-before-assignment)
agent_s3/tools/static_analyzer.py:49:4: R0912: Too many branches (47/12) (too-many-branches)
agent_s3/tools/static_analyzer.py:49:4: R0915: Too many statements (119/50) (too-many-statements)
agent_s3/tools/static_analyzer.py:80:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/static_analyzer.py:262:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/static_analyzer.py:246:81: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/static_analyzer.py:246:81: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/static_analyzer.py:251:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:260:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:263:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:295:8: C0415: Import outside toplevel (agent_s3.tools.phase_validator.validate_architecture_implementation) (import-outside-toplevel)
agent_s3/tools/static_analyzer.py:309:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/static_analyzer.py:305:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:310:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:350:8: C0415: Import outside toplevel (agent_s3.tools.phase_validator.validate_test_coverage_against_risk) (import-outside-toplevel)
agent_s3/tools/static_analyzer.py:364:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/static_analyzer.py:360:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:365:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:377:16: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/static_analyzer.py:391:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/static_analyzer.py:444:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/static_analyzer.py:445:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/static_analyzer.py:452:29: E1101: Instance of 'StaticAnalyzer' has no 'analyze_file_with_tech_stack' member (no-member)
agent_s3/tools/static_analyzer.py:462:20: E1121: Too many positional arguments for method call (too-many-function-args)
agent_s3/tools/static_analyzer.py:2:0: W0611: Unused import re (unused-import)
agent_s3/tools/static_analyzer.py:3:0: W0611: Unused import ast (unused-import)
agent_s3/tools/static_analyzer.py:5:0: W0611: Unused import json (unused-import)
agent_s3/tools/static_analyzer.py:10:0: W0611: Unused LanguageParser imported from parsing.base_parser (unused-import)
************* Module agent_s3.tools.env_tool
agent_s3/tools/env_tool.py:6:0: W0611: Unused import subprocess (unused-import)
************* Module agent_s3.tools.canonical_validator
agent_s3/tools/canonical_validator.py:17:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/canonical_validator.py:19:4: W0613: Unused argument 'element_ids' (unused-argument)
agent_s3/tools/canonical_validator.py:11:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.implementation_validator
agent_s3/tools/implementation_validator.py:1:0: C0302: Too many lines in module (2467/1000) (too-many-lines)
agent_s3/tools/implementation_validator.py:2467:0: C0305: Trailing newlines (trailing-newlines)
agent_s3/tools/implementation_validator.py:33:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/implementation_validator.py:36:0: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:36:0: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:36:0: R0915: Too many statements (60/50) (too-many-statements)
agent_s3/tools/implementation_validator.py:219:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:416:0: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/implementation_validator.py:416:0: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/implementation_validator.py:416:0: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:469:27: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/implementation_validator.py:416:0: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:561:4: W0612: Unused variable 'arch_issue_ids' (unused-variable)
agent_s3/tools/implementation_validator.py:565:8: W0612: Unused variable 'file_path' (unused-variable)
agent_s3/tools/implementation_validator.py:584:0: R0914: Too many local variables (29/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:625:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:584:0: R0912: Too many branches (27/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:584:0: R0915: Too many statements (70/50) (too-many-statements)
agent_s3/tools/implementation_validator.py:588:4: W0613: Unused argument 'test_requirements' (unused-argument)
agent_s3/tools/implementation_validator.py:625:8: W0612: Unused variable 'file_path' (unused-variable)
agent_s3/tools/implementation_validator.py:813:0: R0914: Too many local variables (20/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:813:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:974:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:1004:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:974:0: R0912: Too many branches (19/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:1095:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:1095:0: R0912: Too many branches (17/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:1117:8: W0612: Unused variable 'file_path' (unused-variable)
agent_s3/tools/implementation_validator.py:1126:12: W0612: Unused variable 'function_name' (unused-variable)
agent_s3/tools/implementation_validator.py:1226:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:1188:0: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:1275:0: R0914: Too many local variables (36/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:1359:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:1359:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:1359:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:1275:0: R0912: Too many branches (34/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:1275:0: R0915: Too many statements (66/50) (too-many-statements)
agent_s3/tools/implementation_validator.py:1375:12: W0612: Unused variable 'function_text' (unused-variable)
agent_s3/tools/implementation_validator.py:1489:0: R0914: Too many local variables (54/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:1523:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:1489:0: R0912: Too many branches (43/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:1489:0: R0915: Too many statements (110/50) (too-many-statements)
agent_s3/tools/implementation_validator.py:1907:16: W0612: Unused variable 'edge_case_text' (unused-variable)
agent_s3/tools/implementation_validator.py:2087:0: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:2087:0: R0912: Too many branches (24/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:2087:0: R0915: Too many statements (53/50) (too-many-statements)
agent_s3/tools/implementation_validator.py:2213:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:2272:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:2293:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:2293:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:2276:4: W0613: Unused argument 'test_implementations' (unused-argument)
agent_s3/tools/implementation_validator.py:2320:24: W0612: Unused variable 'description' (unused-variable)
agent_s3/tools/implementation_validator.py:2376:0: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/implementation_validator.py:2433:34: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
agent_s3/tools/implementation_validator.py:2408:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:2376:0: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/tools/implementation_validator.py:2408:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/implementation_validator.py:13:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.semantic_cache
agent_s3/tools/semantic_cache.py:40:0: R0902: Too many instance attributes (14/7) (too-many-instance-attributes)
agent_s3/tools/semantic_cache.py:116:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:134:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:141:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:142:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:153:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:152:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:154:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:203:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:162:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/semantic_cache.py:198:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:195:28: E1120: No value for argument 'x' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:199:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:201:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:204:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:160:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/semantic_cache.py:236:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:227:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/semantic_cache.py:234:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:237:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:242:16: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/semantic_cache.py:318:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/semantic_cache.py:355:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:364:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:407:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:381:45: E1120: No value for argument 'x' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:381:45: E1120: No value for argument 'distances' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:381:45: E1120: No value for argument 'labels' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:404:32: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:408:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:368:12: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/semantic_cache.py:459:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:448:24: E1120: No value for argument 'x' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:458:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:461:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:483:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:496:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:522:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:521:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:523:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:529:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:530:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:537:8: W0621: Redefining name 'faiss' from outer scope (line 19) (redefined-outer-name)
agent_s3/tools/semantic_cache.py:538:8: W0621: Redefining name 'np' from outer scope (line 16) (redefined-outer-name)
agent_s3/tools/semantic_cache.py:537:8: W0404: Reimport 'faiss' (imported line 19) (reimported)
agent_s3/tools/semantic_cache.py:537:8: C0415: Import outside toplevel (faiss) (import-outside-toplevel)
agent_s3/tools/semantic_cache.py:538:8: W0404: Reimport 'numpy' (imported line 16) (reimported)
agent_s3/tools/semantic_cache.py:538:8: C0415: Import outside toplevel (numpy) (import-outside-toplevel)
agent_s3/tools/semantic_cache.py:578:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/semantic_cache.py:573:20: E1120: No value for argument 'x' in method call (no-value-for-parameter)
agent_s3/tools/semantic_cache.py:579:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:581:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/semantic_cache.py:251:16: W0201: Attribute 'index' defined outside __init__ (attribute-defined-outside-init)
agent_s3/tools/semantic_cache.py:559:8: W0201: Attribute 'index' defined outside __init__ (attribute-defined-outside-init)
agent_s3/tools/semantic_cache.py:562:8: W0201: Attribute 'index_lookup' defined outside __init__ (attribute-defined-outside-init)
agent_s3/tools/semantic_cache.py:253:16: W0201: Attribute 'next_id' defined outside __init__ (attribute-defined-outside-init)
agent_s3/tools/semantic_cache.py:563:8: W0201: Attribute 'next_id' defined outside __init__ (attribute-defined-outside-init)
agent_s3/tools/semantic_cache.py:605:12: W0621: Redefining name 'cache' from outer scope (line 20) (redefined-outer-name)
agent_s3/tools/semantic_cache.py:674:4: W0621: Redefining name 'cache' from outer scope (line 20) (redefined-outer-name)
agent_s3/tools/semantic_cache.py:655:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/semantic_cache.py:743:4: W0621: Redefining name 'cache' from outer scope (line 20) (redefined-outer-name)
agent_s3/tools/semantic_cache.py:740:4: C0415: Import outside toplevel (asyncio) (import-outside-toplevel)
agent_s3/tools/semantic_cache.py:17:0: C0411: standard import "pathlib.Path" should be placed before third party import "numpy" (wrong-import-order)
agent_s3/tools/semantic_cache.py:18:0: C0411: standard import "threading" should be placed before third party import "numpy" (wrong-import-order)
agent_s3/tools/semantic_cache.py:21:0: C0411: standard import "shutil" should be placed before third party imports "numpy", "faiss", "gptcache.cache" (wrong-import-order)
agent_s3/tools/semantic_cache.py:22:0: C0411: standard import "stat" should be placed before third party imports "numpy", "faiss", "gptcache.cache" (wrong-import-order)
agent_s3/tools/semantic_cache.py:14:0: W0611: Unused List imported from typing (unused-import)
agent_s3/tools/semantic_cache.py:20:0: W0611: Unused cache imported from gptcache (unused-import)
************* Module agent_s3.tools.plan_validator
agent_s3/tools/plan_validator.py:716:0: W0311: Bad indentation. Found 21 spaces, expected 20 (bad-indentation)
agent_s3/tools/plan_validator.py:724:0: W0311: Bad indentation. Found 25 spaces, expected 24 (bad-indentation)
agent_s3/tools/plan_validator.py:765:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/plan_validator.py:792:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/plan_validator.py:811:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/plan_validator.py:1009:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/plan_validator.py:1072:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1144:0: W0311: Bad indentation. Found 25 spaces, expected 24 (bad-indentation)
agent_s3/tools/plan_validator.py:1180:0: W0311: Bad indentation. Found 25 spaces, expected 24 (bad-indentation)
agent_s3/tools/plan_validator.py:1285:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1287:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1298:0: W0311: Bad indentation. Found 37 spaces, expected 36 (bad-indentation)
agent_s3/tools/plan_validator.py:1299:0: W0311: Bad indentation. Found 41 spaces, expected 40 (bad-indentation)
agent_s3/tools/plan_validator.py:1300:0: W0311: Bad indentation. Found 37 spaces, expected 36 (bad-indentation)
agent_s3/tools/plan_validator.py:1301:0: W0311: Bad indentation. Found 41 spaces, expected 40 (bad-indentation)
agent_s3/tools/plan_validator.py:1306:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1308:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1329:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/plan_validator.py:1:0: C0302: Too many lines in module (1479/1000) (too-many-lines)
agent_s3/tools/plan_validator.py:79:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/plan_validator.py:135:19: E1101: Instance of 'CodeAnalyzer' has no '_detect_language' member (no-member)
agent_s3/tools/plan_validator.py:139:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:167:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:165:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:168:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:182:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:179:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:183:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:186:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:152:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/plan_validator.py:112:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/plan_validator.py:190:0: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/tools/plan_validator.py:230:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:230:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:414:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:438:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:437:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:439:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:190:0: R0912: Too many branches (41/12) (too-many-branches)
agent_s3/tools/plan_validator.py:190:0: R0915: Too many statements (66/50) (too-many-statements)
agent_s3/tools/plan_validator.py:230:8: W0612: Unused variable 'group_idx' (unused-variable)
agent_s3/tools/plan_validator.py:444:0: R0914: Too many local variables (32/15) (too-many-locals)
agent_s3/tools/plan_validator.py:474:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:474:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:474:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:444:0: R0912: Too many branches (67/12) (too-many-branches)
agent_s3/tools/plan_validator.py:444:0: R0915: Too many statements (116/50) (too-many-statements)
agent_s3/tools/plan_validator.py:474:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:638:0: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/plan_validator.py:648:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:654:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:662:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:668:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:674:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:684:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:638:0: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/tools/plan_validator.py:638:0: R0915: Too many statements (58/50) (too-many-statements)
agent_s3/tools/plan_validator.py:730:0: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/plan_validator.py:742:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:812:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:730:0: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/tools/plan_validator.py:730:0: R0915: Too many statements (54/50) (too-many-statements)
agent_s3/tools/plan_validator.py:856:0: R0914: Too many local variables (27/15) (too-many-locals)
agent_s3/tools/plan_validator.py:919:103: C0207: Use current_global_loc_info.split(', element ', maxsplit=1)[0] instead (use-maxsplit-arg)
agent_s3/tools/plan_validator.py:856:0: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/plan_validator.py:937:0: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/plan_validator.py:944:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:948:51: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:953:52: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:956:52: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:959:50: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:989:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:975:78: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:976:72: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:977:63: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:978:64: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:943:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:987:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:990:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:943:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1000:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:998:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:1001:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:943:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:937:0: R0912: Too many branches (23/12) (too-many-branches)
agent_s3/tools/plan_validator.py:937:0: R0915: Too many statements (56/50) (too-many-statements)
agent_s3/tools/plan_validator.py:1017:0: R0914: Too many local variables (63/15) (too-many-locals)
agent_s3/tools/plan_validator.py:1032:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:1038:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:1030:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1093:59: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1094:61: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1095:61: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1096:62: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1097:63: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1104:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:1030:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1137:73: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1138:70: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1030:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1175:85: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1030:4: R1702: Too many nested blocks (11/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1017:0: R0912: Too many branches (54/12) (too-many-branches)
agent_s3/tools/plan_validator.py:1017:0: R0915: Too many statements (132/50) (too-many-statements)
agent_s3/tools/plan_validator.py:1030:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1218:0: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/plan_validator.py:1232:45: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1237:51: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1266:35: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/plan_validator.py:1273:70: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1274:64: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1275:55: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1276:56: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/plan_validator.py:1348:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (9/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1312:28: E0602: Undefined variable 'parse_js' (undefined-variable)
agent_s3/tools/plan_validator.py:1318:32: C0415: Import outside toplevel (agent_s3.ast_tools.ts_languages.get_ts_parser) (import-outside-toplevel)
agent_s3/tools/plan_validator.py:1323:32: E0602: Undefined variable 'parse_js' (undefined-variable)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1331:24: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1340:24: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/plan_validator.py:1218:0: R0912: Too many branches (37/12) (too-many-branches)
agent_s3/tools/plan_validator.py:1218:0: R0915: Too many statements (83/50) (too-many-statements)
agent_s3/tools/plan_validator.py:1231:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/plan_validator.py:1240:12: W0612: Unused variable 'feature_log_prefix' (unused-variable)
agent_s3/tools/plan_validator.py:1439:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/plan_validator.py:1440:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/plan_validator.py:14:0: W0611: Unused import glob (unused-import)
agent_s3/tools/plan_validator.py:18:0: W0611: Unused import importlib.util (unused-import)
agent_s3/tools/plan_validator.py:21:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/plan_validator.py:21:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/plan_validator.py:21:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/plan_validator.py:21:0: W0611: Unused Callable imported from typing (unused-import)
agent_s3/tools/plan_validator.py:27:0: W0611: Unused extract_units imported from agent_s3.ast_tools.python_units (unused-import)
agent_s3/tools/plan_validator.py:29:0: W0611: Unused LanguageParser imported from parsing.base_parser (unused-import)
************* Module agent_s3.tools.canonical_validator 3
agent_s3/tools/canonical_validator 3.py:1:0: C0103: Module name "canonical_validator 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/canonical_validator 3.py:17:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/canonical_validator 3.py:19:4: W0613: Unused argument 'element_ids' (unused-argument)
agent_s3/tools/canonical_validator 3.py:11:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.file_tool
agent_s3/tools/file_tool.py:31:12: C0415: Import outside toplevel (logging) (import-outside-toplevel)
agent_s3/tools/file_tool.py:76:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:64:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:72:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:78:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:98:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:95:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:149:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:138:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_tool.py:147:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:151:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:113:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/file_tool.py:113:40: W0613: Unused argument 'max_size' (unused-argument)
agent_s3/tools/file_tool.py:173:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:180:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:200:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:194:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_tool.py:198:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:202:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:224:12: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/file_tool.py:229:30: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/file_tool.py:245:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:241:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/file_tool.py:247:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:283:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:285:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:298:20: W0612: Unused variable 'error' (unused-variable)
agent_s3/tools/file_tool.py:314:20: W0612: Unused variable 'error' (unused-variable)
agent_s3/tools/file_tool.py:345:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:343:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:347:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:367:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/file_tool.py:369:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/file_tool.py:4:0: W0611: Unused import re (unused-import)
agent_s3/tools/file_tool.py:7:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/file_tool.py:7:0: W0611: Unused Dict imported from typing (unused-import)
agent_s3/tools/file_tool.py:7:0: W0611: Unused Any imported from typing (unused-import)
************* Module agent_s3.tools.phase_validator
agent_s3/tools/phase_validator.py:50:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:20:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/phase_validator.py:119:0: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/phase_validator.py:162:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:119:0: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/phase_validator.py:218:0: R0914: Too many local variables (41/15) (too-many-locals)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator.py:218:0: R0912: Too many branches (48/12) (too-many-branches)
agent_s3/tools/phase_validator.py:218:0: R0915: Too many statements (108/50) (too-many-statements)
agent_s3/tools/phase_validator.py:249:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/phase_validator.py:423:0: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/phase_validator.py:423:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/phase_validator.py:567:19: W0130: Duplicate value 'but' in set (duplicate-value)
agent_s3/tools/phase_validator.py:581:21: W0130: Duplicate value 'csrf' in set (duplicate-value)
agent_s3/tools/phase_validator.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/phase_validator.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/phase_validator.py:14:0: W0611: Unused import difflib (unused-import)
agent_s3/tools/phase_validator.py:15:0: W0611: Unused import json (unused-import)
************* Module agent_s3.tools.code_analysis_tool
agent_s3/tools/code_analysis_tool.py:63:0: R0902: Too many instance attributes (15/7) (too-many-instance-attributes)
agent_s3/tools/code_analysis_tool.py:72:4: W1113: Keyword argument before variable positional arguments list in the definition of __init__ function (keyword-arg-before-vararg)
agent_s3/tools/code_analysis_tool.py:107:35: E1123: Unexpected keyword argument 'workspace_path' in constructor call (unexpected-keyword-arg)
agent_s3/tools/code_analysis_tool.py:107:35: E1123: Unexpected keyword argument 'code_analysis_tool' in constructor call (unexpected-keyword-arg)
agent_s3/tools/code_analysis_tool.py:72:0: W0613: Unused argument 'args' (unused-argument)
agent_s3/tools/code_analysis_tool.py:72:0: W0613: Unused argument 'kwargs' (unused-argument)
agent_s3/tools/code_analysis_tool.py:151:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:152:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:162:4: R0914: Too many local variables (36/15) (too-many-locals)
agent_s3/tools/code_analysis_tool.py:174:30: E1101: Instance of 'EmbeddingClient' has no 'get_embedding' member (no-member)
agent_s3/tools/code_analysis_tool.py:186:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:194:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/code_analysis_tool.py:198:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:202:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:255:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:238:32: E1101: Instance of 'EmbeddingClient' has no 'get_embedding' member (no-member)
agent_s3/tools/code_analysis_tool.py:256:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:267:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:268:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:299:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:300:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:306:8: C0206: Consider iterating with .items() (consider-using-dict-items)
agent_s3/tools/code_analysis_tool.py:306:25: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
agent_s3/tools/code_analysis_tool.py:327:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:328:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:344:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:162:4: R0912: Too many branches (31/12) (too-many-branches)
agent_s3/tools/code_analysis_tool.py:162:4: R0915: Too many statements (92/50) (too-many-statements)
agent_s3/tools/code_analysis_tool.py:365:26: E1101: Instance of 'EmbeddingClient' has no 'get_embedding' member (no-member)
agent_s3/tools/code_analysis_tool.py:395:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:386:35: E1101: Instance of 'StaticAnalyzer' has no 'enhance_search_results' member (no-member)
agent_s3/tools/code_analysis_tool.py:394:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:396:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:348:45: W0613: Unused argument 'paths' (unused-argument)
agent_s3/tools/code_analysis_tool.py:428:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:422:22: E1101: Instance of 'StaticAnalyzer' has no 'find_structurally_relevant_files' member (no-member)
agent_s3/tools/code_analysis_tool.py:429:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:461:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:456:19: E1101: Instance of 'StaticAnalyzer' has no 'compute_multi_signal_relevance' member (no-member)
agent_s3/tools/code_analysis_tool.py:462:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:484:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:499:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:503:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:535:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:578:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:594:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:612:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:613:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:627:8: W0621: Redefining name 'np' from outer scope (line 17) (redefined-outer-name)
agent_s3/tools/code_analysis_tool.py:627:8: W0404: Reimport 'numpy' (imported line 17) (reimported)
agent_s3/tools/code_analysis_tool.py:627:8: C0415: Import outside toplevel (numpy) (import-outside-toplevel)
agent_s3/tools/code_analysis_tool.py:646:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:647:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:669:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:670:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:680:8: W0621: Redefining name 'time' from outer scope (line 11) (redefined-outer-name)
agent_s3/tools/code_analysis_tool.py:680:8: W0404: Reimport 'time' (imported line 11) (reimported)
agent_s3/tools/code_analysis_tool.py:680:8: C0415: Import outside toplevel (time) (import-outside-toplevel)
agent_s3/tools/code_analysis_tool.py:762:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:763:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:923:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:921:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:924:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:944:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/code_analysis_tool.py:935:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:945:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:948:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/code_analysis_tool.py:907:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/code_analysis_tool.py:8:0: W0611: Unused import tempfile (unused-import)
agent_s3/tools/code_analysis_tool.py:11:0: W0611: Unused import time (unused-import)
agent_s3/tools/code_analysis_tool.py:16:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/code_analysis_tool.py:16:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/code_analysis_tool.py:16:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/code_analysis_tool.py:18:0: W0611: Unused import toml (unused-import)
agent_s3/tools/code_analysis_tool.py:22:4: W0611: Unused import faiss (unused-import)
************* Module agent_s3.tools.security_validator
agent_s3/tools/security_validator.py:35:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/security_validator.py:63:8: W0612: Unused variable 'file_path' (unused-variable)
agent_s3/tools/security_validator.py:94:0: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/security_validator.py:157:22: C0201: Consider iterating the dictionary directly instead of calling .keys() (consider-iterating-dictionary)
agent_s3/tools/security_validator.py:127:16: W0612: Unused variable 'arch_message' (unused-variable)
agent_s3/tools/security_validator.py:356:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/security_validator.py:395:4: W0613: Unused argument 'implementation_plan' (unused-argument)
agent_s3/tools/security_validator.py:525:31: W0613: Unused argument 'implementation_plan' (unused-argument)
agent_s3/tools/security_validator.py:539:45: W0613: Unused argument 'patterns' (unused-argument)
agent_s3/tools/security_validator.py:602:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/security_validator.py:631:8: W0612: Unused variable 'aspect' (unused-variable)
agent_s3/tools/security_validator.py:705:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/security_validator.py:23:0: W0611: Unused import re (unused-import)
agent_s3/tools/security_validator.py:24:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.ast_tool
agent_s3/tools/ast_tool.py:32:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/ast_tool.py:8:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module agent_s3.tools.error_context_manager
agent_s3/tools/error_context_manager.py:1:0: C0302: Too many lines in module (1047/1000) (too-many-lines)
agent_s3/tools/error_context_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/error_context_manager.py:8:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
agent_s3/tools/error_context_manager.py:163:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:126:16: W0212: Access to a protected member _refine_current_context of a client class (protected-access)
agent_s3/tools/error_context_manager.py:129:21: W0212: Access to a protected member _context_lock of a client class (protected-access)
agent_s3/tools/error_context_manager.py:152:35: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:122:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/error_context_manager.py:206:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:211:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/error_context_manager.py:263:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:211:73: W0613: Unused argument 'error_message' (unused-argument)
agent_s3/tools/error_context_manager.py:306:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:304:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:268:71: W0613: Unused argument 'error_message' (unused-argument)
agent_s3/tools/error_context_manager.py:311:4: R0914: Too many local variables (26/15) (too-many-locals)
agent_s3/tools/error_context_manager.py:317:8: C0415: Import outside toplevel (subprocess) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:318:8: C0415: Import outside toplevel (shutil) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:319:8: C0415: Import outside toplevel (stat) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:333:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:328:33: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/error_context_manager.py:329:24: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:342:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:358:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:349:33: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/error_context_manager.py:372:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:365:41: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/error_context_manager.py:368:28: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:381:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:393:31: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:388:37: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/error_context_manager.py:389:28: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:414:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:407:33: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/error_context_manager.py:410:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:423:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:436:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:431:29: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/error_context_manager.py:432:20: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/error_context_manager.py:311:4: R0911: Too many return statements (27/6) (too-many-return-statements)
agent_s3/tools/error_context_manager.py:311:4: R0912: Too many branches (43/12) (too-many-branches)
agent_s3/tools/error_context_manager.py:311:4: R0915: Too many statements (87/50) (too-many-statements)
agent_s3/tools/error_context_manager.py:441:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/error_context_manager.py:506:12: C0415: Import outside toplevel (psutil) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:489:51: W0613: Unused argument 'error_info' (unused-argument)
agent_s3/tools/error_context_manager.py:784:12: W0612: Unused variable 'primary_file' (unused-variable)
agent_s3/tools/error_context_manager.py:785:12: W0612: Unused variable 'primary_line' (unused-variable)
agent_s3/tools/error_context_manager.py:803:4: R0914: Too many local variables (29/15) (too-many-locals)
agent_s3/tools/error_context_manager.py:920:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:803:4: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/error_context_manager.py:803:4: R0915: Too many statements (64/50) (too-many-statements)
agent_s3/tools/error_context_manager.py:958:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:954:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:952:16: C0415: Import outside toplevel (site) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:975:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/error_context_manager.py:982:8: C0415: Import outside toplevel (socket) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:983:8: C0415: Import outside toplevel (urllib.request) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:1016:8: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/error_context_manager.py:1014:12: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/error_context_manager.py:1024:8: W0702: No exception type(s) specified (bare-except)
agent_s3/tools/error_context_manager.py:1022:12: R1732: Consider using 'with' for resource-allocating operations (consider-using-with)
agent_s3/tools/error_context_manager.py:1035:8: W0621: Redefining name 'os' from outer scope (line 1) (redefined-outer-name)
agent_s3/tools/error_context_manager.py:1035:8: W0404: Reimport 'os' (imported line 1) (reimported)
agent_s3/tools/error_context_manager.py:1035:8: C0415: Import outside toplevel (os) (import-outside-toplevel)
agent_s3/tools/error_context_manager.py:4:0: W0611: Unused import json (unused-import)
************* Module agent_s3.tools.index_partition_manager
agent_s3/tools/index_partition_manager.py:81:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:79:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:82:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:90:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:88:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:91:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:109:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:97:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:110:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:147:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:123:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:130:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:142:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:146:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:148:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:177:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:178:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:202:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:203:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:234:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:235:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:268:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/index_partition_manager.py:333:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:334:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:384:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:385:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:439:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:437:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:440:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:478:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:473:35: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:456:37: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:474:32: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:476:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:479:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:443:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/index_partition_manager.py:496:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:493:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/index_partition_manager.py:497:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:541:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:539:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:542:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:568:15: W0212: Access to a protected member _file_matches_criteria of a client class (protected-access)
agent_s3/tools/index_partition_manager.py:626:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:627:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:664:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:665:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:710:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:711:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:822:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:823:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:826:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/index_partition_manager.py:883:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:884:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:901:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:902:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:892:16: W0612: Unused variable 'pid' (unused-variable)
agent_s3/tools/index_partition_manager.py:930:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/index_partition_manager.py:916:20: W0212: Access to a protected member _load_data of a client class (protected-access)
agent_s3/tools/index_partition_manager.py:931:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/index_partition_manager.py:13:0: W0611: Unused Path imported from pathlib (unused-import)
agent_s3/tools/index_partition_manager.py:14:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/index_partition_manager.py:14:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/index_partition_manager.py:14:0: W0611: Unused Callable imported from typing (unused-import)
************* Module agent_s3.tools.reporting
agent_s3/tools/reporting.py:13:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/reporting.py:98:4: C0415: Import outside toplevel (xml.dom.minidom) (import-outside-toplevel)
agent_s3/tools/reporting.py:13:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/reporting.py:13:0: R0915: Too many statements (53/50) (too-many-statements)
************* Module agent_s3.tools.phase_validator 4
agent_s3/tools/phase_validator 4.py:1:0: C0103: Module name "phase_validator 4" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/phase_validator 4.py:50:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:20:0: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/phase_validator 4.py:119:0: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/phase_validator 4.py:162:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:119:0: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/phase_validator 4.py:218:0: R0914: Too many local variables (41/15) (too-many-locals)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:307:4: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/phase_validator 4.py:218:0: R0912: Too many branches (48/12) (too-many-branches)
agent_s3/tools/phase_validator 4.py:218:0: R0915: Too many statements (108/50) (too-many-statements)
agent_s3/tools/phase_validator 4.py:249:8: W0612: Unused variable 'test_type' (unused-variable)
agent_s3/tools/phase_validator 4.py:423:0: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/phase_validator 4.py:423:0: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/phase_validator 4.py:567:19: W0130: Duplicate value 'but' in set (duplicate-value)
agent_s3/tools/phase_validator 4.py:581:21: W0130: Duplicate value 'csrf' in set (duplicate-value)
agent_s3/tools/phase_validator 4.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/phase_validator 4.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/phase_validator 4.py:14:0: W0611: Unused import difflib (unused-import)
agent_s3/tools/phase_validator 4.py:15:0: W0611: Unused import json (unused-import)
************* Module agent_s3.tools.context_management.interfaces
agent_s3/tools/context_management/interfaces.py:11:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/context_management/interfaces.py:9:0: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces.py:16:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:13:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:36:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:41:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:46:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:51:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:56:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:61:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:66:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:76:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:82:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:87:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:94:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:99:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:104:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:109:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:116:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces.py:111:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces.py:165:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces.py:156:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module agent_s3.tools.context_management.context_manager
agent_s3/tools/context_management/context_manager.py:1:0: C0302: Too many lines in module (1492/1000) (too-many-lines)
agent_s3/tools/context_management/context_manager.py:83:4: R0913: Too many arguments (6/5) (too-many-arguments)
agent_s3/tools/context_management/context_manager.py:83:4: R0917: Too many positional arguments (6/5) (too-many-positional-arguments)
agent_s3/tools/context_management/context_manager.py:248:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:247:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:249:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:252:0: R0902: Too many instance attributes (18/7) (too-many-instance-attributes)
agent_s3/tools/context_management/context_manager.py:296:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:283:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:293:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:297:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:332:8: E1101: Instance of 'CompressionManager' has no 'set_summarization_threshold' member (no-member)
agent_s3/tools/context_management/context_manager.py:335:8: E1101: Instance of 'CompressionManager' has no 'set_compression_ratio' member (no-member)
agent_s3/tools/context_management/context_manager.py:315:8: W0612: Unused variable 'importance_scoring' (unused-variable)
agent_s3/tools/context_management/context_manager.py:371:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/context_management/context_manager.py:371:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/context_management/context_manager.py:447:4: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/context_management/context_manager.py:452:8: C0415: Import outside toplevel (warnings) (import-outside-toplevel)
agent_s3/tools/context_management/context_manager.py:467:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:466:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:468:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:447:4: R0912: Too many branches (15/12) (too-many-branches)
agent_s3/tools/context_management/context_manager.py:559:12: W0612: Unused variable 'i' (unused-variable)
agent_s3/tools/context_management/context_manager.py:567:4: R0913: Too many arguments (8/5) (too-many-arguments)
agent_s3/tools/context_management/context_manager.py:567:4: R0917: Too many positional arguments (8/5) (too-many-positional-arguments)
agent_s3/tools/context_management/context_manager.py:640:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:640:60: W0212: Access to a protected member _tools of a client class (protected-access)
agent_s3/tools/context_management/context_manager.py:676:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:677:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:681:4: R0914: Too many local variables (24/15) (too-many-locals)
agent_s3/tools/context_management/context_manager.py:757:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:693:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/context_management/context_manager.py:715:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:746:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:693:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/context_management/context_manager.py:750:46: E1101: Instance of 'CompressionManager' has no 'compress_text' member (no-member)
agent_s3/tools/context_management/context_manager.py:758:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:681:4: R0912: Too many branches (25/12) (too-many-branches)
agent_s3/tools/context_management/context_manager.py:681:4: R0915: Too many statements (53/50) (too-many-statements)
agent_s3/tools/context_management/context_manager.py:697:12: W0612: Unused variable 'allocation_result' (unused-variable)
agent_s3/tools/context_management/context_manager.py:824:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:810:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:825:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:770:80: W0613: Unused argument 'task_keywords' (unused-argument)
agent_s3/tools/context_management/context_manager.py:832:4: R0913: Too many arguments (7/5) (too-many-arguments)
agent_s3/tools/context_management/context_manager.py:832:4: R0917: Too many positional arguments (7/5) (too-many-positional-arguments)
agent_s3/tools/context_management/context_manager.py:834:8: W0613: Unused argument 'current_files' (unused-argument)
agent_s3/tools/context_management/context_manager.py:835:8: W0613: Unused argument 'task_description' (unused-argument)
agent_s3/tools/context_management/context_manager.py:837:8: W0613: Unused argument 'related_files' (unused-argument)
agent_s3/tools/context_management/context_manager.py:838:8: W0613: Unused argument 'max_tokens' (unused-argument)
agent_s3/tools/context_management/context_manager.py:878:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:881:4: R0914: Too many local variables (43/15) (too-many-locals)
agent_s3/tools/context_management/context_manager.py:907:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:911:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:915:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:919:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:929:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:932:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:943:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:947:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:951:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:961:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:965:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:977:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:978:24: E1101: Instance of 'CompressionManager' has no 'set_summarization_threshold' member (no-member)
agent_s3/tools/context_management/context_manager.py:982:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:983:24: E1101: Instance of 'CompressionManager' has no 'set_compression_ratio' member (no-member)
agent_s3/tools/context_management/context_manager.py:987:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:991:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1005:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1009:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1013:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1017:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1021:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1025:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1028:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1028:33: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/context_management/context_manager.py:1037:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1045:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1057:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1067:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1078:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1082:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1086:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1089:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1098:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1099:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:881:4: R0912: Too many branches (46/12) (too-many-branches)
agent_s3/tools/context_management/context_manager.py:881:4: R0915: Too many statements (158/50) (too-many-statements)
agent_s3/tools/context_management/context_manager.py:1163:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1164:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1175:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1176:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1187:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1188:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1223:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1224:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1249:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1250:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1262:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1263:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1274:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1275:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1287:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1288:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1299:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1300:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1358:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1359:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1468:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1451:27: E1101: Instance of 'TokenBudgetAnalyzer' has no 'analyze_context' member (no-member)
agent_s3/tools/context_management/context_manager.py:1469:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:1491:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_manager.py:1492:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_manager.py:252:0: R0904: Too many public methods (25/20) (too-many-public-methods)
agent_s3/tools/context_management/context_manager.py:26:0: C0411: standard import "enum.Enum" should be placed before first party imports "agent_s3.tools.context_management.context_size_monitor.ContextSizeMonitor", "agent_s3.tools.context_management.content_pruning_manager.ContentPruningManager"  (wrong-import-order)
agent_s3/tools/context_management/context_manager.py:8:0: W0611: Unused import asyncio (unused-import)
agent_s3/tools/context_management/context_manager.py:13:0: W0611: Unused import heapq (unused-import)
agent_s3/tools/context_management/context_manager.py:14:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/context_manager.py:14:0: W0611: Unused Callable imported from typing (unused-import)
agent_s3/tools/context_management/context_manager.py:16:0: W0611: Unused import ast (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused ContextProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused TechStackProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused FileContextProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused ProjectContextProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused TestContextProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused MemoryContextProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused DependencyGraphProvider imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused DependencyNode imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:31:0: W0611: Unused DependencyEdge imported from agent_s3.tools.context_management.interfaces (unused-import)
agent_s3/tools/context_management/context_manager.py:36:0: W0611: Unused ProjectProfiler imported from agent_s3.tools.context_management.adaptive_config (unused-import)
agent_s3/tools/context_management/context_manager.py:36:0: W0611: Unused ConfigTemplateManager imported from agent_s3.tools.context_management.adaptive_config (unused-import)
agent_s3/tools/context_management/context_manager.py:36:0: W0611: Unused MetricsCollector imported from agent_s3.tools.context_management.adaptive_config (unused-import)
agent_s3/tools/context_management/context_manager.py:36:0: W0611: Unused ConfigExplainer imported from agent_s3.tools.context_management.adaptive_config (unused-import)
************* Module agent_s3.tools.context_management.context_registry
agent_s3/tools/context_management/context_registry.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:24:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:25:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:33:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:37:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:43:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:45:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:49:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:51:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:70:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:77:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:84:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:87:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:91:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:98:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:101:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:108:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:115:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:133:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:136:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:143:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:150:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:157:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:161:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry.py:164:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:173:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry.py:173:36: W0613: Unused argument 'context_type' (unused-argument)
agent_s3/tools/context_management/context_registry.py:15:0: R0904: Too many public methods (24/20) (too-many-public-methods)
************* Module agent_s3.tools.context_management.content_pruning_manager
agent_s3/tools/context_management/content_pruning_manager.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/context_management/content_pruning_manager.py:9:0: R0902: Too many instance attributes (10/7) (too-many-instance-attributes)
agent_s3/tools/context_management/content_pruning_manager.py:24:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/content_pruning_manager.py:35:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/content_pruning_manager.py:38:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/content_pruning_manager.py:63:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module agent_s3.tools.context_management.token_budget
agent_s3/tools/context_management/token_budget.py:80:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/token_budget.py:153:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/token_budget.py:154:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/token_budget.py:173:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/context_management/token_budget.py:241:0: C0206: Consider iterating with .items() (consider-using-dict-items)
agent_s3/tools/context_management/token_budget.py:392:4: R0914: Too many local variables (25/15) (too-many-locals)
agent_s3/tools/context_management/token_budget.py:392:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/context_management/token_budget.py:408:12: W0612: Unused variable 'avg_line_length' (unused-variable)
agent_s3/tools/context_management/token_budget.py:455:16: W0612: Unused variable 'pattern_name' (unused-variable)
agent_s3/tools/context_management/token_budget.py:481:4: R0914: Too many local variables (18/15) (too-many-locals)
agent_s3/tools/context_management/token_budget.py:517:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/token_budget.py:518:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/token_budget.py:481:4: R0912: Too many branches (24/12) (too-many-branches)
agent_s3/tools/context_management/token_budget.py:578:4: R0914: Too many local variables (35/15) (too-many-locals)
agent_s3/tools/context_management/token_budget.py:611:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/context_management/token_budget.py:676:31: R1716: Simplify chained comparison between the operands (chained-comparison)
agent_s3/tools/context_management/token_budget.py:704:16: C0206: Consider iterating with .items() (consider-using-dict-items)
agent_s3/tools/context_management/token_budget.py:611:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/context_management/token_budget.py:705:23: R1714: Consider merging these comparisons with 'in' by using 'section not in ('code_context', 'total')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/token_budget.py:578:4: R0912: Too many branches (16/12) (too-many-branches)
agent_s3/tools/context_management/token_budget.py:578:4: R0915: Too many statements (56/50) (too-many-statements)
agent_s3/tools/context_management/token_budget.py:655:28: W0612: Unused variable 'language' (unused-variable)
agent_s3/tools/context_management/token_budget.py:668:32: W0612: Unused variable 'i' (unused-variable)
agent_s3/tools/context_management/token_budget.py:792:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/context_management/token_budget.py:771:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/token_budget.py:848:36: W0613: Unused argument 'file_path' (unused-argument)
agent_s3/tools/context_management/token_budget.py:848:47: W0613: Unused argument 'content' (unused-argument)
agent_s3/tools/context_management/token_budget.py:848:56: W0613: Unused argument 'task_type' (unused-argument)
agent_s3/tools/context_management/token_budget.py:795:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/token_budget.py:957:16: W0612: Unused variable 'scorer_name' (unused-variable)
agent_s3/tools/context_management/token_budget.py:859:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/token_budget.py:13:0: C0411: standard import "os" should be placed before third party import "tiktoken" (wrong-import-order)
agent_s3/tools/context_management/token_budget.py:14:0: C0411: standard import "ast" should be placed before third party import "tiktoken" (wrong-import-order)
agent_s3/tools/context_management/token_budget.py:15:0: C0411: standard import "abc.ABC" should be placed before third party import "tiktoken" (wrong-import-order)
agent_s3/tools/context_management/token_budget.py:16:0: C0411: standard import "typing.Dict" should be placed before third party import "tiktoken" (wrong-import-order)
agent_s3/tools/context_management/token_budget.py:17:0: C0411: standard import "collections.defaultdict" should be placed before third party import "tiktoken" (wrong-import-order)
agent_s3/tools/context_management/token_budget.py:10:0: W0611: Unused import math (unused-import)
agent_s3/tools/context_management/token_budget.py:16:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/token_budget.py:16:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/token_budget.py:17:0: W0611: Unused defaultdict imported from collections (unused-import)
************* Module agent_s3.tools.context_management.compression
agent_s3/tools/context_management/compression.py:1:0: C0302: Too many lines in module (1307/1000) (too-many-lines)
agent_s3/tools/context_management/compression.py:38:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/context_management/compression.py:51:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/context_management/compression.py:203:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/compression.py:215:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/context_management/compression.py:294:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/compression.py:215:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:220:8: W0612: Unused variable 'in_function' (unused-variable)
agent_s3/tools/context_management/compression.py:261:29: W0612: Unused variable 'params' (unused-variable)
agent_s3/tools/context_management/compression.py:376:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/compression.py:299:4: R0912: Too many branches (20/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:304:8: W0612: Unused variable 'in_function' (unused-variable)
agent_s3/tools/context_management/compression.py:305:8: W0612: Unused variable 'in_class' (unused-variable)
agent_s3/tools/context_management/compression.py:317:12: W0612: Unused variable 'i' (unused-variable)
agent_s3/tools/context_management/compression.py:451:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/compression.py:381:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:387:8: W0612: Unused variable 'in_method' (unused-variable)
agent_s3/tools/context_management/compression.py:388:8: W0612: Unused variable 'in_class' (unused-variable)
agent_s3/tools/context_management/compression.py:526:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/compression.py:456:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:462:8: W0612: Unused variable 'in_method' (unused-variable)
agent_s3/tools/context_management/compression.py:463:8: W0612: Unused variable 'in_class' (unused-variable)
agent_s3/tools/context_management/compression.py:684:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/tools/context_management/compression.py:684:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:961:12: W0612: Unused variable 'pattern_hash' (unused-variable)
agent_s3/tools/context_management/compression.py:1085:15: R1714: Consider merging these comparisons with 'in' by using 'key not in ('code_context', 'compression_metadata')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/compression.py:1172:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/compression.py:1145:27: R1714: Consider merging these comparisons with 'in' by using 'key not in ('code_context', 'compression_metadata')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/compression.py:1149:27: R1714: Consider merging these comparisons with 'in' by using 'key not in ('code_context', 'compression_metadata')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/compression.py:1173:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/compression.py:1222:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/compression.py:1201:27: R1714: Consider merging these comparisons with 'in' by using 'key not in ('code_context', 'compression_metadata')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/compression.py:1205:27: R1714: Consider merging these comparisons with 'in' by using 'key not in ('code_context', 'compression_metadata')'. Use a set instead if elements are hashable. (consider-using-in)
agent_s3/tools/context_management/compression.py:1223:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/compression.py:1092:4: R0912: Too many branches (26/12) (too-many-branches)
agent_s3/tools/context_management/compression.py:1092:4: R0915: Too many statements (54/50) (too-many-statements)
agent_s3/tools/context_management/compression.py:9:0: W0611: Unused import json (unused-import)
agent_s3/tools/context_management/compression.py:11:0: W0611: Unused import zlib (unused-import)
agent_s3/tools/context_management/compression.py:12:0: W0611: Unused import base64 (unused-import)
agent_s3/tools/context_management/compression.py:15:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/compression.py:15:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/compression.py:15:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/compression.py:15:0: W0611: Unused Callable imported from typing (unused-import)
agent_s3/tools/context_management/compression.py:16:0: W0611: Unused Path imported from pathlib (unused-import)
************* Module agent_s3.tools.context_management.llm_integration
agent_s3/tools/context_management/llm_integration.py:17:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/llm_integration.py:221:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/llm_integration.py:129:12: R0402: Use 'from agent_s3 import llm_utils' instead (consider-using-from-import)
agent_s3/tools/context_management/llm_integration.py:129:12: C0415: Import outside toplevel (agent_s3.llm_utils) (import-outside-toplevel)
agent_s3/tools/context_management/llm_integration.py:130:12: C0415: Import outside toplevel (agent_s3.config.get_config, agent_s3.config.ConfigModel) (import-outside-toplevel)
agent_s3/tools/context_management/llm_integration.py:132:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/llm_integration.py:138:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/llm_integration.py:139:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/llm_integration.py:200:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/llm_integration.py:202:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/llm_integration.py:214:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/llm_integration.py:213:16: W0212: Access to a protected member _start_background_optimization of a client class (protected-access)
agent_s3/tools/context_management/llm_integration.py:215:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/llm_integration.py:222:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/llm_integration.py:120:0: R0915: Too many statements (51/50) (too-many-statements)
agent_s3/tools/context_management/llm_integration.py:11:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/llm_integration.py:11:0: W0611: Unused List imported from typing (unused-import)
agent_s3/tools/context_management/llm_integration.py:11:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/llm_integration.py:11:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/llm_integration.py:11:0: W0611: Unused Callable imported from typing (unused-import)
************* Module agent_s3.tools.context_management.context_adapter
agent_s3/tools/context_management/context_adapter.py:93:4: R0914: Too many local variables (22/15) (too-many-locals)
agent_s3/tools/context_management/context_adapter.py:93:4: R0912: Too many branches (21/12) (too-many-branches)
agent_s3/tools/context_management/context_adapter.py:256:16: W0612: Unused variable 'import_matches' (unused-variable)
agent_s3/tools/context_management/context_adapter.py:284:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/context_adapter.py:279:16: C0415: Import outside toplevel (yaml) (import-outside-toplevel)
agent_s3/tools/context_management/context_adapter.py:285:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_adapter.py:311:53: R1721: Unnecessary use of a comprehension, use dict(sorted_files) instead. (unnecessary-comprehension)
agent_s3/tools/context_management/context_adapter.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/context_adapter.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tools.context_management.interfaces 3
agent_s3/tools/context_management/interfaces 3.py:1:0: C0103: Module name "interfaces 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/interfaces 3.py:11:4: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/context_management/interfaces 3.py:9:0: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces 3.py:16:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:13:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces 3.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:26:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:30:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:36:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:41:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:46:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:51:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:56:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:61:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:66:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:72:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:76:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:82:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:87:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:94:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:99:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:104:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:109:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:116:8: W2301: Unnecessary ellipsis constant (unnecessary-ellipsis)
agent_s3/tools/context_management/interfaces 3.py:111:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/interfaces 3.py:165:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/interfaces 3.py:156:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module agent_s3.tools.context_management.context_registry 4
agent_s3/tools/context_management/context_registry 4.py:1:0: C0103: Module name "context_registry 4" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/context_registry 4.py:22:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:24:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:25:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:27:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:33:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:37:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:39:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:43:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:45:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:49:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:51:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:57:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:66:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:70:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:73:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:77:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:80:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:84:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:87:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:91:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:94:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:98:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:101:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:108:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:115:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:122:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:129:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:133:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:136:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:143:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:150:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:157:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:161:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_registry 4.py:164:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:173:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_registry 4.py:173:36: W0613: Unused argument 'context_type' (unused-argument)
agent_s3/tools/context_management/context_registry 4.py:15:0: R0904: Too many public methods (24/20) (too-many-public-methods)
************* Module agent_s3.tools.context_management.checkpoint_manager
agent_s3/tools/context_management/checkpoint_manager.py:61:9: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/checkpoint_manager.py:64:9: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/checkpoint_manager.py:67:4: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/checkpoint_manager.py:88:9: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/checkpoint_manager.py:99:13: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/checkpoint_manager.py:136:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/checkpoint_manager.py:128:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/checkpoint_manager.py:137:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/checkpoint_manager.py:196:0: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/context_management/checkpoint_manager.py:212:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/checkpoint_manager.py:11:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/checkpoint_manager.py:12:0: W0611: Unused import difflib (unused-import)
************* Module agent_s3.tools.context_management.context_size_monitor
agent_s3/tools/context_management/context_size_monitor.py:1:0: C0114: Missing module docstring (missing-module-docstring)
agent_s3/tools/context_management/context_size_monitor.py:19:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_size_monitor.py:27:20: W0612: Unused variable 'k' (unused-variable)
agent_s3/tools/context_management/context_size_monitor.py:39:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/context_size_monitor.py:47:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_size_monitor.py:58:4: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/tools/context_management/context_size_monitor.py:68:4: C0116: Missing function or method docstring (missing-function-docstring)
************* Module agent_s3.tools.context_management.coordinator_integration
agent_s3/tools/context_management/coordinator_integration.py:46:12: C0415: Import outside toplevel (agent_s3.config.Config) (import-outside-toplevel)
agent_s3/tools/context_management/coordinator_integration.py:46:12: W0611: Unused Config imported from agent_s3.config (unused-import)
agent_s3/tools/context_management/coordinator_integration.py:92:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/coordinator_integration.py:137:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:136:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:138:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:190:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:191:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:304:20: C0415: Import outside toplevel (re) (import-outside-toplevel)
agent_s3/tools/context_management/coordinator_integration.py:355:37: W0212: Access to a protected member _models_by_role of a client class (protected-access)
agent_s3/tools/context_management/coordinator_integration.py:435:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:436:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:489:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:490:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:21:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/context_management/coordinator_integration.py:581:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:515:8: C0415: Import outside toplevel (agent_s3.config.Config) (import-outside-toplevel)
agent_s3/tools/context_management/coordinator_integration.py:545:8: C0415: Import outside toplevel (agent_s3.tools.context_management.llm_integration.integrate_with_llm_utils) (import-outside-toplevel)
agent_s3/tools/context_management/coordinator_integration.py:565:12: W0212: Access to a protected member _start_background_optimization of a client class (protected-access)
agent_s3/tools/context_management/coordinator_integration.py:583:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:515:8: W0611: Unused Config imported from agent_s3.config (unused-import)
agent_s3/tools/context_management/coordinator_integration.py:610:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:611:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:636:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:632:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/coordinator_integration.py:637:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:614:40: W0613: Unused argument 'reason' (unused-argument)
agent_s3/tools/context_management/coordinator_integration.py:660:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:656:8: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/coordinator_integration.py:661:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:695:11: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/coordinator_integration.py:696:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/coordinator_integration.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.adaptive_config_manager
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:24:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:91:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:78:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:92:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:126:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:112:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:124:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:127:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:169:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:180:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:219:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:194:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:213:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:220:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:241:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:242:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:320:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:314:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:321:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:366:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:367:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:395:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:396:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:425:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:411:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:426:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:451:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:452:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:489:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:474:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:478:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:482:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:490:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:509:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:510:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:502:12: W0612: Unused variable 'repo_metrics' (unused-variable)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:12:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager.py:15:0: W0611: Unused timedelta imported from datetime (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.__init__
************* Module agent_s3.tools.context_management.adaptive_config.config_explainer
agent_s3/tools/context_management/adaptive_config/config_explainer.py:31:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:245:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:246:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:249:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:325:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:326:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:436:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:442:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:448:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:454:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:460:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:466:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:472:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:478:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:484:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:490:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:400:4: R0911: Too many return statements (21/6) (too-many-return-statements)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:400:4: R0912: Too many branches (37/12) (too-many-branches)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:498:4: R0912: Too many branches (28/12) (too-many-branches)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:498:4: R0915: Too many statements (66/50) (too-many-statements)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:643:4: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:713:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:663:28: E0602: Undefined variable 'os' (undefined-variable)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:666:44: E0602: Undefined variable 'os' (undefined-variable)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:672:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:675:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:714:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:719:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:734:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:746:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:757:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:768:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:779:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:790:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:891:8: W0613: Unused argument 'current_config' (unused-argument)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:9:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:9:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:9:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:9:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:10:0: W0611: Unused import time (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer.py:12:0: W0611: Unused import textwrap (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.config_templates 4
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:1:0: C0103: Module name "config_templates 4" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:420:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:481:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:494:12: W0707: Consider explicitly re-raising using 'except FileNotFoundError as exc' and 'raise FileNotFoundError(f'Templates file not found: {file_path}') from exc' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:496:12: W0707: Consider explicitly re-raising using 'except Exception as exc' and 'raise ValueError(f'Invalid JSON in templates file: {file_path}') from exc' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:509:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:512:12: W0707: Consider explicitly re-raising using 'raise IOError(f'Failed to save templates to {file_path}: {e}') from e' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:10:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_templates 4.py:10:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.metrics_collector
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:57:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:256:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:249:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:252:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:257:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:275:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:274:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:276:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:312:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:552:41: W1309: Using an f-string that does not have any interpolated variables (f-string-without-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:591:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:584:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:592:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:595:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:12:0: W0611: Unused timedelta imported from datetime (unused-import)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:13:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:13:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:13:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/metrics_collector.py:14:0: W0611: Unused deque imported from collections (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.project_profiler
agent_s3/tools/context_management/adaptive_config/project_profiler.py:75:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:105:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:126:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:185:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:326:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:406:34: R1721: Unnecessary use of a comprehension, use dict(sorted(dirs.items(), key=lambda x: x[1], reverse=True)[:20]) instead. (unnecessary-comprehension)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:391:31: W0612: Unused variable 'files' (unused-variable)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler.py:14:0: W0611: Unused import math (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.config_templates
agent_s3/tools/context_management/adaptive_config/config_templates.py:420:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_templates.py:481:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_templates.py:494:12: W0707: Consider explicitly re-raising using 'except FileNotFoundError as exc' and 'raise FileNotFoundError(f'Templates file not found: {file_path}') from exc' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates.py:496:12: W0707: Consider explicitly re-raising using 'except Exception as exc' and 'raise ValueError(f'Invalid JSON in templates file: {file_path}') from exc' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates.py:509:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_templates.py:512:12: W0707: Consider explicitly re-raising using 'raise IOError(f'Failed to save templates to {file_path}: {e}') from e' (raise-missing-from)
agent_s3/tools/context_management/adaptive_config/config_templates.py:10:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_templates.py:10:0: W0611: Unused Union imported from typing (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.adaptive_config_manager 4
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:1:0: C0103: Module name "adaptive_config_manager 4" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:24:0: R0902: Too many instance attributes (12/7) (too-many-instance-attributes)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:91:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:78:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:92:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:126:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:112:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:124:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:127:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:169:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:180:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:219:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:194:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:213:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:220:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:241:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:242:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:320:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:314:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:321:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:366:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:367:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:395:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:396:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:425:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:411:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:426:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:451:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:452:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:489:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:474:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:478:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:482:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:490:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:509:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:510:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:502:12: W0612: Unused variable 'repo_metrics' (unused-variable)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:12:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/adaptive_config_manager 4.py:15:0: W0611: Unused timedelta imported from datetime (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.project_profiler 4
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:1:0: C0103: Module name "project_profiler 4" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:75:0: R0902: Too many instance attributes (9/7) (too-many-instance-attributes)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:105:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:126:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:185:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:326:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:406:34: R1721: Unnecessary use of a comprehension, use dict(sorted(dirs.items(), key=lambda x: x[1], reverse=True)[:20]) instead. (unnecessary-comprehension)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:391:31: W0612: Unused variable 'files' (unused-variable)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:12:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:12:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:12:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/project_profiler 4.py:14:0: W0611: Unused import math (unused-import)
************* Module agent_s3.tools.context_management.adaptive_config.config_explainer 3
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:1:0: C0103: Module name "config_explainer 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:31:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:245:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:246:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:249:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:325:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:326:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:436:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:442:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:448:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:454:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:460:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:466:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:472:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:478:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:484:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:490:12: R1705: Unnecessary "else" after "return", remove the "else" and de-indent the code inside it (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:400:4: R0911: Too many return statements (21/6) (too-many-return-statements)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:400:4: R0912: Too many branches (37/12) (too-many-branches)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:498:4: R0912: Too many branches (28/12) (too-many-branches)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:498:4: R0915: Too many statements (66/50) (too-many-statements)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:643:4: R0914: Too many local variables (21/15) (too-many-locals)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:713:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:663:28: E0602: Undefined variable 'os' (undefined-variable)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:666:44: E0602: Undefined variable 'os' (undefined-variable)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:672:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:675:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:714:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:719:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:734:12: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:746:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:757:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:768:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:779:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:790:8: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:891:8: W0613: Unused argument 'current_config' (unused-argument)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:9:0: W0611: Unused Optional imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:9:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:9:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:9:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:10:0: W0611: Unused import time (unused-import)
agent_s3/tools/context_management/adaptive_config/config_explainer 3.py:12:0: W0611: Unused import textwrap (unused-import)
************* Module agent_s3.tools.test_critic.reporter 3
agent_s3/tools/test_critic/reporter 3.py:1:0: C0103: Module name "reporter 3" doesn't conform to snake_case naming style (invalid-name)
agent_s3/tools/test_critic/reporter 3.py:43:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/reporter 3.py:44:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter 3.py:68:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter 3.py:143:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter 3.py:16:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/test_critic/reporter 3.py:12:0: W0611: Unused List imported from typing (unused-import)
agent_s3/tools/test_critic/reporter 3.py:12:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.test_critic.reporter
agent_s3/tools/test_critic/reporter.py:43:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/reporter.py:44:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter.py:68:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter.py:143:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/reporter.py:16:0: R0903: Too few public methods (1/2) (too-few-public-methods)
agent_s3/tools/test_critic/reporter.py:12:0: W0611: Unused List imported from typing (unused-import)
agent_s3/tools/test_critic/reporter.py:12:0: W0611: Unused Optional imported from typing (unused-import)
************* Module agent_s3.tools.test_critic.core
agent_s3/tools/test_critic/core.py:550:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/test_critic/core.py:551:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/test_critic/core.py:552:0: W0311: Bad indentation. Found 21 spaces, expected 20 (bad-indentation)
agent_s3/tools/test_critic/core.py:575:0: W0311: Bad indentation. Found 21 spaces, expected 20 (bad-indentation)
agent_s3/tools/test_critic/core.py:587:0: W0311: Bad indentation. Found 25 spaces, expected 24 (bad-indentation)
agent_s3/tools/test_critic/core.py:645:0: W0311: Bad indentation. Found 29 spaces, expected 28 (bad-indentation)
agent_s3/tools/test_critic/core.py:665:0: W0311: Bad indentation. Found 21 spaces, expected 20 (bad-indentation)
agent_s3/tools/test_critic/core.py:754:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/test_critic/core.py:888:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/test_critic/core.py:902:0: W0311: Bad indentation. Found 21 spaces, expected 20 (bad-indentation)
agent_s3/tools/test_critic/core.py:1053:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/test_critic/core.py:1054:0: W0311: Bad indentation. Found 13 spaces, expected 12 (bad-indentation)
agent_s3/tools/test_critic/core.py:1111:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/test_critic/core.py:1241:0: W0311: Bad indentation. Found 17 spaces, expected 16 (bad-indentation)
agent_s3/tools/test_critic/core.py:1:0: C0302: Too many lines in module (1270/1000) (too-many-lines)
agent_s3/tools/test_critic/core.py:1270:0: C0305: Trailing newlines (trailing-newlines)
agent_s3/tools/test_critic/core.py:33:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_critic/core.py:46:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_critic/core.py:59:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_critic/core.py:72:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_critic/core.py:85:8: W0107: Unnecessary pass statement (unnecessary-pass)
agent_s3/tools/test_critic/core.py:124:4: C0415: Import outside toplevel (adapters.python_pytest.PythonPytestAdapter) (import-outside-toplevel)
agent_s3/tools/test_critic/core.py:125:4: C0415: Import outside toplevel (adapters.js_jest.JsJestAdapter) (import-outside-toplevel)
agent_s3/tools/test_critic/core.py:126:4: C0415: Import outside toplevel (adapters.php_pest.PhpPestAdapter) (import-outside-toplevel)
agent_s3/tools/test_critic/core.py:150:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:154:4: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_critic/core.py:200:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/core.py:201:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:356:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/core.py:357:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:373:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/core.py:374:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:405:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/core.py:388:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:399:12: C0415: Import outside toplevel (reporter.Reporter) (import-outside-toplevel)
agent_s3/tools/test_critic/core.py:406:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:509:4: R0914: Too many local variables (41/15) (too-many-locals)
agent_s3/tools/test_critic/core.py:561:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:593:8: R1702: Too many nested blocks (8/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/core.py:619:37: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/test_critic/core.py:612:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/core.py:630:53: C0321: More than one statement on a single line (multiple-statements)
agent_s3/tools/test_critic/core.py:639:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/core.py:661:8: R1702: Too many nested blocks (7/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/core.py:509:4: R0912: Too many branches (50/12) (too-many-branches)
agent_s3/tools/test_critic/core.py:509:4: R0915: Too many statements (102/50) (too-many-statements)
agent_s3/tools/test_critic/core.py:814:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:848:4: R0914: Too many local variables (19/15) (too-many-locals)
agent_s3/tools/test_critic/core.py:902:21: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:848:4: R0912: Too many branches (18/12) (too-many-branches)
agent_s3/tools/test_critic/core.py:1011:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:1045:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/tools/test_critic/core.py:1267:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/core.py:1264:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:1268:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/core.py:13:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/tools/test_critic/core.py:14:0: W0611: Unused Enum imported from enum (unused-import)
agent_s3/tools/test_critic/core.py:14:0: W0611: Unused auto imported from enum (unused-import)
************* Module agent_s3.tools.test_critic.adapters.js_jest
agent_s3/tools/test_critic/adapters/js_jest.py:56:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/js_jest.py:57:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:60:11: R1729: Use a generator instead 'any((workspace / filename).exists() for filename in ['jest.config.js', 'jest.config.ts', 'jest.config.json'])' (use-a-generator)
agent_s3/tools/test_critic/adapters/js_jest.py:74:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:112:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/js_jest.py:96:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:113:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:142:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/js_jest.py:137:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:143:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:150:4: R0914: Too many local variables (16/15) (too-many-locals)
agent_s3/tools/test_critic/adapters/js_jest.py:216:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/js_jest.py:167:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:172:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_critic/adapters/js_jest.py:186:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_critic/adapters/js_jest.py:205:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:217:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:224:4: R0914: Too many local variables (23/15) (too-many-locals)
agent_s3/tools/test_critic/adapters/js_jest.py:302:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/js_jest.py:255:32: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:279:29: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/js_jest.py:286:25: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_critic/adapters/js_jest.py:303:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/js_jest.py:224:4: R0912: Too many branches (14/12) (too-many-branches)
************* Module agent_s3.tools.test_critic.adapters.python_pytest
agent_s3/tools/test_critic/adapters/python_pytest.py:36:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:57:11: R1729: Use a generator instead 'any((workspace / filename).exists() for filename in ['pytest.ini', 'conftest.py', 'tox.ini', 'pyproject.toml'])' (use-a-generator)
agent_s3/tools/test_critic/adapters/python_pytest.py:66:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:77:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/python_pytest.py:75:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:31:4: R0911: Too many return statements (8/6) (too-many-return-statements)
agent_s3/tools/test_critic/adapters/python_pytest.py:45:23: W0612: Unused variable 'minor' (unused-variable)
agent_s3/tools/test_critic/adapters/python_pytest.py:118:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/python_pytest.py:105:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:119:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:150:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/python_pytest.py:142:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:151:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:206:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/python_pytest.py:184:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:188:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:192:21: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/tools/test_critic/adapters/python_pytest.py:198:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:207:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:214:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/test_critic/adapters/python_pytest.py:299:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/python_pytest.py:227:27: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:258:12: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:261:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/python_pytest.py:278:20: R1731: Consider using 'best_score = max(best_score, score)' instead of unnecessary if block (consider-using-max-builtin)
agent_s3/tools/test_critic/adapters/python_pytest.py:284:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:293:12: W0101: Unreachable code (unreachable)
agent_s3/tools/test_critic/adapters/python_pytest.py:300:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/python_pytest.py:214:4: R0912: Too many branches (16/12) (too-many-branches)
************* Module agent_s3.tools.test_critic.adapters.php_pest
agent_s3/tools/test_critic/adapters/php_pest.py:64:19: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:56:20: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_critic/adapters/php_pest.py:65:16: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:68:11: R1729: Use a generator instead 'any((workspace / filename).exists() for filename in ['phpunit.xml', 'phpunit.xml.dist', 'pest.php'])' (use-a-generator)
agent_s3/tools/test_critic/adapters/php_pest.py:97:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:89:24: R1705: Unnecessary "elif" after "return", remove the leading "el" from "elif" (no-else-return)
agent_s3/tools/test_critic/adapters/php_pest.py:90:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:94:28: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:102:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:32:4: R0911: Too many return statements (7/6) (too-many-return-statements)
agent_s3/tools/test_critic/adapters/php_pest.py:32:4: R0912: Too many branches (13/12) (too-many-branches)
agent_s3/tools/test_critic/adapters/php_pest.py:146:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:130:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/php_pest.py:147:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:181:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:176:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/php_pest.py:182:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:249:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:211:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/php_pest.py:237:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:199:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/adapters/php_pest.py:238:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:199:8: R1702: Too many nested blocks (6/5) (too-many-nested-blocks)
agent_s3/tools/test_critic/adapters/php_pest.py:250:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/tools/test_critic/adapters/php_pest.py:189:4: R0912: Too many branches (14/12) (too-many-branches)
agent_s3/tools/test_critic/adapters/php_pest.py:257:4: R0914: Too many local variables (17/15) (too-many-locals)
agent_s3/tools/test_critic/adapters/php_pest.py:316:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/tools/test_critic/adapters/php_pest.py:299:21: W1510: 'subprocess.run' used without explicitly defining the value for 'check'. (subprocess-run-check)
agent_s3/tools/test_critic/adapters/php_pest.py:317:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
************* Module agent_s3.workflows.planning_workflow
agent_s3/workflows/planning_workflow.py:14:15: W0212: Access to a protected member _planning_workflow of a client class (protected-access)
agent_s3/workflows/planning_workflow.py:6:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module agent_s3.workflows.implementation_workflow
agent_s3/workflows/implementation_workflow.py:14:15: W0212: Access to a protected member _implementation_workflow of a client class (protected-access)
agent_s3/workflows/implementation_workflow.py:6:0: R0903: Too few public methods (1/2) (too-few-public-methods)
************* Module agent_s3.communication.vscode_bridge
agent_s3/communication/vscode_bridge.py:14:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/communication/vscode_bridge.py:14:4: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/communication/vscode_bridge.py:16:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/communication/vscode_bridge.py:17:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/communication/vscode_bridge.py:19:8: C0116: Missing function or method docstring (missing-function-docstring)
agent_s3/communication/vscode_bridge.py:21:4: C0115: Missing class docstring (missing-class-docstring)
agent_s3/communication/vscode_bridge.py:21:4: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/communication/vscode_bridge.py:44:8: C0415: Import outside toplevel (websockets) (import-outside-toplevel)
agent_s3/communication/vscode_bridge.py:48:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:59:23: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/communication/vscode_bridge.py:60:20: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:78:27: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/communication/vscode_bridge.py:74:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:77:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:79:24: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:47:37: W0613: Unused argument 'path' (unused-argument)
agent_s3/communication/vscode_bridge.py:112:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:133:15: W0718: Catching too general exception Exception (broad-exception-caught)
agent_s3/communication/vscode_bridge.py:134:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:152:12: C0415: Import outside toplevel (secrets) (import-outside-toplevel)
agent_s3/communication/vscode_bridge.py:170:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:184:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:207:17: W1514: Using open without explicitly specifying an encoding (unspecified-encoding)
agent_s3/communication/vscode_bridge.py:212:16: C0415: Import outside toplevel (stat) (import-outside-toplevel)
agent_s3/communication/vscode_bridge.py:216:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:220:12: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:235:8: W1203: Use lazy % formatting in logging functions (logging-fstring-interpolation)
agent_s3/communication/vscode_bridge.py:137:0: R0903: Too few public methods (0/2) (too-few-public-methods)
agent_s3/communication/vscode_bridge.py:8:0: W0611: Unused List imported from typing (unused-import)
agent_s3/communication/vscode_bridge.py:8:0: W0611: Unused Set imported from typing (unused-import)
agent_s3/communication/vscode_bridge.py:8:0: W0611: Unused Tuple imported from typing (unused-import)
agent_s3/communication/vscode_bridge.py:8:0: W0611: Unused Union imported from typing (unused-import)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.system_design_validator 3:[14:1195]
==agent_s3.tools.system_design_validator:[14:1195]
logger = logging.getLogger(__name__)


class SystemDesignValidationError(Exception):
    """Exception raised when validation of system designs fails."""
    pass


def validate_system_design(
    system_design: Dict[str, Any],
    requirements: Dict[str, Any]
) -> Tuple[Dict[str, Any], List[Dict[str, Any]], bool]:
    """
    Validate system design against requirements.

    Args:
        system_design: The system design to validate
        requirements: The requirements data

    Returns:
        Tuple of (validated_design, validation_issues, needs_repair)
    """
    validation_issues = []
    needs_repair = False

    # Create a deep copy of system design for potential repairs
    validated_design = json.loads(json.dumps(system_design))

    # Validate overall structure
    if not isinstance(system_design, dict):
        validation_issues.append({
            "issue_type": "structure",
            "severity": "critical",
            "description": "System design must be a dictionary"
        })
        needs_repair = True
        return validated_design, validation_issues, needs_repair

    # Check for basic sections
    required_sections = ["overview", "code_elements", "data_flow"]
    for section in required_sections:
        if section not in system_design:
            validation_issues.append({
                "issue_type": "missing_section",
                "severity": "critical",
                "description": f"System design is missing required section: {section}",
                "section": section
            })
            needs_repair = True

    # Validate code elements
    code_elements_issues = _validate_code_elements(system_design)
    validation_issues.extend(code_elements_issues)
    if any(issue["severity"] in ["critical", "high"] for issue in code_elements_issues):
        needs_repair = True

    # Validate design against requirements
    requirements_issues = _validate_design_requirements_alignment(system_design, requirements)
    validation_issues.extend(requirements_issues)
    if any(issue["severity"] in ["critical", "high"] for issue in requirements_issues):
        needs_repair = True

    # Validate architectural patterns
    pattern_issues = _validate_design_patterns(system_design)
    validation_issues.extend(pattern_issues)
    if any(issue["severity"] in ["critical", "high"] for issue in pattern_issues):
        needs_repair = True

    # Validate component relationships
    relationship_issues = _validate_component_relationships(system_design)
    validation_issues.extend(relationship_issues)
    if any(issue["severity"] in ["critical", "high"] for issue in relationship_issues):
        needs_repair = True

    # Calculate design quality metrics
    metrics = _calculate_design_metrics(system_design, requirements)

    # Check if quality is below threshold
    if metrics["overall_score"] < 0.7:
        validation_issues.append({
            "issue_type": "low_design_quality",
            "severity": "high",
            "description": f"Overall design quality score ({metrics['overall_score']:.2f}) is below threshold (0.7)",
            "metrics": metrics
        })
        needs_repair = True

    return validated_design, validation_issues, needs_repair


def repair_system_design(
    system_design: Dict[str, Any],
    validation_issues: List[Dict[str, Any]],
    requirements: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Attempt to repair system design based on validation issues.

    Args:
        system_design: The system design to repair
        validation_issues: List of validation issues to address
        requirements: The requirements data

    Returns:
        Repaired system design
    """
    # Create a deep copy for repairs
    repaired_design = json.loads(json.dumps(system_design))

    # Ensure the basic structure exists
    if not isinstance(repaired_design, dict):
        repaired_design = {}

    # Group issues by type for targeted repairs
    issues_by_type = defaultdict(list)
    for issue in validation_issues:
        issues_by_type[issue.get("issue_type", "")].append(issue)

    # Fix structural issues first
    if "structure" in issues_by_type or any(t.startswith("missing_section") for t in issues_by_type):
        repaired_design = _repair_structure(repaired_design)

    # Fix code elements issues
    code_element_issue_types = [
        "missing_element_id",
        "duplicate_element_id",
        "invalid_element_signature",
        "missing_element_description"
    ]

    if any(t in issues_by_type for t in code_element_issue_types):
        repaired_design = _repair_code_elements(repaired_design, issues_by_type)

    # Fix requirements alignment issues
    if "missing_requirement_coverage" in issues_by_type:
        repaired_design = _repair_requirements_alignment(
            repaired_design,
            issues_by_type["missing_requirement_coverage"],
            requirements
        )

    # Fix component relationship issues
    relationship_issue_types = [
        "circular_dependency",
        "excessive_coupling",
        "missing_relationship"
    ]

    if any(t in issues_by_type for t in relationship_issue_types):
        relationship_issues = []
        for issue_type in relationship_issue_types:
            if issue_type in issues_by_type:
                relationship_issues.extend(issues_by_type[issue_type])

        repaired_design = _repair_component_relationships(repaired_design, relationship_issues)

    # Fix architectural pattern issues
    if "inconsistent_pattern" in issues_by_type:
        repaired_design = _repair_architectural_patterns(
            repaired_design,
            issues_by_type["inconsistent_pattern"]
        )

    return repaired_design


def _validate_code_elements(system_design: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Validate code elements in the system design."""
    issues = []

    if "code_elements" not in system_design:
        return issues  # Already handled by missing_section check

    code_elements = system_design.get("code_elements", [])
    if not isinstance(code_elements, list):
        issues.append({
            "issue_type": "invalid_code_elements_format",
            "severity": "critical",
            "description": f"code_elements must be a list, got {type(code_elements)}"
        })
        return issues

    # Check for required fields and uniqueness of element_ids
    element_ids = set()
    for idx, element in enumerate(code_elements):
        if not isinstance(element, dict):
            issues.append({
                "issue_type": "invalid_element_format",
                "severity": "critical",
                "description": f"Code element at index {idx} must be a dictionary",
                "index": idx
            })
            continue

        # Check required fields
        for field in ["element_id", "signature", "description"]:
            if field not in element:
                issues.append({
                    "issue_type": f"missing_element_{field}",
                    "severity": "high",
                    "description": f"Code element at index {idx} is missing required field: {field}",
                    "index": idx
                })

        # Check element_id uniqueness
        element_id = element.get("element_id")
        if element_id:
            if element_id in element_ids:
                issues.append({
                    "issue_type": "duplicate_element_id",
                    "severity": "critical",
                    "description": f"Duplicate element_id found: {element_id}",
                    "element_id": element_id
                })
            else:
                element_ids.add(element_id)

        # Check signature format
        signature = element.get("signature", "")
        if signature and not _is_valid_signature(signature):
            issues.append({
                "issue_type": "invalid_element_signature",
                "severity": "high",
                "description": f"Invalid signature format for element {element_id}: {signature}",
                "element_id": element_id,
                "signature": signature
            })

    return issues


def _is_valid_signature(signature: str) -> bool:
    """Check if a signature has a valid format."""
    # Function signature patterns
    function_patterns = [
        r'def\s+\w+\s*\([^)]*\)\s*(?:->.*)?:',  # Python function
        r'function\s+\w+\s*\([^)]*\)\s*{',       # JavaScript function
        r'async\s+function\s+\w+\s*\([^)]*\)',   # Async JS function
        r'const\s+\w+\s*=\s*(?:async\s*)?\([^)]*\)\s*=>',  # Arrow function
        r'public\s+(?:static\s+)?(?:\w+\s+)+\w+\s*\([^)]*\)',  # Java/C# method
        r'class\s+\w+',                          # Class definition
        r'interface\s+\w+',                      # Interface definition
        r'\w+\([^)]*\)\s*{\s*',                  # C-style function
        r'@\w+(?:\([^)]*\))?\s*\n\s*def',        # Python decorated function
    ]

    for pattern in function_patterns:
        if re.search(pattern, signature):
            return True

    return False


def _validate_design_requirements_alignment(
    system_design: Dict[str, Any],
    requirements: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """Check if system design satisfies all requirements."""
    issues = []

    # Extract requirements
    requirement_ids = _extract_requirement_ids(requirements)

    # Extract requirement coverage from the system design
    covered_requirements = set()

    # Check code elements for requirement coverage
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict):
            # Check if there's an explicit requirements_addressed field
            if "requirements_addressed" in element:
                addressed = element.get("requirements_addressed", [])
                if isinstance(addressed, list):
                    covered_requirements.update(addressed)

            # Check descriptions for requirement mentions
            description = element.get("description", "")
            if description:
                for req_id in requirement_ids:
                    if req_id in description:
                        covered_requirements.add(req_id)

    # Check overview for requirement coverage
    overview = system_design.get("overview", "")
    if isinstance(overview, str):
        for req_id in requirement_ids:
            if req_id in overview:
                covered_requirements.add(req_id)

    # Identify requirements that aren't covered
    missing_requirements = requirement_ids - covered_requirements
    if missing_requirements:
        issues.append({
            "issue_type": "missing_requirement_coverage",
            "severity": "high",
            "description": f"System design does not address these requirements: {', '.join(missing_requirements)}",
            "missing_requirements": list(missing_requirements)
        })

    # Calculate coverage percentage
    if requirement_ids:
        coverage = len(covered_requirements) / len(requirement_ids)
        if coverage < 0.9:  # 90% coverage threshold
            issues.append({
                "issue_type": "low_requirements_coverage",
                "severity": "medium",
                "description": f"Requirements coverage is only {coverage:.1%}, below the 90% threshold",
                "coverage": coverage,
                "covered_count": len(covered_requirements),
                "total_count": len(requirement_ids)
            })

    return issues


def _extract_requirement_ids(requirements: Dict[str, Any]) -> Set[str]:
    """Extract requirement IDs from the requirements data."""
    requirement_ids = set()

    # This extraction logic will depend on the structure of your requirements
    # Here's a generic implementation that assumes requirements are in a list
    if "functional_requirements" in requirements:
        for req in requirements["functional_requirements"]:
            if isinstance(req, dict) and "id" in req:
                requirement_ids.add(req["id"])

    if "non_functional_requirements" in requirements:
        for req in requirements["non_functional_requirements"]:
            if isinstance(req, dict) and "id" in req:
                requirement_ids.add(req["id"])

    return requirement_ids


def _validate_design_patterns(system_design: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Ensure appropriate architectural patterns are used."""
    issues = []

    # Extract patterns used in the design
    patterns = _extract_patterns(system_design)

    # Check for pattern consistency
    if len(patterns) > 3:  # Too many patterns might indicate inconsistency
        issues.append({
            "issue_type": "too_many_patterns",
            "severity": "medium",
            "description": f"Design uses too many architectural patterns ({len(patterns)}), which may lead to inconsistency",
            "patterns": list(patterns)
        })

    # Check if patterns are appropriate for the domain
    # This would require domain-specific knowledge, so here's a simplified check
    domain_type = _infer_domain_type(system_design)
    inappropriate_patterns = _check_pattern_domain_fit(patterns, domain_type)

    if inappropriate_patterns:
        issues.append({
            "issue_type": "inappropriate_patterns",
            "severity": "medium",
            "description": f"Some patterns may not be appropriate for {domain_type} domain: {', '.join(inappropriate_patterns)}",
            "domain_type": domain_type,
            "inappropriate_patterns": inappropriate_patterns
        })

    return issues


def _extract_patterns(system_design: Dict[str, Any]) -> Set[str]:
    """Extract architectural patterns from the system design."""
    patterns = set()

    # Common pattern keywords to look for
    pattern_keywords = {
        "mvc": "Model-View-Controller",
        "mvvm": "Model-View-ViewModel",
        "repository": "Repository Pattern",
        "factory": "Factory Pattern",
        "singleton": "Singleton Pattern",
        "observer": "Observer Pattern",
        "strategy": "Strategy Pattern",
        "adapter": "Adapter Pattern",
        "facade": "Facade Pattern",
        "decorator": "Decorator Pattern",
        "command": "Command Pattern",
        "mediator": "Mediator Pattern",
        "microservice": "Microservice Architecture",
        "layered": "Layered Architecture",
        "event-driven": "Event-Driven Architecture",
        "serverless": "Serverless Architecture",
        "cqrs": "Command Query Responsibility Segregation",
        "ddd": "Domain-Driven Design",
        "clean architecture": "Clean Architecture",
        "hexagonal": "Hexagonal Architecture"
    }

    # Search for pattern mentions in overview
    overview = system_design.get("overview", "").lower()
    for keyword, pattern_name in pattern_keywords.items():
        if keyword in overview:
            patterns.add(pattern_name)

    # Check code elements for pattern indicators
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict):
            description = element.get("description", "").lower()
            signature = element.get("signature", "").lower()

            for keyword, pattern_name in pattern_keywords.items():
                if keyword in description or keyword in signature:
                    patterns.add(pattern_name)

    # Check file structure for pattern indicators
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict) and "target_file" in element:
            file_path = element.get("target_file", "").lower()

            if "/controllers/" in file_path:
                patterns.add("Model-View-Controller")
            elif "/repositories/" in file_path:
                patterns.add("Repository Pattern")
            elif "/factories/" in file_path:
                patterns.add("Factory Pattern")
            elif "/services/" in file_path or "/providers/" in file_path:
                patterns.add("Service Pattern")
            elif "/adapters/" in file_path:
                patterns.add("Adapter Pattern")
            elif "/decorators/" in file_path:
                patterns.add("Decorator Pattern")
            elif "/commands/" in file_path:
                patterns.add("Command Pattern")
            elif "/observers/" in file_path:
                patterns.add("Observer Pattern")

    return patterns


def _infer_domain_type(system_design: Dict[str, Any]) -> str:
    """Infer the domain type from the system design."""
    # This is a simplified inference - real implementation would be more sophisticated
    overview = system_design.get("overview", "").lower()

    domain_indicators = {
        "web application": ["web", "browser", "http", "html", "css", "frontend"],
        "api service": ["api", "rest", "graphql", "endpoint", "microservice"],
        "data processing": ["data", "processing", "etl", "pipeline", "analytics"],
        "mobile application": ["mobile", "android", "ios", "app"],
        "desktop application": ["desktop", "gui", "electron"],
        "embedded system": ["embedded", "iot", "device", "hardware"],
        "ml system": ["machine learning", "ml", "model", "training", "inference"]
    }

    scores = defaultdict(int)

    for domain, indicators in domain_indicators.items():
        for indicator in indicators:
            if indicator in overview:
                scores[domain] += 1

        # Check code elements for domain indicators
        for element in system_design.get("code_elements", []):
            if not isinstance(element, dict):
                continue

            description = element.get("description", "").lower()
            signature = element.get("signature", "").lower()

            for indicator in indicators:
                if indicator in description or indicator in signature:
                    scores[domain] += 0.5

    if not scores:
        return "general"

    return max(scores, key=scores.get)


def _check_pattern_domain_fit(patterns: Set[str], domain_type: str) -> List[str]:
    """Check if the patterns are appropriate for the given domain type."""
    inappropriate_patterns = []

    # Simplified check - real implementation would have more nuanced rules
    domain_pattern_mismatches = {
        "web application": ["Command Pattern", "Adapter Pattern"],  # These are not necessarily bad, just examples
        "api service": ["Model-View-Controller", "Model-View-ViewModel"],
        "data processing": ["Model-View-Controller", "Model-View-ViewModel"],
        "mobile application": ["Microservice Architecture"],
        "embedded system": ["Microservice Architecture", "Serverless Architecture"],
    }

    if domain_type in domain_pattern_mismatches:
        for pattern in patterns:
            if pattern in domain_pattern_mismatches[domain_type]:
                inappropriate_patterns.append(pattern)

    return inappropriate_patterns


def _validate_component_relationships(system_design: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Verify relationships between components are appropriate."""
    issues = []

    # Extract component relationships
    components, dependencies = _extract_component_dependencies(system_design)

    # Check for circular dependencies
    circular_deps = _find_circular_dependencies(components, dependencies)
    for cycle in circular_deps:
        issues.append({
            "issue_type": "circular_dependency",
            "severity": "high",
            "description": f"Circular dependency detected: {' -> '.join(cycle)}",
            "components": cycle
        })

    # Check for excessive coupling
    coupling_scores = _calculate_coupling_scores(components, dependencies)
    for component, score in coupling_scores.items():
        if score > 0.7:  # Threshold for excessive coupling
            coupled_with = [other for other in components if other != component and
                           (dependencies.get((component, other)) or dependencies.get((other, component)))]

            issues.append({
                "issue_type": "excessive_coupling",
                "severity": "medium",
                "description": f"Component {component} has excessive coupling (score: {score:.2f})",
                "component": component,
                "coupling_score": score,
                "coupled_with": coupled_with
            })

    # Check for proper layering (e.g., controllers shouldn't depend on data access)
    layering_issues = _check_proper_layering(components, dependencies)
    issues.extend(layering_issues)

    return issues


def _extract_component_dependencies(system_design: Dict[str, Any]) -> Tuple[List[str], Dict[Tuple[str, str], int]]:
    """Extract component dependencies from the system design."""
    components = []
    dependencies = {}  # (from_component, to_component) -> strength

    # Extract component names from code elements
    element_id_to_component = {}
    for element in system_design.get("code_elements", []):
        if not isinstance(element, dict) or "element_id" not in element:
            continue

        element_id = element["element_id"]

        # Infer component from file path or element type
        component = None
        if "target_file" in element:
            file_path = element["target_file"]
            parts = file_path.split("/")
            if len(parts) > 1:
                component = parts[-2]  # Use parent directory as component name

        if not component and "signature" in element:
            signature = element["signature"]
            if "class" in signature.lower():
                match = re.search(r'class\s+(\w+)', signature)
                if match:
                    component = match.group(1)

        if not component:
            component = element_id  # Use element_id as fallback

        if component not in components:
            components.append(component)

        element_id_to_component[element_id] = component

    # Extract dependencies from data_flow
    for flow in system_design.get("data_flow", []):
        if not isinstance(flow, dict):
            continue

        from_element = flow.get("from")
        to_element = flow.get("to")

        if from_element in element_id_to_component and to_element in element_id_to_component:
            from_component = element_id_to_component[from_element]
            to_component = element_id_to_component[to_element]

            if from_component != to_component:  # Ignore self-dependencies
                key = (from_component, to_component)
                dependencies[key] = dependencies.get(key, 0) + 1

    return components, dependencies


def _find_circular_dependencies(
    components: List[str],
    dependencies: Dict[Tuple[str, str], int]
) -> List[List[str]]:
    """Find circular dependencies in the component graph."""
    # Build adjacency list
    graph = defaultdict(list)
    for (from_comp, to_comp), _ in dependencies.items():
        graph[from_comp].append(to_comp)

    # Find cycles using DFS
    cycles = []

    def find_cycles_dfs(node, path, visited):
        if node in path:
            # Found a cycle
            cycle_start = path.index(node)
            cycle = path[cycle_start:] + [node]
            if cycle not in cycles:
                cycles.append(cycle)
            return

        if node in visited:
            return

        visited.add(node)
        path.append(node)

        for neighbor in graph.get(node, []):
            find_cycles_dfs(neighbor, path, visited)

        path.pop()

    for component in components:
        find_cycles_dfs(component, [], set())

    return cycles


def _calculate_coupling_scores(
    components: List[str],
    dependencies: Dict[Tuple[str, str], int]
) -> Dict[str, float]:
    """Calculate coupling scores for each component."""
    scores = {}

    if not components:
        return scores

    max_possible_deps = len(components) - 1  # Maximum possible dependencies
    if max_possible_deps == 0:
        return {comp: 0 for comp in components}

    # Count outgoing and incoming dependencies
    outgoing = defaultdict(int)
    incoming = defaultdict(int)

    for (from_comp, to_comp), strength in dependencies.items():
        outgoing[from_comp] += 1
        incoming[to_comp] += 1

    # Calculate coupling score as (outgoing + incoming) / max_possible
    for component in components:
        total_deps = outgoing[component] + incoming[component]
        scores[component] = total_deps / (2 * max_possible_deps)  # Normalize to 0-1

    return scores


def _check_proper_layering(
    components: List[str],
    dependencies: Dict[Tuple[str, str], int]
) -> List[Dict[str, Any]]:
    """Check for proper layering in the architecture."""
    issues = []

    # Define layering rules
    layer_rules = [
        # format: (higher_layer_pattern, lower_layer_pattern, allowed_direction)
        # allowed_direction: True means higher->lower is allowed, False means lower->higher is allowed
        (r'controller|api|rest|endpoint', r'service|business|domain', True),
        (r'service|business|domain', r'repository|dao|data', True),
        (r'repository|dao|data', r'controller|api|rest|endpoint', False),
    ]

    # Check each dependency against layering rules
    for (from_comp, to_comp), _ in dependencies.items():
        from_comp_lower = from_comp.lower()
        to_comp_lower = to_comp.lower()

        for higher_pattern, lower_pattern, higher_to_lower in layer_rules:
            is_from_higher = re.search(higher_pattern, from_comp_lower) is not None
            is_to_higher = re.search(higher_pattern, to_comp_lower) is not None
            is_from_lower = re.search(lower_pattern, from_comp_lower) is not None
            is_to_lower = re.search(lower_pattern, to_comp_lower) is not None

            if is_from_higher and is_to_lower:
                # Higher layer depends on lower layer - this is fine if higher_to_lower is True
                if not higher_to_lower:
                    issues.append({
                        "issue_type": "improper_layering",
                        "severity": "medium",
                        "description": f"Improper dependency: {from_comp} (higher layer) -> {to_comp} (lower layer)",
                        "from_component": from_comp,
                        "to_component": to_comp,
                        "violated_rule": f"{higher_pattern} should not depend on {lower_pattern}"
                    })
            elif is_from_lower and is_to_higher:
                # Lower layer depends on higher layer - this is fine if higher_to_lower is False
                if higher_to_lower:
                    issues.append({
                        "issue_type": "improper_layering",
                        "severity": "medium",
                        "description": f"Improper dependency: {from_comp} (lower layer) -> {to_comp} (higher layer)",
                        "from_component": from_comp,
                        "to_component": to_comp,
                        "violated_rule": f"{lower_pattern} should not depend on {higher_pattern}"
                    })

    return issues


def _calculate_design_metrics(
    system_design: Dict[str, Any],
    requirements: Dict[str, Any]
) -> Dict[str, float]:
    """
    Calculate quality metrics for the system design.

    Metrics include:
    - requirements_coverage_score: Percentage of requirements covered by design elements
    - design_cohesion_score: Measure of related functionality grouping
    - design_coupling_score: Measure of appropriate coupling between components
    - overall_score: Combined weighted score of all metrics

    Args:
        system_design: The system design to score
        requirements: The requirements data

    Returns:
        Dictionary of metric scores (0.0 to 1.0)
    """
    metrics = {}

    # Calculate requirements coverage
    requirement_ids = _extract_requirement_ids(requirements)
    covered_requirements = set()

    # Check code elements for requirement coverage
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict):
            # Check explicit requirements addressed
            if "requirements_addressed" in element:
                addressed = element.get("requirements_addressed", [])
                if isinstance(addressed, list):
                    covered_requirements.update(addressed)

            # Check descriptions
            description = element.get("description", "")
            if description:
                for req_id in requirement_ids:
                    if req_id in description:
                        covered_requirements.add(req_id)

    # Calculate requirements coverage score
    if requirement_ids:
        metrics["requirements_coverage_score"] = len(covered_requirements) / len(requirement_ids)
    else:
        metrics["requirements_coverage_score"] = 1.0

    # Calculate design cohesion and coupling scores
    components, dependencies = _extract_component_dependencies(system_design)

    # Cohesion score - based on how well related functionality is grouped
    # Here we use a simplified approach - higher is better
    if components:
        # Calculate average number of dependencies within the same component
        internal_deps = 0
        total_deps = 0

        # Count internal vs. external dependencies
        for element in system_design.get("code_elements", []):
            if not isinstance(element, dict) or "element_id" not in element:
                continue

            element_id = element["element_id"]
            element_component = None

            # Find which component this element belongs to
            for comp_name in components:
                if comp_name in element_id or (
                    "target_file" in element and
                    comp_name in element["target_file"]
                ):
                    element_component = comp_name
                    break

            if not element_component:
                continue

            # Check dependencies
            for flow in system_design.get("data_flow", []):
                if not isinstance(flow, dict):
                    continue

                if flow.get("from") == element_id:
                    total_deps += 1

                    # Check if target is in the same component
                    to_element = flow.get("to")
                    to_component = None

                    for other_element in system_design.get("code_elements", []):
                        if isinstance(other_element, dict) and other_element.get("element_id") == to_element:
                            for comp_name in components:
                                if comp_name in to_element or (
                                    "target_file" in other_element and
                                    comp_name in other_element["target_file"]
                                ):
                                    to_component = comp_name
                                    break
                            break

                    if to_component == element_component:
                        internal_deps += 1

        cohesion_score = internal_deps / max(total_deps, 1)
        # Adjust score to favor higher cohesion
        metrics["design_cohesion_score"] = min(1.0, cohesion_score * 1.2)
    else:
        metrics["design_cohesion_score"] = 0.0

    # Coupling score - based on appropriate level of coupling
    coupling_scores = _calculate_coupling_scores(components, dependencies)
    if coupling_scores:
        # Ideal coupling is neither too high nor too low
        # We define ideal as around 0.3-0.4
        avg_coupling = sum(coupling_scores.values()) / len(coupling_scores)

        # Penalize deviation from ideal range
        ideal_min, ideal_max = 0.2, 0.4

        if avg_coupling < ideal_min:
            # Too little coupling might indicate disconnected components
            metrics["design_coupling_score"] = avg_coupling / ideal_min
        elif avg_coupling > ideal_max:
            # Too much coupling indicates poor separation of concerns
            excess = avg_coupling - ideal_max
            metrics["design_coupling_score"] = max(0, 1 - (excess / 0.6))
        else:
            # Within ideal range
            metrics["design_coupling_score"] = 1.0
    else:
        metrics["design_coupling_score"] = 0.0

    # Calculate overall design quality score
    weights = {
        "requirements_coverage_score": 0.5,
        "design_cohesion_score": 0.25,
        "design_coupling_score": 0.25
    }

    overall_score = sum(metrics[metric] * weight for metric, weight in weights.items())
    metrics["overall_score"] = overall_score

    return metrics


def _repair_structure(system_design: Dict[str, Any]) -> Dict[str, Any]:
    """Repair the basic structure of the system design."""
    repaired_design = system_design.copy() if isinstance(system_design, dict) else {}

    # Ensure required sections exist
    required_sections = ["overview", "code_elements", "data_flow"]
    for section in required_sections:
        if section not in repaired_design:
            if section == "overview":
                repaired_design[section] = "System design overview"
            elif section == "code_elements":
                repaired_design[section] = []
            elif section == "data_flow":
                repaired_design[section] = []

    return repaired_design


def _repair_code_elements(
    system_design: Dict[str, Any],
    issues_by_type: Dict[str, List[Dict[str, Any]]]
) -> Dict[str, Any]:
    """Repair code elements in the system design."""
    repaired_design = json.loads(json.dumps(system_design))

    # Ensure code_elements is a list
    if "code_elements" not in repaired_design or not isinstance(repaired_design["code_elements"], list):
        repaired_design["code_elements"] = []

    # Fix issues with existing elements
    if repaired_design["code_elements"]:
        # Fix missing element IDs
        if "missing_element_id" in issues_by_type:
            for issue in issues_by_type["missing_element_id"]:
                idx = issue.get("index")
                if idx is not None and idx < len(repaired_design["code_elements"]):
                    element = repaired_design["code_elements"][idx]
                    if isinstance(element, dict) and "element_id" not in element:
                        # Generate a unique element ID
                        base_id = "element"
                        if "signature" in element:
                            sig = element["signature"]
                            match = re.search(r'\b(\w+)\s*\(', sig)
                            if match:
                                base_id = match.group(1)

                        # Ensure uniqueness
                        existing_ids = {e["element_id"] for e in repaired_design["code_elements"]
                                      if isinstance(e, dict) and "element_id" in e}

                        element_id = base_id
                        counter = 1
                        while element_id in existing_ids:
                            element_id = f"{base_id}_{counter}"
                            counter += 1

                        element["element_id"] = element_id

        # Fix invalid signatures
        if "invalid_element_signature" in issues_by_type:
            for issue in issues_by_type["invalid_element_signature"]:
                element_id = issue.get("element_id")
                if element_id:
                    for element in repaired_design["code_elements"]:
                        if isinstance(element, dict) and element.get("element_id") == element_id:
                            old_sig = element.get("signature", "")

                            # Try to repair the signature
                            if "def" in old_sig and ":" not in old_sig:
                                element["signature"] = old_sig + ":"
                            elif "function" in old_sig and "{" not in old_sig:
                                element["signature"] = old_sig + " {"
                            elif "class" in old_sig and ":" not in old_sig:
                                element["signature"] = old_sig + ":"

    return repaired_design


def _repair_requirements_alignment(
    system_design: Dict[str, Any],
    issues: List[Dict[str, Any]],
    requirements: Dict[str, Any]
) -> Dict[str, Any]:
    """Repair requirements alignment issues in the system design."""
    repaired_design = json.loads(json.dumps(system_design))

    # Add missing requirement references
    for issue in issues:
        missing_reqs = issue.get("missing_requirements", [])

        if not missing_reqs:
            continue

        # Add missing requirements to the design
        for req_id in missing_reqs:
            # Find or create an appropriate code element for this requirement
            added = False

            # First try to find a related element to attach this requirement to
            for element in repaired_design.get("code_elements", []):
                if not isinstance(element, dict):
                    continue

                # Check if this element might be related to the requirement
                if _is_element_related_to_requirement(element, req_id, requirements):
                    # Add to requirements_addressed if it exists, or create it
                    if "requirements_addressed" not in element:
                        element["requirements_addressed"] = []

                    if req_id not in element["requirements_addressed"]:
                        element["requirements_addressed"].append(req_id)

                    # Also mention in description
                    if "description" in element and req_id not in element["description"]:
                        element["description"] += f" Addresses requirement {req_id}."

                    added = True
                    break

            # If no suitable element found, mention in overview
            if not added and "overview" in repaired_design:
                if req_id not in repaired_design["overview"]:
                    repaired_design["overview"] += f"\nThe design addresses requirement {req_id}."

    return repaired_design


def _is_element_related_to_requirement(
    element: Dict[str, Any],
    req_id: str,
    requirements: Dict[str, Any]
) -> bool:
    """Check if an element might be related to a given requirement."""
    # This is a simplified check - a real implementation would be more sophisticated
    # Get requirement details
    req_details = None

    if "functional_requirements" in requirements:
        for req in requirements["functional_requirements"]:
            if isinstance(req, dict) and req.get("id") == req_id:
                req_details = req
                break

    if not req_details and "non_functional_requirements" in requirements:
        for req in requirements["non_functional_requirements"]:
            if isinstance(req, dict) and req.get("id") == req_id:
                req_details = req
                break

    if not req_details:
        return False

    # Extract keywords from requirement
    req_desc = req_details.get("description", "").lower()
    req_keywords = set(re.findall(r'\b\w+\b', req_desc))

    # Extract keywords from element
    element_desc = element.get("description", "").lower()
    element_sig = element.get("signature", "").lower()
    element_text = f"{element_desc} {element_sig}"
    element_keywords = set(re.findall(r'\b\w+\b', element_text))

    # Calculate overlap
    overlap = len(req_keywords.intersection(element_keywords))

    # Check for significant keyword overlap
    return overlap >= 3 or (len(req_keywords) > 0 and overlap / len(req_keywords) > 0.2)


def _repair_component_relationships(
    system_design: Dict[str, Any],
    issues: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """Repair component relationship issues in the system design."""
    repaired_design = json.loads(json.dumps(system_design))

    # Fix circular dependencies
    circular_issues = [issue for issue in issues if issue.get("issue_type") == "circular_dependency"]

    if circular_issues:
        # Extract components and current dependencies
        components, dependencies = _extract_component_dependencies(repaired_design)

        # For each cycle, break the weakest link
        for issue in circular_issues:
            cycle = issue.get("components", [])
            if len(cycle) < 2:
                continue

            # Find the weakest link in the cycle
            weakest_link = None
            min_strength = float('inf')

            for i in range(len(cycle)):
                from_comp = cycle[i]
                to_comp = cycle[(i + 1) % len(cycle)]

                strength = dependencies.get((from_comp, to_comp), 0)
                if strength < min_strength:
                    min_strength = strength
                    weakest_link = (from_comp, to_comp)

            if not weakest_link:
                continue

            # Break the cycle by removing data flows corresponding to the weakest link
            from_comp, to_comp = weakest_link

            # Update data_flow to remove the dependency
            if "data_flow" in repaired_design and isinstance(repaired_design["data_flow"], list):
                # First identify which element IDs correspond to these components
                from_elements = []
                to_elements = []

                element_to_component = {}
                for element in repaired_design.get("code_elements", []):
                    if not isinstance(element, dict) or "element_id" not in element:
                        continue

                    element_id = element["element_id"]
                    component = None

                    if "target_file" in element:
                        file_path = element["target_file"]
                        if from_comp in file_path:
                            component = from_comp
                        elif to_comp in file_path:
                            component = to_comp

                    if not component and "signature" in element:
                        sig = element["signature"]
                        if from_comp in sig:
                            component = from_comp
                        elif to_comp in sig:
                            component = to_comp

                    if component:
                        element_to_component[element_id] = component

                # Now remove flows between these components
                repaired_design["data_flow"] = [
                    flow for flow in repaired_design["data_flow"]
                    if not (isinstance(flow, dict) and
                           flow.get("from") in element_to_component and
                           flow.get("to") in element_to_component and
                           element_to_component[flow.get("from")] == from_comp and
                           element_to_component[flow.get("to")] == to_comp)
                ]

    # Fix excessive coupling
    coupling_issues = [issue for issue in issues if issue.get("issue_type") == "excessive_coupling"]

    if coupling_issues:
        # For each coupling issue, suggest a better organization
        for issue in issues:
            component = issue.get("component")
            if not component:
                continue

            # Add a note in the system design overview about reducing coupling
            if "overview" in repaired_design and isinstance(repaired_design["overview"], str):
                note = f"\nNote: Component '{component}' has high coupling and should be refactored" + \
                       " into smaller, more focused components."
                if note not in repaired_design["overview"]:
                    repaired_design["overview"] += note

    return repaired_design


def _repair_architectural_patterns(
    system_design: Dict[str, Any],
    issues: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """Repair architectural pattern issues in the system design."""
    repaired_design = json.loads(json.dumps(system_design))

    # Add notes about architectural patterns
    if "overview" in repaired_design and isinstance(repaired_design["overview"], str):
        for issue in issues:
            if issue.get("issue_type") == "too_many_patterns":
                patterns = issue.get("patterns", [])
                if patterns:
                    # Suggest focusing on fewer patterns
                    dominant_patterns = patterns[:2]
                    note = (f"\nArchitectural pattern recommendation: Focus on a smaller set of patterns" +
                            f" such as {' and '.join(dominant_patterns)} for more consistency.")

                    if note not in repaired_design["overview"]:
                        repaired_design["overview"] += note

            elif issue.get("issue_type") == "inappropriate_patterns":
                domain = issue.get("domain_type", "")
                inappropriate = issue.get("inappropriate_patterns", [])

                if domain and inappropriate:
                    # Suggest more appropriate patterns
                    appropriate_patterns = _suggest_patterns_for_domain(domain)

                    if appropriate_patterns:
                        note = (f"\nFor {domain} domain, consider using {', '.join(appropriate_patterns)}" +
                                f" patterns instead of {', '.join(inappropriate)}.")

                        if note not in repaired_design["overview"]:
                            repaired_design["overview"] += note

    return repaired_design


def _suggest_patterns_for_domain(domain: str) -> List[str]:
    """Suggest appropriate patterns for a given domain."""
    domain_pattern_suggestions = {
        "web application": ["Model-View-Controller", "Component-Based Architecture", "Repository Pattern"],
        "api service": ["Layered Architecture", "Repository Pattern", "Dependency Injection"],
        "data processing": ["Pipeline Pattern", "Repository Pattern", "Command Pattern"],
        "mobile application": ["MVVM", "Repository Pattern", "Observer Pattern"],
        "desktop application": ["MVC", "MVVM", "Observer Pattern"],
        "embedded system": ["State Pattern", "Observer Pattern", "Command Pattern"],
        "ml system": ["Pipeline Pattern", "Strategy Pattern", "Factory Pattern"],
    }

    return domain_pattern_suggestions.get(domain, ["Layered Architecture", "Repository Pattern"]) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_explainer 3:[13:947]
==agent_s3.tools.context_management.adaptive_config.config_explainer:[13:947]
logger = logging.getLogger(__name__)


class ConfigExplainer:
    """
    Provides explanations for configuration decisions and changes in the adaptive system.
    """

    def __init__(self, adaptive_config_manager=None):
        """
        Initialize the configuration explainer.

        Args:
            adaptive_config_manager: Optional reference to AdaptiveConfigManager instance
        """
        self.config_manager = adaptive_config_manager

    def explain_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate a human-readable explanation of a configuration.

        Args:
            config: Configuration dictionary to explain

        Returns:
            Dictionary with explanations of key configuration parameters
        """
        result = {
            "overview": "This is the context management configuration that optimizes how code is processed and retrieved.",
            "parameters": {},
            "performance_impact": {}
        }

        cm_config = config.get("context_management", {})

        # Explain embedding parameters
        embedding_config = cm_config.get("embedding", {})
        chunk_size = embedding_config.get("chunk_size")
        chunk_overlap = embedding_config.get("chunk_overlap")

        if chunk_size:
            result["parameters"]["chunk_size"] = {
                "value": chunk_size,
                "explanation": f"Code is divided into chunks of approximately {chunk_size} tokens. " +
                    self._get_chunk_size_impact(chunk_size)
            }

        if chunk_overlap:
            result["parameters"]["chunk_overlap"] = {
                "value": chunk_overlap,
                "explanation": f"Chunks overlap by {chunk_overlap} tokens to maintain continuity. " +
                    self._get_chunk_overlap_impact(chunk_overlap, chunk_size)
            }

        # Explain search parameters
        search_config = cm_config.get("search", {})
        bm25_config = search_config.get("bm25", {})
        k1 = bm25_config.get("k1")
        b = bm25_config.get("b")

        if k1 is not None:
            result["parameters"]["bm25_k1"] = {
                "value": k1,
                "explanation": f"The BM25 k1 parameter is set to {k1}. " +
                    self._get_bm25_k1_impact(k1)
            }

        if b is not None:
            result["parameters"]["bm25_b"] = {
                "value": b,
                "explanation": f"The BM25 b parameter is set to {b}. " +
                    self._get_bm25_b_impact(b)
            }

        # Explain summarization parameters
        summarization_config = cm_config.get("summarization", {})
        threshold = summarization_config.get("threshold")
        compression_ratio = summarization_config.get("compression_ratio")

        if threshold:
            result["parameters"]["summary_threshold"] = {
                "value": threshold,
                "explanation": f"Summarization is triggered when context exceeds {threshold} tokens. " +
                    self._get_summary_threshold_impact(threshold)
            }

        if compression_ratio:
            result["parameters"]["compression_ratio"] = {
                "value": compression_ratio,
                "explanation": f"Content is compressed to approximately {int(compression_ratio * 100)}% of its original size. " +
                    self._get_compression_ratio_impact(compression_ratio)
            }

        # Explain importance scoring parameters
        scoring_config = cm_config.get("importance_scoring", {})
        code_weight = scoring_config.get("code_weight")
        comment_weight = scoring_config.get("comment_weight")
        metadata_weight = scoring_config.get("metadata_weight")
        framework_weight = scoring_config.get("framework_weight")

        if code_weight:
            result["parameters"]["code_weight"] = {
                "value": code_weight,
                "explanation": f"Code has a relative importance weight of {code_weight}. " +
                    self._get_weight_impact("code", code_weight)
            }

        if comment_weight:
            result["parameters"]["comment_weight"] = {
                "value": comment_weight,
                "explanation": f"Comments have a relative importance weight of {comment_weight}. " +
                    self._get_weight_impact("comments", comment_weight)
            }

        if metadata_weight:
            result["parameters"]["metadata_weight"] = {
                "value": metadata_weight,
                "explanation": f"Metadata has a relative importance weight of {metadata_weight}. " +
                    self._get_weight_impact("metadata", metadata_weight)
            }

        if framework_weight:
            result["parameters"]["framework_weight"] = {
                "value": framework_weight,
                "explanation": f"Framework code has a relative importance weight of {framework_weight}. " +
                    self._get_weight_impact("framework", framework_weight)
            }

        # Overall performance impact
        result["performance_impact"] = self._get_overall_performance_impact(config)

        return result

    def explain_config_change(
        self,
        old_config: Dict[str, Any],
        new_config: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Generate a human-readable explanation of configuration changes.

        Args:
            old_config: Previous configuration
            new_config: New configuration

        Returns:
            Dictionary with explanations of changes
        """
        result = {
            "overview": "This explains the changes made to the context management configuration.",
            "changes": [],
            "impact": {}
        }

        # Detect changes
        changes = self._detect_config_changes(old_config, new_config)

        # Generate explanations for each change
        for change in changes:
            param_path = change["path"]
            old_value = change["old_value"]
            new_value = change["new_value"]

            explanation = self._explain_parameter_change(param_path, old_value, new_value)

            result["changes"].append({
                "parameter": param_path,
                "old_value": old_value,
                "new_value": new_value,
                "explanation": explanation,
                "impact": self._get_change_impact(param_path, old_value, new_value)
            })

        # Overall impact assessment
        if len(changes) > 0:
            result["impact"] = self._assess_overall_impact(changes)
        else:
            result["impact"] = {
                "description": "No configuration changes detected.",
                "performance_effect": "neutral"
            }

        return result

    def generate_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive configuration report.

        Returns:
            Dictionary with configuration report
        """
        if not self.config_manager:
            return {"error": "No configuration manager available"}

        try:
            current_config = self.config_manager.get_current_config()
            config_history = self.config_manager.get_config_history()
            performance_summary = self.config_manager.get_performance_summary()

            # Generate explanations
            config_explanation = self.explain_config(current_config)

            # Recent changes
            recent_changes = []
            if len(config_history) > 1:
                # Only process if we have at least 2 versions
                latest_version = config_history[0].get("version")
                previous_version = config_history[1].get("version")

                if latest_version and previous_version:
                    recent_changes = {
                        "from_version": previous_version,
                        "to_version": latest_version,
                        "timestamp": config_history[0].get("timestamp"),
                        "reason": config_history[0].get("reason"),
                        "change_details": self._get_version_changes(previous_version, latest_version)
                    }

            # Assemble report
            report = {
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "current_version": self.config_manager.get_config_version(),
                "total_versions": len(config_history),
                "configuration_explanation": config_explanation,
                "recent_changes": recent_changes,
                "performance_metrics": self._summarize_performance(performance_summary),
                "recommendations": self._get_recommendations(current_config, performance_summary)
            }

            return report

        except Exception as e:
            logger.error(f"Error generating configuration report: {e}")
            return {"error": str(e)}

    def get_human_readable_report(self) -> str:
        """
        Generate a human-readable configuration report.

        Returns:
            String with formatted report
        """
        try:
            report = self.generate_report()

            if "error" in report:
                return f"Error generating report: {report['error']}"

            lines = [
                "# Context Management Configuration Report",
                f"Generated on: {report.get('timestamp')}",
                f"Configuration Version: {report.get('current_version')}",
                "",
                "## Configuration Overview",
                ""
            ]

            # Add configuration explanation
            config_explanation = report.get("configuration_explanation", {})
            lines.append(config_explanation.get("overview", ""))
            lines.append("")
            lines.append("### Key Parameters")
            lines.append("")

            for param_name, param_info in config_explanation.get("parameters", {}).items():
                lines.append(f"- **{param_name}**: {param_info.get('value')}")
                lines.append(f"  {param_info.get('explanation')}")
                lines.append("")

            # Add recent changes
            recent_changes = report.get("recent_changes")
            if recent_changes:
                lines.append("## Recent Changes")
                lines.append("")
                lines.append(f"From Version {recent_changes.get('from_version')} to {recent_changes.get('to_version')}")
                lines.append(f"Reason: {recent_changes.get('reason')}")
                lines.append("")

                for change in recent_changes.get("change_details", {}).get("changes", []):
                    lines.append(f"- Changed **{change.get('parameter')}** from {change.get('old_value')} to {change.get('new_value')}")
                    lines.append(f"  {change.get('explanation')}")
                    lines.append("")

            # Add performance metrics
            metrics = report.get("performance_metrics", {})
            lines.append("## Performance Metrics")
            lines.append("")

            for metric_name, metric_info in metrics.items():
                if isinstance(metric_info, dict):
                    lines.append(f"### {metric_name.replace('_', ' ').title()}")
                    for k, v in metric_info.items():
                        lines.append(f"- {k.replace('_', ' ').title()}: {v}")
                else:
                    lines.append(f"- {metric_name.replace('_', ' ').title()}: {metric_info}")
                lines.append("")

            # Add recommendations
            recommendations = report.get("recommendations", [])
            if recommendations:
                lines.append("## Recommendations")
                lines.append("")

                for i, rec in enumerate(recommendations, 1):
                    lines.append(f"{i}. {rec.get('recommendation')}")
                    if "rationale" in rec:
                        lines.append(f"   Rationale: {rec.get('rationale')}")
                    lines.append("")

            return "\n".join(lines)

        except Exception as e:
            logger.error(f"Error generating human-readable report: {e}")
            return f"Error generating report: {e}"

    def _detect_config_changes(
        self,
        old_config: Dict[str, Any],
        new_config: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Detect changes between two configurations.

        Args:
            old_config: Previous configuration
            new_config: New configuration

        Returns:
            List of changes
        """
        changes = []

        # Check context management section
        old_cm = old_config.get("context_management", {})
        new_cm = new_config.get("context_management", {})

        # Check embedding parameters
        old_embedding = old_cm.get("embedding", {})
        new_embedding = new_cm.get("embedding", {})

        for param in ["chunk_size", "chunk_overlap"]:
            if param in old_embedding and param in new_embedding and old_embedding[param] != new_embedding[param]:
                changes.append({
                    "path": f"context_management.embedding.{param}",
                    "old_value": old_embedding[param],
                    "new_value": new_embedding[param]
                })

        # Check search parameters
        old_search = old_cm.get("search", {}).get("bm25", {})
        new_search = new_cm.get("search", {}).get("bm25", {})

        for param in ["k1", "b"]:
            if param in old_search and param in new_search and old_search[param] != new_search[param]:
                changes.append({
                    "path": f"context_management.search.bm25.{param}",
                    "old_value": old_search[param],
                    "new_value": new_search[param]
                })

        # Check summarization parameters
        old_summarization = old_cm.get("summarization", {})
        new_summarization = new_cm.get("summarization", {})

        for param in ["threshold", "compression_ratio"]:
            if param in old_summarization and param in new_summarization and old_summarization[param] != new_summarization[param]:
                changes.append({
                    "path": f"context_management.summarization.{param}",
                    "old_value": old_summarization[param],
                    "new_value": new_summarization[param]
                })

        # Check importance scoring parameters
        old_scoring = old_cm.get("importance_scoring", {})
        new_scoring = new_cm.get("importance_scoring", {})

        for param in ["code_weight", "comment_weight", "metadata_weight", "framework_weight"]:
            if param in old_scoring and param in new_scoring and old_scoring[param] != new_scoring[param]:
                changes.append({
                    "path": f"context_management.importance_scoring.{param}",
                    "old_value": old_scoring[param],
                    "new_value": new_scoring[param]
                })

        return changes

    def _explain_parameter_change(self, param_path: str, old_value: Any, new_value: Any) -> str:
        """
        Generate an explanation for a parameter change.

        Args:
            param_path: Parameter path (dot notation)
            old_value: Previous value
            new_value: New value

        Returns:
            Explanation string
        """
        # Extract parameter name from path
        param_name = param_path.split('.')[-1]

        # Calculate change percentage
        if isinstance(old_value, (int, float)) and isinstance(new_value, (int, float)) and old_value != 0:
            change_pct = ((new_value - old_value) / old_value) * 100
            direction = "increased" if new_value > old_value else "decreased"
            magnitude = abs(change_pct)

            if magnitude < 5:
                adj = "slightly"
            elif magnitude < 15:
                adj = "moderately"
            elif magnitude < 30:
                adj = "significantly"
            else:
                adj = "dramatically"

            change_desc = f"{adj} {direction} by {magnitude:.1f}%"
        else:
            change_desc = "changed"

        # Generate explanation based on parameter
        if "chunk_size" in param_path:
            if new_value > old_value:
                return f"Chunk size {change_desc}. Larger chunks capture more context in each embedding but may reduce precision."
            else:
                return f"Chunk size {change_desc}. Smaller chunks provide more granular context retrieval but may miss broader patterns."

        elif "chunk_overlap" in param_path:
            if new_value > old_value:
                return f"Chunk overlap {change_desc}. Greater overlap improves continuity between chunks but increases storage requirements."
            else:
                return f"Chunk overlap {change_desc}. Reduced overlap optimizes storage but may create discontinuities between chunks."

        elif "bm25.k1" in param_path:
            if new_value > old_value:
                return f"BM25 k1 parameter {change_desc}. Higher values give more weight to term frequency, improving results for repeated terms."
            else:
                return f"BM25 k1 parameter {change_desc}. Lower values reduce the impact of term frequency, which can help with keyword matching."

        elif "bm25.b" in param_path:
            if new_value > old_value:
                return f"BM25 b parameter {change_desc}. Higher values increase document length normalization, favoring shorter documents."
            else:
                return f"BM25 b parameter {change_desc}. Lower values reduce length normalization, potentially favoring longer, more detailed documents."

        elif "threshold" in param_path:
            if new_value > old_value:
                return f"Summarization threshold {change_desc}. Higher threshold means summarization happens less frequently, retaining more detail."
            else:
                return f"Summarization threshold {change_desc}. Lower threshold triggers summarization more frequently, potentially improving token efficiency."

        elif "compression_ratio" in param_path:
            if new_value > old_value:
                return f"Compression ratio {change_desc}. Higher ratio retains more content during summarization but uses more tokens."
            else:
                return f"Compression ratio {change_desc}. Lower ratio produces more concise summaries, optimizing token usage."

        elif "code_weight" in param_path:
            if new_value > old_value:
                return f"Code importance weight {change_desc}. Higher weight prioritizes actual code over other content types."
            else:
                return f"Code importance weight {change_desc}. Lower weight gives relatively more importance to non-code content."

        elif "comment_weight" in param_path:
            if new_value > old_value:
                return f"Comment importance weight {change_desc}. Higher weight prioritizes code comments for better documentation context."
            else:
                return f"Comment importance weight {change_desc}. Lower weight reduces the relative importance of comments compared to code."

        elif "metadata_weight" in param_path:
            if new_value > old_value:
                return f"Metadata importance weight {change_desc}. Higher weight prioritizes file metadata for better file relationship understanding."
            else:
                return f"Metadata importance weight {change_desc}. Lower weight reduces the relative importance of metadata in the context."

        elif "framework_weight" in param_path:
            if new_value > old_value:
                return f"Framework code importance weight {change_desc}. Higher weight prioritizes framework-related code for better API understanding."
            else:
                return f"Framework code importance weight {change_desc}. Lower weight reduces focus on framework code to prioritize application logic."

        else:
            return f"Parameter {param_name} {change_desc} from {old_value} to {new_value}."

    def _get_change_impact(self, param_path: str, old_value: Any, new_value: Any) -> Dict[str, Any]:
        """
        Assess the impact of a parameter change.

        Args:
            param_path: Parameter path (dot notation)
            old_value: Previous value
            new_value: New value

        Returns:
            Dictionary with impact assessment
        """
        result = {
            "aspect": "unknown",
            "effect": "neutral",
            "confidence": "low"
        }

        # Determine the affected aspect
        if "chunk_size" in param_path or "chunk_overlap" in param_path:
            result["aspect"] = "context_segmentation"
        elif "bm25" in param_path:
            result["aspect"] = "search_relevance"
        elif "summarization" in param_path:
            result["aspect"] = "summarization_quality"
        elif "weight" in param_path:
            result["aspect"] = "content_prioritization"

        # Determine the effect and confidence
        if "chunk_size" in param_path:
            if new_value > old_value:
                result["effect"] = "more_broad_context"
                result["confidence"] = "medium"
            else:
                result["effect"] = "more_precise_context"
                result["confidence"] = "medium"

        elif "chunk_overlap" in param_path:
            if new_value > old_value:
                result["effect"] = "improved_continuity"
                result["confidence"] = "high"
            else:
                result["effect"] = "improved_efficiency"
                result["confidence"] = "medium"

        elif "bm25.k1" in param_path:
            if new_value > old_value:
                result["effect"] = "improved_term_frequency_sensitivity"
                result["confidence"] = "medium"
            else:
                result["effect"] = "improved_rare_term_matching"
                result["confidence"] = "medium"

        elif "bm25.b" in param_path:
            if new_value > old_value:
                result["effect"] = "favors_shorter_documents"
                result["confidence"] = "medium"
            else:
                result["effect"] = "favors_longer_documents"
                result["confidence"] = "medium"

        elif "threshold" in param_path:
            if new_value > old_value:
                result["effect"] = "more_detail_retention"
                result["confidence"] = "high"
            else:
                result["effect"] = "more_token_efficiency"
                result["confidence"] = "high"

        elif "compression_ratio" in param_path:
            if new_value > old_value:
                result["effect"] = "more_detail_in_summaries"
                result["confidence"] = "high"
            else:
                result["effect"] = "more_concise_summaries"
                result["confidence"] = "high"

        elif "code_weight" in param_path:
            if new_value > old_value:
                result["effect"] = "prioritize_code"
                result["confidence"] = "medium"
            else:
                result["effect"] = "deprioritize_code"
                result["confidence"] = "medium"

        elif "comment_weight" in param_path:
            if new_value > old_value:
                result["effect"] = "prioritize_documentation"
                result["confidence"] = "medium"
            else:
                result["effect"] = "deprioritize_documentation"
                result["confidence"] = "medium"

        return result

    def _assess_overall_impact(self, changes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Assess overall impact of multiple changes.

        Args:
            changes: List of detected changes

        Returns:
            Dictionary with overall impact assessment
        """
        aspects = set()
        effects = []
        total_magnitude = 0

        for change in changes:
            param_path = change["path"]
            old_value = change["old_value"]
            new_value = change["new_value"]

            impact = self._get_change_impact(param_path, old_value, new_value)
            aspects.add(impact["aspect"])
            effects.append(impact["effect"])

            # Calculate magnitude of change
            if isinstance(old_value, (int, float)) and isinstance(new_value, (int, float)) and old_value != 0:
                magnitude = abs((new_value - old_value) / old_value)
                total_magnitude += magnitude

        # Generate overall impact description
        if len(changes) == 1:
            description = f"This change affects {list(aspects)[0]}."
        else:
            description = f"These changes affect {', '.join(aspects)}."

        # Assess performance effect
        if total_magnitude < 0.1:
            performance_effect = "minor"
        elif total_magnitude < 0.3:
            performance_effect = "moderate"
        else:
            performance_effect = "significant"

        return {
            "description": description,
            "affected_aspects": list(aspects),
            "effects": effects,
            "performance_effect": performance_effect,
            "change_count": len(changes)
        }

    def _get_version_changes(self, from_version: int, to_version: int) -> Dict[str, Any]:
        """
        Get changes between two configuration versions.

        Args:
            from_version: Previous version number
            to_version: Current version number

        Returns:
            Dictionary with change information

        Note:
            Requires access to AdaptiveConfigManager
        """
        if not self.config_manager:
            return {"error": "No configuration manager available"}

        try:
            # Find configuration files
            config_files = {}
            for filename in os.listdir(self.config_manager.config_dir):
                if filename.startswith(f"config_v{from_version}_") or filename.startswith(f"config_v{to_version}_"):
                    version = int(filename.split('_')[1][1:])  # Extract version number
                    config_files[version] = os.path.join(self.config_manager.config_dir, filename)

            if from_version not in config_files or to_version not in config_files:
                return {"error": "One or both versions not found"}

            # Load configurations
            with open(config_files[from_version], 'r') as f:
                from_data = json.load(f)

            with open(config_files[to_version], 'r') as f:
                to_data = json.load(f)

            # Extract actual configs
            old_config = from_data.get("config", {})
            new_config = to_data.get("config", {})

            # Detect changes
            changes = self._detect_config_changes(old_config, new_config)

            # Generate explanations for each change
            explained_changes = []
            for change in changes:
                param_path = change["path"]
                old_value = change["old_value"]
                new_value = change["new_value"]

                explanation = self._explain_parameter_change(param_path, old_value, new_value)
                impact = self._get_change_impact(param_path, old_value, new_value)

                explained_changes.append({
                    "parameter": param_path,
                    "old_value": old_value,
                    "new_value": new_value,
                    "explanation": explanation,
                    "impact": impact
                })

            # Overall impact assessment
            overall_impact = self._assess_overall_impact(changes)

            return {
                "from_version": from_version,
                "to_version": to_version,
                "changes": explained_changes,
                "overall_impact": overall_impact
            }

        except Exception as e:
            logger.error(f"Error getting version changes: {e}")
            return {"error": str(e)}

    def _get_chunk_size_impact(self, chunk_size: int) -> str:
        """Get explanation of chunk size impact."""
        if chunk_size <= 500:
            return "This small chunk size focuses on precise context retrieval but may miss broader relationships."
        elif chunk_size <= 800:
            return "This moderate chunk size balances precision with sufficient context for most code snippets."
        elif chunk_size <= 1200:
            return "This balanced chunk size captures enough context for functions and related code blocks."
        elif chunk_size <= 1500:
            return "This larger chunk size captures broad context but may reduce precision for specific queries."
        else:
            return "This very large chunk size maximizes context but may reduce precision and increase token usage."

    def _get_chunk_overlap_impact(self, overlap: int, chunk_size: int) -> str:
        """Get explanation of chunk overlap impact."""
        if chunk_size:
            ratio = overlap / chunk_size
            if ratio <= 0.1:
                return "This minimal overlap conserves tokens but may create discontinuities between chunks."
            elif ratio <= 0.2:
                return "This moderate overlap provides decent continuity between chunks while optimizing token usage."
            elif ratio <= 0.3:
                return "This substantial overlap ensures good continuity between chunks for better context retrieval."
            else:
                return "This large overlap maximizes continuity but significantly increases storage requirements."
        return ""

    def _get_bm25_k1_impact(self, k1: float) -> str:
        """Get explanation of BM25 k1 impact."""
        if k1 <= 0.5:
            return "This low value reduces the impact of term frequency, which is good for keyword matching."
        elif k1 <= 1.0:
            return "This moderate value balances term frequency with other factors for general code search."
        elif k1 <= 1.5:
            return "This higher value gives more weight to term frequency, improving results for repeated terms."
        else:
            return "This very high value strongly emphasizes term frequency, which helps with highly repetitive patterns."

    def _get_bm25_b_impact(self, b: float) -> str:
        """Get explanation of BM25 b impact."""
        if b <= 0.5:
            return "This low value reduces document length normalization, potentially favoring longer, more detailed documents."
        elif b <= 0.7:
            return "This moderate value applies some length normalization for balanced search results."
        elif b <= 0.85:
            return "This higher value emphasizes document length normalization for more balanced comparison across different file sizes."
        else:
            return "This very high value strongly normalizes for document length, which may favor shorter, more concise documents."

    def _get_summary_threshold_impact(self, threshold: int) -> str:
        """Get explanation of summarization threshold impact."""
        if threshold <= 1000:
            return "This low threshold triggers summarization frequently, optimizing token usage but potentially reducing detail."
        elif threshold <= 2000:
            return "This moderate threshold provides a good balance between detail preservation and token optimization."
        elif threshold <= 3000:
            return "This higher threshold preserves more detail by summarizing less frequently, but may use more tokens."
        else:
            return "This very high threshold strongly prioritizes detail preservation over token optimization."

    def _get_compression_ratio_impact(self, ratio: float) -> str:
        """Get explanation of compression ratio impact."""
        if ratio <= 0.3:
            return "This aggressive compression significantly reduces token usage but may lose important details."
        elif ratio <= 0.5:
            return "This moderate compression provides a good balance between conciseness and detail preservation."
        elif ratio <= 0.7:
            return "This lighter compression preserves most details while still reducing token usage."
        else:
            return "This minimal compression preserves nearly all details but offers limited token optimization."

    def _get_weight_impact(self, content_type: str, weight: float) -> str:
        """Get explanation of importance weight impact."""
        if weight <= 0.5:
            return f"This low weight means {content_type} are considered less important relative to other content types."
        elif weight <= 0.8:
            return f"This moderate weight gives {content_type} standard importance in the context mixture."
        elif weight <= 1.2:
            return f"This balanced weight treats {content_type} with standard importance for most use cases."
        elif weight <= 1.5:
            return f"This higher weight prioritizes {content_type} over other content types when optimizing context."
        else:
            return f"This very high weight strongly favors {content_type} when making context optimization decisions."

    def _get_overall_performance_impact(self, config: Dict[str, Any]) -> Dict[str, str]:
        """Assess overall performance impact of configuration."""
        cm_config = config.get("context_management", {})

        # Extract key parameters
        chunk_size = cm_config.get("embedding", {}).get("chunk_size", 1000)
        chunk_overlap = cm_config.get("embedding", {}).get("chunk_overlap", 200)
        threshold = cm_config.get("summarization", {}).get("threshold", 2000)
        compression = cm_config.get("summarization", {}).get("compression_ratio", 0.5)

        # Assess token efficiency
        if chunk_size <= 800 and compression <= 0.4 and threshold <= 1500:
            token_efficiency = "optimized for token efficiency at the potential cost of detail"
        elif chunk_size >= 1200 and compression >= 0.6 and threshold >= 2500:
            token_efficiency = "optimized for detail preservation at the potential cost of token efficiency"
        else:
            token_efficiency = "balanced between token efficiency and detail preservation"

        # Assess context continuity
        overlap_ratio = chunk_overlap / chunk_size if chunk_size > 0 else 0
        if overlap_ratio >= 0.25:
            continuity = "optimized for strong context continuity"
        elif overlap_ratio <= 0.15:
            continuity = "optimized for storage efficiency with potential continuity gaps"
        else:
            continuity = "balanced between continuity and storage efficiency"

        # Assess search optimization
        k1 = cm_config.get("search", {}).get("bm25", {}).get("k1", 1.2)
        b = cm_config.get("search", {}).get("bm25", {}).get("b", 0.75)

        if k1 >= 1.4:
            search = "optimized for term frequency sensitivity"
        elif b >= 0.85:
            search = "optimized for document length normalization"
        elif b <= 0.6:
            search = "optimized for detailed document matching"
        else:
            search = "balanced for general code search performance"

        return {
            "token_efficiency": token_efficiency,
            "context_continuity": continuity,
            "search_optimization": search
        }

    def _summarize_performance(self, performance_summary: Dict[str, Any]) -> Dict[str, Any]:
        """Create a simplified performance summary."""
        result = {}

        # Extract key metrics
        if "token_usage" in performance_summary:
            token_usage = performance_summary["token_usage"]
            result["token_utilization"] = {
                "average": f"{token_usage.get('avg_utilization', 0) * 100:.1f}%",
                "max": f"{token_usage.get('max_utilization', 0) * 100:.1f}%"
            }

        if "search_relevance" in performance_summary:
            search = performance_summary["search_relevance"]
            result["search_relevance"] = {
                "top_result": f"{search.get('avg_top_relevance', 0) * 100:.1f}%",
                "average": f"{search.get('avg_overall_relevance', 0) * 100:.1f}%"
            }

        if "context_relevance" in performance_summary:
            context = performance_summary["context_relevance"]
            result["context_relevance"] = {
                "overall": f"{context.get('avg_relevance', 0) * 100:.1f}%"
            }

            # Add task-specific relevance
            by_task = context.get("by_task_type", {})
            if by_task:
                task_relevance = {}
                for task, score in by_task.items():
                    task_relevance[task] = f"{score * 100:.1f}%"
                result["task_relevance"] = task_relevance

        if "response_latency" in performance_summary:
            latency = performance_summary["response_latency"]
            result["response_times"] = {
                "average": f"{latency.get('avg_latency_ms', 0):.1f}ms",
                "median": f"{latency.get('median_latency_ms', 0):.1f}ms"
            }

        return result

    def _get_recommendations(
        self,
        current_config: Dict[str, Any],
        performance: Dict[str, Any]
    ) -> List[Dict[str, str]]:
        """Generate configuration recommendations based on performance metrics."""
        recommendations = []

        # Check if we have enough performance data
        if not performance or "context_relevance" not in performance:
            return [{
                "recommendation": "Collect more usage data for configuration optimization recommendations",
                "rationale": "Insufficient performance metrics available for analysis"
            }]

        # Extract key metrics
        token_usage = performance.get("token_usage", {})
        search_relevance = performance.get("search_relevance", {})
        context_relevance = performance.get("context_relevance", {})

        # Check token utilization
        avg_utilization = token_usage.get("avg_utilization", 0)
        if avg_utilization > 0.95:
            recommendations.append({
                "recommendation": "Consider increasing summarization threshold or reducing chunk size",
                "rationale": f"Current token utilization is very high ({avg_utilization:.1%})"
            })
        elif avg_utilization < 0.6:
            recommendations.append({
                "recommendation": "Consider decreasing summarization threshold or increasing chunk size",
                "rationale": f"Current token utilization is low ({avg_utilization:.1%})"
            })

        # Check search relevance
        avg_top_relevance = search_relevance.get("avg_top_relevance", 0)
        if avg_top_relevance < 0.7:
            recommendations.append({
                "recommendation": "Consider adjusting BM25 parameters to improve search relevance",
                "rationale": f"Current top search relevance is suboptimal ({avg_top_relevance:.1%})"
            })

        # Check context relevance
        avg_relevance = context_relevance.get("avg_relevance", 0)
        if avg_relevance < 0.7:
            recommendations.append({
                "recommendation": "Consider increasing chunk overlap to improve context continuity",
                "rationale": f"Current context relevance is suboptimal ({avg_relevance:.1%})"
            })

        # Check task-specific relevance
        by_task = context_relevance.get("by_task_type", {})
        for task, score in by_task.items():
            if score < 0.65:
                recommendations.append({
                    "recommendation": f"Consider adjusting importance weights for {task} tasks",
                    "rationale": f"Current relevance for {task} tasks is low ({score:.1%})"
                })

        return recommendations (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.security_validator 3:[29:789]
==agent_s3.tools.security_validator:[29:789]
logger = logging.getLogger(__name__)


class SecurityValidationError(Exception):
    """Exception raised when security validation fails."""
    pass


def _validate_implementation_security(
    implementation_plan: Dict[str, Any],
    security_concerns: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Simplified security validation that focuses on traceability rather than complex semantic validation.
    This function validates that security concerns from architecture review are explicitly referenced
    in implementation plans.

    Args:
        implementation_plan: The implementation plan to validate
        security_concerns: List of security concerns from architecture review

    Returns:
        List of validation issues related to security
    """
    issues = []

    # Create a dictionary of security concerns by ID for easy lookup
    concerns_by_id = {concern["id"]: concern for concern in security_concerns if "id" in concern}

    # Track which security concerns are addressed in implementation
    addressed_concerns = set()

    # Check each function for explicit references to security concerns
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function in functions:
            if not isinstance(function, dict):
                continue

            # Check architecture_issues_addressed field for explicit references to security concerns
            arch_issues_addressed = function.get("architecture_issues_addressed", [])
            if isinstance(arch_issues_addressed, list):
                for issue_id in arch_issues_addressed:
                    if issue_id in concerns_by_id:
                        addressed_concerns.add(issue_id)

    # Report any security concerns that are not explicitly addressed
    for concern_id, concern in concerns_by_id.items():
        if concern_id not in addressed_concerns:
            severity = concern.get("severity", "Medium").lower()
            issue_severity = "critical" if severity in ["critical", "high"] else "high"

            issues.append({
                "issue_type": "unaddressed_security_issue",
                "severity": issue_severity,
                "description": f"Security concern not explicitly addressed in implementation: {concern_id} - {concern.get('description', 'No description')}",
                "arch_issue_id": concern_id
            })

    return issues


def validate_cross_phase_security(
    architecture_review: Dict[str, Any],
    implementation_plan: Dict[str, Any],
    test_implementations: Dict[str, Any]
) -> Tuple[bool, Dict[str, Any], List[Dict[str, Any]]]:
    """
    Perform cross-phase security validation between architecture, implementation, and testing.

    Args:
        architecture_review: The architecture review data containing security concerns
        implementation_plan: The implementation plan to validate against security concerns
        test_implementations: The test implementations data for security testing validation

    Returns:
        Tuple of (is_valid, validation_details, validation_issues)
    """
    issues = []
    is_valid = True

    # Collect validation details
    validation_details = {
        "phases": {
            "architecture": {},
            "implementation": {},
            "testing": {}
        },
        "security_concerns": {},
        "cross_phase_issues": [],
        "owasp_categories": {},
        "overall_security_score": 0.0
    }

    # Step 1: Validate architecture security concerns
    arch_valid, arch_message, arch_details = validate_security_concerns(architecture_review)
    if not arch_valid:
        is_valid = False

    validation_details["phases"]["architecture"] = arch_details

    # Extract security concerns for cross-phase tracking
    security_concerns = _extract_security_concerns(architecture_review)
    validation_details["security_concerns"] = {
        concern["id"]: {
            "description": concern.get("description", ""),
            "severity": concern.get("severity", "Low"),
            "addressed_in": set(),
            "tested": False
        } for concern in security_concerns
    }

    # Step 2: Validate implementation security using the simplified validation function
    implementation_issues = _validate_implementation_security(implementation_plan, security_concerns)

    # Update validation details with implementation results
    implemented_concerns = set()
    for issue in implementation_issues:
        if issue["issue_type"] == "unaddressed_security_issue" and "arch_issue_id" in issue:
            concern_id = issue["arch_issue_id"]
            if concern_id in validation_details["security_concerns"]:
                # This security issue is not addressed in implementation
                pass

    # Find addressed concerns (those not in the issues list)
    for concern_id in validation_details["security_concerns"].keys():
        if not any(issue["arch_issue_id"] == concern_id for issue in implementation_issues if "arch_issue_id" in issue):
            implemented_concerns.add(concern_id)
            validation_details["security_concerns"][concern_id]["addressed_in"].add("implementation")

    # Add all implementation issues to the overall issues list
    issues.extend(implementation_issues)

    # Prepare implementation phase summary
    validation_details["phases"]["implementation"] = {
        "addressed_concerns": len(implemented_concerns),
        "total_concerns": len(security_concerns),
        "coverage_ratio": len(implemented_concerns) / max(1, len(security_concerns))
    }

    # Step 3: Validate security testing coverage
    security_test_issues = validate_security_testing_coverage(test_implementations, security_concerns)
    issues.extend(security_test_issues)

    # Extract tested security concerns
    tested_concerns = _extract_tested_concerns(test_implementations, security_concerns)
    for concern_id in tested_concerns:
        if concern_id in validation_details["security_concerns"]:
            validation_details["security_concerns"][concern_id]["addressed_in"].add("testing")
            validation_details["security_concerns"][concern_id]["tested"] = True

    # Update testing phase summary
    validation_details["phases"]["testing"] = {
        "tested_concerns": len(tested_concerns),
        "total_concerns": len(security_concerns),
        "coverage_ratio": len(tested_concerns) / max(1, len(security_concerns))
    }

    # Step 4: Perform cross-phase validation
    cross_phase_issues = _validate_security_across_phases(
        validation_details["security_concerns"],
        architecture_review,
        implementation_plan,
        test_implementations
    )
    issues.extend(cross_phase_issues)
    validation_details["cross_phase_issues"] = [issue["description"] for issue in cross_phase_issues]

    # Step 5: Calculate overall security score
    validation_details["overall_security_score"] = _calculate_security_score(validation_details)

    # Update overall validation status
    if issues and any(issue["severity"] in ["critical", "high"] for issue in issues):
        is_valid = False

    return is_valid, validation_details, issues


def validate_security_testing_coverage(
    test_implementations: Dict[str, Any],
    security_concerns: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """
    Validate that security concerns have corresponding tests.

    Args:
        test_implementations: The test implementations data
        security_concerns: List of security concerns from architecture review

    Returns:
        List of validation issues
    """
    issues = []

    # Extract security concerns by ID
    concerns_by_id = {concern["id"]: concern for concern in security_concerns if "id" in concern}

    # Track which security concerns are tested
    tested_concerns = _extract_tested_concerns(test_implementations, security_concerns)

    # Check for untested critical/high security concerns
    for concern_id, concern in concerns_by_id.items():
        severity = concern.get("severity", "Medium").lower()
        if severity in ["critical", "high"] and concern_id not in tested_concerns:
            issues.append({
                "issue_type": "untested_security_concern",
                "severity": "high",
                "description": f"Critical security concern '{concern_id}' ({concern.get('description', '')}) has no tests",
                "concern_id": concern_id
            })

    # Check for security test cases without coverage of key security aspects
    security_test_coverage = _analyze_security_test_coverage(test_implementations)

    # Check coverage of OWASP Top 10 categories
    owasp_categories = {
        "A01": "Broken Access Control",
        "A02": "Cryptographic Failures",
        "A03": "Injection",
        "A04": "Insecure Design",
        "A05": "Security Misconfiguration",
        "A06": "Vulnerable Components",
        "A07": "Identification and Authentication Failures",
        "A08": "Software and Data Integrity Failures",
        "A09": "Security Logging and Monitoring Failures",
        "A10": "Server-Side Request Forgery"
    }

    # Get security concerns' OWASP categories
    concern_categories = set()
    for concern in security_concerns:
        concern_text = concern.get("description", "") + " " + concern.get("recommendation", "")
        for category_id, category_name in owasp_categories.items():
            if category_id in concern_text or category_name.lower() in concern_text.lower():
                concern_categories.add(category_id)

    # Check if security testing covers all relevant OWASP categories
    for category_id in concern_categories:
        if category_id not in security_test_coverage["owasp_categories"]:
            issues.append({
                "issue_type": "missing_owasp_category_testing",
                "severity": "medium",
                "description": f"No tests for OWASP category {category_id}: {owasp_categories[category_id]}",
                "owasp_category": category_id
            })

    return issues


def _extract_security_concerns(architecture_review: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Extract security concerns from architecture review.

    Args:
        architecture_review: The architecture review data

    Returns:
        List of security concerns
    """
    security_concerns = []

    # Extract explicit security concerns
    if "security_concerns" in architecture_review:
        for concern in architecture_review.get("security_concerns", []):
            if isinstance(concern, dict):
                # Ensure each concern has an ID
                if "id" not in concern:
                    concern = concern.copy()
                    concern["id"] = f"SC-{len(security_concerns) + 1}"

                # Add issue_type if not present
                if "issue_type" not in concern:
                    concern = concern.copy()
                    concern["issue_type"] = "security_concern"

                security_concerns.append(concern)

    # Check for security-related logical gaps
    security_keywords = [
        "security", "auth", "login", "password", "credential", "token", "session",
        "jwt", "oauth", "permission", "access control", "rbac", "acl", "privilege",
        "validate", "sanitize", "escape", "filter", "clean", "parse", "encoding",
        "sql", "injection", "xss", "script", "csrf", "forgery", "cross-site",
        "encrypt", "hash", "salt", "sensitive", "pii", "personal", "data", "leak",
        "tls", "ssl", "https", "certificate"
    ]

    for gap in architecture_review.get("logical_gaps", []):
        if isinstance(gap, dict):
            description = gap.get("description", "").lower()
            recommendation = gap.get("recommendation", "").lower()
            if any(keyword in description or keyword in recommendation for keyword in security_keywords):
                # This logical gap is security-related, treat as security concern
                security_concern = gap.copy()
                if "id" not in security_concern:
                    security_concern["id"] = f"SC-LGAP-{len(security_concerns) + 1}"
                security_concern["issue_type"] = "security_concern"
                security_concerns.append(security_concern)

    return security_concerns


def _extract_tested_concerns(
    test_implementations: Dict[str, Any],
    security_concerns: List[Dict[str, Any]]
) -> Set[str]:
    """
    Extract security concerns that have tests.

    Args:
        test_implementations: The test implementations data
        security_concerns: List of security concerns from architecture review

    Returns:
        Set of concern IDs that are tested
    """
    tested_concerns = set()
    concern_ids = {concern["id"] for concern in security_concerns if "id" in concern}

    # Check if test_implementations has the expected structure
    if "tests" not in test_implementations:
        return tested_concerns

    # Extract tests that address security concerns
    for test_type, tests in test_implementations.get("tests", {}).items():
        for test in tests:
            # Check explicit architecture issue addressal
            if "architecture_issues_addressed" in test:
                for issue_id in test.get("architecture_issues_addressed", []):
                    if issue_id in concern_ids:
                        tested_concerns.add(issue_id)

            # Check target element IDs
            target_elements = test.get("target_element_ids", [])
            for concern in security_concerns:
                affected_elements = concern.get("affected_elements", []) or concern.get("target_element_ids", [])
                if any(elem in target_elements for elem in affected_elements):
                    tested_concerns.add(concern["id"])

            # Check test code and description for security-related testing
            test_code = test.get("code", "").lower()
            test_desc = test.get("description", "").lower()
            if any(keyword in test_code or keyword in test_desc for keyword in [
                "security", "auth", "login", "password", "injection", "xss", "sql",
                "csrf", "forgery", "unauthorized", "permission", "encrypt", "hash"
            ]):
                # This looks like a security test, check which concerns it might address
                for concern in security_concerns:
                    concern_desc = concern.get("description", "").lower()
                    # Check if test description or code addresses the security concern
                    if (any(term in concern_desc and term in test_desc for term in [
                        "auth", "login", "password", "injection", "xss", "sql", "csrf"
                    ]) or any(term in concern_desc and term in test_code for term in [
                        "auth", "login", "password", "injection", "xss", "sql", "csrf"
                    ])):
                        tested_concerns.add(concern["id"])

    return tested_concerns


def _validate_security_across_phases(
    security_concerns: Dict[str, Any],
    architecture_review: Dict[str, Any],
    implementation_plan: Dict[str, Any],
    test_implementations: Dict[str, Any]
) -> List[Dict[str, Any]]:
    """
    Simplified validation of security consistency across all phases,
    focusing on traceability rather than semantic validation.

    Args:
        security_concerns: Dictionary of security concerns with their cross-phase status
        architecture_review: The architecture review data
        implementation_plan: The implementation plan data
        test_implementations: The test implementations data

    Returns:
        List of cross-phase validation issues
    """
    issues = []

    # Check that critical/high security concerns are addressed in both implementation and testing
    for concern_id, concern_status in security_concerns.items():
        severity = concern_status["severity"].lower()
        addressed_in = concern_status["addressed_in"]

        if severity in ["critical", "high"]:
            # Critical concerns must be addressed in both implementation and testing
            if "implementation" not in addressed_in:
                issues.append({
                    "issue_type": "critical_concern_not_implemented",
                    "severity": "critical",
                    "description": f"Critical security concern '{concern_id}' is not addressed in implementation",
                    "concern_id": concern_id
                })

            if "testing" not in addressed_in:
                issues.append({
                    "issue_type": "critical_concern_not_tested",
                    "severity": "critical",
                    "description": f"Critical security concern '{concern_id}' lacks test coverage",
                    "concern_id": concern_id
                })
        elif severity == "medium":
            # Medium concerns should be addressed in at least implementation
            if "implementation" not in addressed_in:
                issues.append({
                    "issue_type": "medium_concern_not_implemented",
                    "severity": "medium",
                    "description": f"Medium security concern '{concern_id}' is not addressed in implementation",
                    "concern_id": concern_id
                })

    # Check architecture-to-tests direct traceability for critical concerns
    architecture_elements_with_security = _extract_elements_with_security_concerns(architecture_review)
    tested_elements = _extract_tested_elements(test_implementations)

    for element_id in architecture_elements_with_security:
        if element_id not in tested_elements:
            issues.append({
                "issue_type": "security_element_not_tested",
                "severity": "high",
                "description": f"Element '{element_id}' has security concerns but lacks direct test coverage",
                "element_id": element_id
            })

    return issues


def _analyze_security_test_coverage(test_implementations: Dict[str, Any]) -> Dict[str, Any]:
    """
    Analyze security test coverage from test implementations.

    Args:
        test_implementations: The test implementations data

    Returns:
        Dictionary with security test coverage statistics
    """
    coverage = {
        "owasp_categories": set(),
        "security_test_count": 0,
        "test_types": defaultdict(int)
    }

    # OWASP categories with keywords for detection
    owasp_detection = {
        "A01": ["access control", "authorization", "permission", "privilege", "rbac"],
        "A02": ["crypto", "encrypt", "hash", "tls", "ssl", "certificate"],
        "A03": ["injection", "sql", "xss", "script", "escape", "sanitize"],
        "A04": ["design", "architecture", "logic", "flow"],
        "A05": ["config", "misconfiguration", "default", "hardcoded"],
        "A06": ["component", "library", "dependency", "outdated", "version"],
        "A07": ["authentication", "login", "password", "credential", "session", "jwt", "token"],
        "A08": ["integrity", "signature", "verify", "deserialization"],
        "A09": ["log", "monitor", "audit", "trace", "debug"],
        "A10": ["ssrf", "request forgery", "server-side"]
    }

    # Check if test_implementations has the expected structure
    if "tests" not in test_implementations:
        return coverage

    # Analyze tests for security coverage
    for test_type, tests in test_implementations.get("tests", {}).items():
        for test in tests:
            # Detect if this is a security test
            test_code = test.get("code", "").lower()
            test_desc = test.get("description", "").lower()
            test_name = test.get("name", "").lower()

            is_security_test = (
                "security" in test_type or
                "security" in test_name or
                "security" in test_desc or
                any(keyword in test_desc or keyword in test_code for keyword in [
                    "auth", "login", "password", "injection", "xss", "sql",
                    "csrf", "forgery", "unauthorized", "permission", "encrypt", "hash"
                ])
            )

            if is_security_test:
                coverage["security_test_count"] += 1
                coverage["test_types"][test_type] += 1

                # Check which OWASP categories this test covers
                for category, keywords in owasp_detection.items():
                    if any(keyword in test_desc or keyword in test_code or keyword in test_name for keyword in keywords):
                        coverage["owasp_categories"].add(category)

    return coverage


def _extract_security_patterns(implementation_plan: Dict[str, Any]) -> Dict[str, List[str]]:
    """
    A simplified stub function that returns an empty dictionary.
    This function is kept for backward compatibility but no longer performs complex pattern matching.

    Args:
        implementation_plan: The implementation plan data

    Returns:
        Empty dictionary as complex pattern matching is no longer performed
    """
    return {}


def _identify_inconsistent_security_patterns(patterns: Dict[str, List[str]]) -> Dict[str, Any]:
    """
    A simplified stub function that returns an empty dictionary.
    This function is kept for backward compatibility but no longer performs complex pattern matching.

    Args:
        patterns: Dictionary mapping security patterns to lists of component paths

    Returns:
        Empty dictionary as complex pattern matching is no longer performed
    """
    return {}


def _extract_elements_with_security_concerns(architecture_review: Dict[str, Any]) -> Set[str]:
    """
    Extract elements that have security concerns in architecture review.

    Args:
        architecture_review: The architecture review data

    Returns:
        Set of element IDs with security concerns
    """
    elements = set()

    # Extract from explicit security concerns
    for concern in architecture_review.get("security_concerns", []):
        if isinstance(concern, dict):
            elements.update(concern.get("affected_elements", []) or concern.get("target_element_ids", []))

    # Extract from security-related logical gaps
    security_keywords = [
        "security", "auth", "login", "password", "credential", "token", "session",
        "inject", "xss", "csrf", "encrypt", "hash"
    ]

    for gap in architecture_review.get("logical_gaps", []):
        if isinstance(gap, dict):
            description = gap.get("description", "").lower()
            if any(keyword in description for keyword in security_keywords):
                elements.update(gap.get("affected_elements", []) or gap.get("target_element_ids", []))

    return elements


def _extract_tested_elements(test_implementations: Dict[str, Any]) -> Set[str]:
    """
    Extract elements that have test coverage.

    Args:
        test_implementations: The test implementations data

    Returns:
        Set of element IDs with test coverage
    """
    elements = set()

    # Check if test_implementations has the expected structure
    if "tests" not in test_implementations:
        return elements

    # Extract tested elements
    for test_type, tests in test_implementations.get("tests", {}).items():
        for test in tests:
            elements.update(test.get("target_element_ids", []))

    return elements


def _calculate_security_score(validation_details: Dict[str, Any]) -> float:
    """
    Calculate overall security score based on validation details.

    Args:
        validation_details: Dictionary with validation details

    Returns:
        Float between 0.0 and 1.0 representing security score
    """
    # Start with a perfect score
    score = 1.0

    # Penalize for architecture phase issues
    architecture_details = validation_details["phases"]["architecture"]
    if "total_security_concerns" in architecture_details and architecture_details["total_security_concerns"] > 0:
        properly_documented = architecture_details.get("properly_documented_concerns", 0)
        documentation_ratio = properly_documented / architecture_details["total_security_concerns"]
        # Reduce score for poor documentation (up to 10%)
        score -= 0.1 * (1 - documentation_ratio)

    # Penalize for missing security aspects (5% each)
    for aspect in architecture_details.get("missing_critical_security_aspects", []):
        score -= 0.05

    # Penalize for implementation phase issues
    implementation_details = validation_details["phases"]["implementation"]
    if "coverage_ratio" in implementation_details:
        # Reduce score for low implementation coverage (up to 40%)
        score -= 0.4 * (1 - implementation_details["coverage_ratio"])

    # Penalize for testing phase issues
    testing_details = validation_details["phases"]["testing"]
    if "coverage_ratio" in testing_details:
        # Reduce score for low testing coverage (up to 30%)
        score -= 0.3 * (1 - testing_details["coverage_ratio"])

    # Penalize for cross-phase issues (5% each, up to 20%)
    cross_phase_penalty = min(0.2, 0.05 * len(validation_details.get("cross_phase_issues", [])))
    score -= cross_phase_penalty

    # Ensure score is between 0 and 1
    return max(0.0, min(1.0, score))


def generate_security_report(
    architecture_review: Dict[str, Any],
    implementation_plan: Dict[str, Any],
    test_implementations: Dict[str, Any],
    output_format: str = "json"
) -> str:
    """
    Generate a comprehensive security report.

    Args:
        architecture_review: The architecture review data
        implementation_plan: The implementation plan data
        test_implementations: The test implementations data
        output_format: The output format ("json" or "markdown")

    Returns:
        Security report string in the requested format
    """
    # Perform validation
    is_valid, validation_details, issues = validate_cross_phase_security(
        architecture_review, implementation_plan, test_implementations
    )

    # Prepare report data
    report = {
        "summary": {
            "is_valid": is_valid,
            "score": validation_details["overall_security_score"],
            "grade": _score_to_grade(validation_details["overall_security_score"]),
            "total_issues": len(issues),
            "critical_issues": len([i for i in issues if i["severity"] == "critical"]),
            "high_issues": len([i for i in issues if i["severity"] == "high"]),
            "medium_issues": len([i for i in issues if i["severity"] == "medium"]),
            "low_issues": len([i for i in issues if i["severity"] == "low"])
        },
        "security_concerns": validation_details["security_concerns"],
        "phase_details": validation_details["phases"],
        "cross_phase_issues": validation_details["cross_phase_issues"],
        "issues": issues
    }

    # Format the report
    if output_format.lower() == "markdown":
        return _format_report_markdown(report)

    # Default to JSON format
    return json.dumps(report, indent=2, default=_set_serializer)


def _score_to_grade(score: float) -> str:
    """Convert security score to letter grade."""
    if score >= 0.9:
        return "A"
    elif score >= 0.8:
        return "B"
    elif score >= 0.7:
        return "C"
    elif score >= 0.6:
        return "D"
    else:
        return "F"


def _set_serializer(obj):
    """JSON serializer for sets."""
    if isinstance(obj, set):
        return list(obj)
    raise TypeError("Type not serializable")


def _format_report_markdown(report: Dict[str, Any]) -> str:
    """Format security report as Markdown."""
    md = ["# Security Validation Report\n"]

    # Summary section
    md.append("## Summary\n")
    md.append(f"- **Status**: {' PASS' if report['summary']['is_valid'] else ' FAIL'}")
    md.append(f"- **Security Score**: {report['summary']['score']:.2f} ({report['summary']['grade']})")
    md.append(f"- **Total Issues**: {report['summary']['total_issues']}")
    md.append(f"- **Critical Issues**: {report['summary']['critical_issues']}")
    md.append(f"- **High Issues**: {report['summary']['high_issues']}")
    md.append(f"- **Medium Issues**: {report['summary']['medium_issues']}")
    md.append(f"- **Low Issues**: {report['summary']['low_issues']}\n")

    # Phase details
    md.append("## Phase Details\n")

    # Architecture phase
    arch = report["phase_details"]["architecture"]
    md.append("### Architecture Phase\n")
    md.append(f"- **Security Concerns**: {arch.get('total_security_concerns', 0)}")
    md.append(f"- **Properly Documented**: {arch.get('properly_documented_concerns', 0)}")

    missing_aspects = arch.get("missing_critical_security_aspects", [])
    if missing_aspects:
        md.append("\n**Missing Security Aspects:**\n")
        for aspect in missing_aspects:
            md.append(f"- {aspect}")

    # Implementation phase
    impl = report["phase_details"]["implementation"]
    md.append("\n### Implementation Phase\n")
    md.append(f"- **Addressed Concerns**: {impl.get('addressed_concerns', 0)}/{impl.get('total_concerns', 0)}")
    md.append(f"- **Coverage Ratio**: {impl.get('coverage_ratio', 0):.2f}")

    # Testing phase
    test = report["phase_details"]["testing"]
    md.append("\n### Testing Phase\n")
    md.append(f"- **Tested Concerns**: {test.get('tested_concerns', 0)}/{test.get('total_concerns', 0)}")
    md.append(f"- **Coverage Ratio**: {test.get('coverage_ratio', 0):.2f}")

    # Cross-phase issues
    if report["cross_phase_issues"]:
        md.append("\n## Cross-Phase Issues\n")
        for issue in report["cross_phase_issues"]:
            md.append(f"- {issue}")

    # Security issues
    if report["issues"]:
        md.append("\n## Security Issues\n")

        # Group issues by severity
        severity_groups = {"critical": [], "high": [], "medium": [], "low": []}
        for issue in report["issues"]:
            severity_groups[issue["severity"]].append(issue)

        for severity, issues in severity_groups.items():
            if not issues:
                continue

            md.append(f"\n### {severity.upper()} Issues\n")
            for i, issue in enumerate(issues):
                md.append(f"**{i+1}. {issue['issue_type']}**")
                md.append(f"- {issue['description']}")

    return "\n".join(md) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.project_profiler 4:[17:623]
==agent_s3.tools.context_management.adaptive_config.project_profiler:[17:623]
logger = logging.getLogger(__name__)

# Common framework detection patterns
FRAMEWORK_PATTERNS = {
    "python": {
        "django": [r'django', r'urls\.py', r'views\.py', r'models\.py', r'apps\.py'],
        "flask": [r'flask', r'@app\.route', r'Flask\s*\('],
        "fastapi": [r'fastapi', r'@app\.get', r'@app\.post'],
        "pytorch": [r'torch\.nn', r'torch\.optim'],
        "tensorflow": [r'tensorflow', r'tf\.keras', r'tf\.data'],
        "pytest": [r'pytest', r'@pytest', r'test_.*\.py'],
    },
    "javascript": {
        "react": [r'react', r'React', r'useState', r'useEffect'],
        "vue": [r'vue', r'Vue', r'createApp', r'setup\(\)'],
        "angular": [r'angular', r'@Component', r'NgModule'],
        "express": [r'express', r'app\.get', r'app\.post', r'app\.use'],
        "next.js": [r'next/router', r'getServerSideProps', r'getStaticProps'],
    },
    "typescript": {
        "react": [r'React', r'useState', r'useEffect'],
        "angular": [r'@Component', r'NgModule', r'Injectable'],
        "nest": [r'@nestjs', r'@Controller', r'@Module'],
        "next.js": [r'next/router', r'GetServerSideProps', r'GetStaticProps'],
    }
}

# Project type classification criteria
PROJECT_TYPE_CRITERIA = {
    "web_frontend": {
        "file_patterns": [r'index\.html', r'styles?\.css', r'package\.json'],
        "frameworks": ["react", "vue", "angular", "next.js"],
        "directory_patterns": ["components", "pages", "views", "public", "static"]
    },
    "web_backend": {
        "file_patterns": [r'server\.js', r'app\.py', r'urls\.py', r'routes\.'],
        "frameworks": ["django", "flask", "express", "fastapi", "nest"],
        "directory_patterns": ["routes", "controllers", "models", "api"]
    },
    "data_science": {
        "file_patterns": [r'\.ipynb$', r'data_processing', r'model\.py', r'train\.py'],
        "frameworks": ["pytorch", "tensorflow", "pandas", "scikit-learn"],
        "directory_patterns": ["data", "models", "notebooks", "experiments"]
    },
    "cli_tool": {
        "file_patterns": [r'cli\.py', r'main\.py', r'bin/', r'command'],
        "frameworks": ["click", "argparse", "commander"],
        "directory_patterns": ["commands", "cli"]
    },
    "library": {
        "file_patterns": [r'setup\.py', r'package\.json', r'Cargo\.toml', r'README\.md'],
        "frameworks": [],  # Libraries often don't use specific frameworks
        "directory_patterns": ["src", "lib", "test", "docs", "examples"]
    },
}


class ProjectProfiler:
    """
    Analyzes code repository characteristics to determine optimal configuration
    settings for context management.
    """

    def __init__(self, repo_path: str):
        """
        Initialize the project profiler with a repository path.

        Args:
            repo_path: Path to the code repository
        """
        self.repo_path = repo_path
        self.file_stats = {}
        self.language_stats = {}
        self.framework_stats = {}
        self.project_type = None
        self.project_size = None
        self.directory_structure = {}
        self.repo_metrics = {}
        self._content_samples = {}

    def analyze_repository(self) -> Dict[str, Any]:
        """
        Perform a comprehensive analysis of the repository.

        Returns:
            Dictionary containing repository metrics and characteristics
        """
        logger.info(f"Analyzing repository at {self.repo_path}")

        # Gather basic repository metrics
        self._gather_file_statistics()
        self._detect_languages()
        self._analyze_directory_structure()
        self._detect_frameworks()
        self._determine_project_type()
        self._calculate_code_density()

        # Compile all metrics into a single report
        self.repo_metrics = {
            "file_stats": self.file_stats,
            "language_stats": self.language_stats,
            "framework_stats": self.framework_stats,
            "project_type": self.project_type,
            "project_size": self.project_size,
            "directory_structure": self.directory_structure,
            "code_density": self.file_stats.get("code_density", {}),
        }

        logger.info(f"Repository analysis complete: {self.project_type} project with "
                  f"primary language {self.get_primary_language()}")

        return self.repo_metrics

    def get_recommended_config(self) -> Dict[str, Any]:
        """
        Get recommended configuration settings based on repository analysis.

        Returns:
            Dictionary with recommended configuration parameters
        """
        # Ensure we have analysis results
        if not self.repo_metrics:
            self.analyze_repository()

        # Base configuration
        config = {
            "context_management": {
                "enabled": True,
                "background_enabled": True,
                "optimization_interval": 60,
                "embedding": {
                    "chunk_size": 1000,
                    "chunk_overlap": 200,
                },
                "search": {
                    "bm25": {
                        "k1": 1.2,
                        "b": 0.75
                    },
                },
                "summarization": {
                    "threshold": 2000,
                    "compression_ratio": 0.5
                },
                "importance_scoring": {
                    "code_weight": 1.0,
                    "comment_weight": 0.8,
                    "metadata_weight": 0.7,
                    "framework_weight": 0.9
                }
            }
        }

        # Adjust configuration based on project type
        self._adjust_config_for_project_type(config)

        # Adjust configuration based on project size
        self._adjust_config_for_project_size(config)

        # Adjust configuration based on language
        self._adjust_config_for_language(config)

        # Adjust configuration based on code density
        self._adjust_config_for_code_density(config)

        return config

    def _gather_file_statistics(self) -> None:
        """Gather statistics about files in the repository."""
        file_count = 0
        total_size = 0
        extension_counts = Counter()
        size_by_extension = defaultdict(int)

        # Ignore common directories that don't contain source code
        ignore_patterns = [
            ".git", "__pycache__", "node_modules", "venv",
            "build", "dist", ".vscode", ".idea"
        ]
        ignore_dirs = set()

        for root, dirs, files in os.walk(self.repo_path):
            # Filter out directories to ignore
            dirs[:] = [d for d in dirs if d not in ignore_patterns]

            for file in files:
                file_path = os.path.join(root, file)

                # Skip if file is in an ignored directory
                if any(ignored in file_path for ignored in ignore_dirs):
                    continue

                # Skip binary files and very large files
                try:
                    if os.path.getsize(file_path) > 10 * 1024 * 1024:  # Skip files larger than 10MB
                        continue

                    _, ext = os.path.splitext(file)
                    ext = ext.lower()

                    file_size = os.path.getsize(file_path)
                    file_count += 1
                    total_size += file_size
                    extension_counts[ext] += 1
                    size_by_extension[ext] += file_size

                except OSError:
                    continue

        # Calculate average file size by extension
        avg_size_by_extension = {
            ext: size_by_extension[ext] / count
            for ext, count in extension_counts.items()
            if count > 0
        }

        # Calculate project size category
        if file_count < 100:
            project_size = "small"
        elif file_count < 1000:
            project_size = "medium"
        else:
            project_size = "large"

        self.file_stats = {
            "file_count": file_count,
            "total_size": total_size,
            "avg_file_size": total_size / file_count if file_count > 0 else 0,
            "extension_counts": dict(extension_counts),
            "avg_size_by_extension": avg_size_by_extension
        }

        self.project_size = project_size

    def _detect_languages(self) -> None:
        """Detect programming languages used in the repository."""
        if not self.file_stats:
            self._gather_file_statistics()

        language_counts = Counter()
        language_sizes = defaultdict(int)

        # Map file extensions to languages
        for ext, count in self.file_stats["extension_counts"].items():
            language = EXTENSION_TO_LANGUAGE.get(ext, "unknown")
            if language != "unknown":
                language_counts[language] += count
                language_sizes[language] += self.file_stats["avg_size_by_extension"].get(ext, 0) * count

        # Calculate language percentages by file count
        total_files = sum(language_counts.values())
        language_percentages = {
            lang: count / total_files * 100
            for lang, count in language_counts.items()
        } if total_files > 0 else {}

        # Calculate language percentages by file size
        total_size = sum(language_sizes.values())
        language_size_percentages = {
            lang: size / total_size * 100
            for lang, size in language_sizes.items()
        } if total_size > 0 else {}

        self.language_stats = {
            "language_counts": dict(language_counts),
            "language_percentages": language_percentages,
            "language_size_percentages": language_size_percentages,
            "primary_language": language_counts.most_common(1)[0][0] if language_counts else "unknown"
        }

    def _get_content_sample(self, language: str) -> List[str]:
        """
        Get a sample of file content for a specific language.

        Args:
            language: The programming language

        Returns:
            List of file content samples for the specified language
        """
        if language in self._content_samples:
            return self._content_samples[language]

        samples = []
        sample_count = 0
        max_samples = 10

        for ext, lang in EXTENSION_TO_LANGUAGE.items():
            if lang != language:
                continue

            # Find files with this extension
            for root, _, files in os.walk(self.repo_path):
                for file in files:
                    if not file.endswith(ext):
                        continue

                    file_path = os.path.join(root, file)
                    try:
                        # Only read the first 50KB to avoid large files
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read(50 * 1024)
                            samples.append(content)
                            sample_count += 1

                            if sample_count >= max_samples:
                                self._content_samples[language] = samples
                                return samples
                    except Exception:
                        continue

        self._content_samples[language] = samples
        return samples

    def _detect_frameworks(self) -> None:
        """Detect frameworks used in the repository."""
        if not self.language_stats:
            self._detect_languages()

        framework_scores = defaultdict(float)

        # Check for framework patterns in each language
        for language, percentage in self.language_stats["language_percentages"].items():
            if percentage < 5:  # Skip languages with less than 5% usage
                continue

            if language not in FRAMEWORK_PATTERNS:
                continue

            # Get content samples for this language
            samples = self._get_content_sample(language)
            if not samples:
                continue

            # Check each framework's patterns
            for framework, patterns in FRAMEWORK_PATTERNS[language].items():
                framework_key = f"{language}.{framework}"
                score = 0

                # Check for framework patterns in content samples
                for sample in samples:
                    for pattern in patterns:
                        matches = re.findall(pattern, sample, re.IGNORECASE)
                        if matches:
                            score += len(matches) * 0.5

                # Check for framework files and directories
                for pattern in patterns:
                    matching_files = glob.glob(f"{self.repo_path}/**/*{pattern}*", recursive=True)
                    score += len(matching_files)

                if score > 0:
                    framework_scores[framework_key] = score

        # Normalize scores
        total_score = sum(framework_scores.values()) or 1
        framework_percentages = {
            framework: (score / total_score) * 100
            for framework, score in framework_scores.items()
        }

        self.framework_stats = {
            "detected_frameworks": {
                k: v for k, v in framework_scores.items() if v > 0
            },
            "framework_percentages": framework_percentages
        }

    def _analyze_directory_structure(self) -> None:
        """Analyze the repository directory structure."""
        dirs = defaultdict(int)
        dir_depths = []

        for root, directories, files in os.walk(self.repo_path):
            # Calculate depth from repo root
            rel_path = os.path.relpath(root, self.repo_path)
            if rel_path == '.':
                depth = 0
            else:
                depth = rel_path.count(os.sep) + 1

            dir_depths.append(depth)

            # Count directories at each level
            for directory in directories:
                dirs[directory.lower()] += 1

        self.directory_structure = {
            "common_directories": {k: v for k, v in sorted(dirs.items(), key=lambda x: x[1], reverse=True)[:20]},
            "max_depth": max(dir_depths) if dir_depths else 0,
            "avg_depth": sum(dir_depths) / len(dir_depths) if dir_depths else 0
        }

    def _determine_project_type(self) -> None:
        """Determine the type of project based on files and frameworks."""
        if not self.framework_stats or not self.directory_structure:
            self._detect_frameworks()
            self._analyze_directory_structure()

        scores = defaultdict(float)

        # Score based on file patterns
        for project_type, criteria in PROJECT_TYPE_CRITERIA.items():
            # Check file patterns
            for pattern in criteria["file_patterns"]:
                matching_files = glob.glob(f"{self.repo_path}/**/{pattern}", recursive=True)
                scores[project_type] += len(matching_files) * 2

            # Check frameworks
            detected_frameworks = set(self.framework_stats.get("detected_frameworks", {}).keys())
            for framework in criteria["frameworks"]:
                for detected in detected_frameworks:
                    if framework in detected.lower():
                        scores[project_type] += 5

            # Check directory patterns
            common_dirs = set(self.directory_structure["common_directories"].keys())
            for dir_pattern in criteria["directory_patterns"]:
                for common_dir in common_dirs:
                    if dir_pattern in common_dir:
                        scores[project_type] += 3

        # Determine the most likely project type
        if scores:
            self.project_type = max(scores.items(), key=lambda x: x[1])[0]
        else:
            self.project_type = "unknown"

    def _calculate_code_density(self) -> None:
        """Calculate code density metrics for the repository."""
        language_density = {}

        # Calculate density for each major language
        for language, percentage in self.language_stats.get("language_percentages", {}).items():
            if percentage < 5:  # Skip languages with less than 5% usage
                continue

            samples = self._get_content_sample(language)
            if not samples:
                continue

            # Calculate metrics
            total_lines = 0
            total_chars = 0
            total_empty_lines = 0
            total_comment_lines = 0

            comment_patterns = {
                "python": r'^\s*#.*$',
                "javascript": r'^\s*(//.*)$|^\s*/\*[\s\S]*?\*/',
                "typescript": r'^\s*(//.*)$|^\s*/\*[\s\S]*?\*/',
                "java": r'^\s*(//.*)$|^\s*/\*[\s\S]*?\*/',
                "csharp": r'^\s*(//.*)$|^\s*/\*[\s\S]*?\*/',
            }

            comment_pattern = comment_patterns.get(language, r'^\s*#.*$')

            for sample in samples:
                lines = sample.split('\n')
                total_lines += len(lines)
                total_chars += len(sample)

                for line in lines:
                    if not line.strip():
                        total_empty_lines += 1
                    elif re.match(comment_pattern, line):
                        total_comment_lines += 1

            if total_lines > 0:
                language_density[language] = {
                    "avg_line_length": total_chars / total_lines,
                    "empty_line_ratio": total_empty_lines / total_lines,
                    "comment_ratio": total_comment_lines / total_lines,
                    "code_density_score": (total_lines - total_empty_lines - total_comment_lines) / total_lines
                }

        self.file_stats["code_density"] = language_density

    def get_primary_language(self) -> str:
        """Get the primary programming language used in the repository."""
        if not self.language_stats:
            self._detect_languages()

        return self.language_stats.get("primary_language", "unknown")

    def _adjust_config_for_project_type(self, config: Dict[str, Any]) -> None:
        """
        Adjust configuration based on detected project type.

        Args:
            config: Configuration dictionary to adjust
        """
        cm_config = config["context_management"]

        if self.project_type == "web_frontend":
            # Frontend projects often benefit from smaller chunks with more overlap
            cm_config["embedding"]["chunk_size"] = 800
            cm_config["embedding"]["chunk_overlap"] = 250
            cm_config["importance_scoring"]["code_weight"] = 1.1
            cm_config["importance_scoring"]["framework_weight"] = 1.2

        elif self.project_type == "web_backend":
            # Backend projects often have more structured code
            cm_config["embedding"]["chunk_size"] = 1200
            cm_config["search"]["bm25"]["k1"] = 1.5  # Higher k1 for more term frequency impact
            cm_config["importance_scoring"]["code_weight"] = 1.2

        elif self.project_type == "data_science":
            # Data science projects often have notebooks and data processing code
            cm_config["embedding"]["chunk_size"] = 1500
            cm_config["embedding"]["chunk_overlap"] = 300
            cm_config["importance_scoring"]["comment_weight"] = 1.0  # Comments often contain important explanations

        elif self.project_type == "cli_tool":
            # CLI tools often have simpler structure
            cm_config["embedding"]["chunk_size"] = 900
            cm_config["importance_scoring"]["code_weight"] = 1.3

        elif self.project_type == "library":
            # Libraries often have well-documented interfaces
            cm_config["embedding"]["chunk_size"] = 1100
            cm_config["importance_scoring"]["code_weight"] = 1.1
            cm_config["importance_scoring"]["comment_weight"] = 1.0

    def _adjust_config_for_project_size(self, config: Dict[str, Any]) -> None:
        """
        Adjust configuration based on project size.

        Args:
            config: Configuration dictionary to adjust
        """
        cm_config = config["context_management"]

        if self.project_size == "small":
            # Small projects can use smaller optimization intervals
            cm_config["optimization_interval"] = 30
            cm_config["summarization"]["threshold"] = 1500

        elif self.project_size == "medium":
            # Medium projects use the default settings
            pass

        elif self.project_size == "large":
            # Large projects need more aggressive optimization
            cm_config["optimization_interval"] = 90  # More frequent optimization
            cm_config["summarization"]["threshold"] = 2500
            cm_config["summarization"]["compression_ratio"] = 0.4  # More aggressive summarization

    def _adjust_config_for_language(self, config: Dict[str, Any]) -> None:
        """
        Adjust configuration based on primary programming language.

        Args:
            config: Configuration dictionary to adjust
        """
        cm_config = config["context_management"]
        primary_language = self.get_primary_language()

        if primary_language == "python":
            # Python tends to be more concise
            cm_config["embedding"]["chunk_size"] = int(cm_config["embedding"]["chunk_size"] * 0.9)

        elif primary_language in ["java", "csharp"]:
            # Java and C# tend to be more verbose
            cm_config["embedding"]["chunk_size"] = int(cm_config["embedding"]["chunk_size"] * 1.2)
            cm_config["search"]["bm25"]["b"] = 0.8  # Slightly higher b for more document length normalization

        elif primary_language in ["javascript", "typescript"]:
            # JS/TS often have many short functions
            cm_config["embedding"]["chunk_size"] = int(cm_config["embedding"]["chunk_size"] * 0.95)
            cm_config["search"]["bm25"]["k1"] = 1.3  # Higher k1 for more term frequency impact

    def _adjust_config_for_code_density(self, config: Dict[str, Any]) -> None:
        """
        Adjust configuration based on code density metrics.

        Args:
            config: Configuration dictionary to adjust
        """
        cm_config = config["context_management"]
        primary_language = self.get_primary_language()

        density_metrics = self.file_stats.get("code_density", {}).get(primary_language, {})
        if not density_metrics:
            return

        code_density_score = density_metrics.get("code_density_score", 0.7)  # Default if not available

        # Adjust chunk size based on code density
        if code_density_score > 0.8:
            # Very dense code, use smaller chunks
            cm_config["embedding"]["chunk_size"] = int(cm_config["embedding"]["chunk_size"] * 0.9)
            cm_config["embedding"]["chunk_overlap"] = int(cm_config["embedding"]["chunk_overlap"] * 1.1)

        elif code_density_score < 0.5:
            # Less dense code (more comments, whitespace), can use larger chunks
            cm_config["embedding"]["chunk_size"] = int(cm_config["embedding"]["chunk_size"] * 1.1)

        # Adjust importance weights based on comment ratio
        comment_ratio = density_metrics.get("comment_ratio", 0.2)
        if comment_ratio > 0.3:
            # Many comments, likely important documentation
            cm_config["importance_scoring"]["comment_weight"] = min(1.2, cm_config["importance_scoring"]["comment_weight"] * 1.2)
        elif comment_ratio < 0.1:
            # Few comments, less likely to be important
            cm_config["importance_scoring"]["comment_weight"] = max(0.5, cm_config["importance_scoring"]["comment_weight"] * 0.8) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.phase_validator 4:[16:594]
==agent_s3.tools.phase_validator:[16:594]
logger = logging.getLogger(__name__)


def validate_phase_transition(pre_plan_data: Dict[str, Any], feature_group: Dict[str, Any]) -> Tuple[bool, str]:
    """Validate the transition from pre-planning to planning phase.

    Checks if feature group is consistent with pre-planning constraints.

    Args:
        pre_plan_data: The pre-planning data containing constraints
        feature_group: The feature group to validate

    Returns:
        Tuple of (is_valid, error_message)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []

    # Check if feature group has required fields
    required_fields = ["group_name", "group_description", "features"]
    missing_fields = [field for field in required_fields if field not in feature_group]

    if missing_fields:
        error_messages.append(f"Missing required fields in feature group: {', '.join(missing_fields)}")
        is_valid = False

    # Check features list is not empty
    if "features" in feature_group and not feature_group["features"]:
        error_messages.append("Feature group has empty features list")
        is_valid = False

    # Validate against technical constraints
    if "technical_constraints" in pre_plan_data:
        tech_constraints = pre_plan_data["technical_constraints"]

        # Check file exclusions
        if "file_exclusions" in tech_constraints and "features" in feature_group:
            excluded_patterns = tech_constraints["file_exclusions"]

            for feature in feature_group["features"]:
                if "files_affected" in feature:
                    for file_path in feature["files_affected"]:
                        for pattern in excluded_patterns:
                            if re.search(pattern, file_path):
                                error_messages.append(
                                    f"Feature {feature.get('name', 'Unknown')} affects excluded file: {file_path} (matches pattern: {pattern})"
                                )
                                is_valid = False

    # Validate file references if files_affected are present
    for feature in feature_group.get("features", []):
        for file_path in feature.get("files_affected", []):
            # Skip files with wildcards or common new file patterns
            if "*" in file_path or "?" in file_path:
                continue
            if any(pattern in file_path.lower() for pattern in ["new_", "to_be_created", "create_"]):
                continue

            # Check if file exists (can't do actual validation here since we don't have file_tool)
            # This will be done in the coordinator when this function is called

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid"


def validate_user_modifications(modification_text: str) -> Tuple[bool, str]:
    """Validate user modifications to ensure they don't break the plan.

    Args:
        modification_text: The user's modification text

    Returns:
        Tuple of (is_valid, error_message)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []

    # Check for problematic patterns in modification text
    problematic_patterns = [
        (r"remove all", "Modification suggests removing everything"),
        (r"delete (everything|all)", "Modification suggests deleting everything"),
        (r"start over", "Modification suggests starting over"),
        (r"redo (everything|all|the plan)", "Modification suggests redoing everything"),
        (r"completely change", "Modification suggests completely changing the plan")
    ]

    for pattern, error_msg in problematic_patterns:
        if re.search(pattern, modification_text, re.IGNORECASE):
            error_messages.append(error_msg)
            is_valid = False

    # Check if modification text is too short or empty
    if len(modification_text.strip()) < 5:
        error_messages.append("Modification text is too short or empty")
        is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid"


def validate_architecture_implementation(architecture_review: Dict[str, Any], implementation_plan: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    """Validate that implementation components align with architecture design.

    Args:
        architecture_review: The architecture review data
        implementation_plan: The implementation plan data

    Returns:
        Tuple of (is_valid, error_message, validation_details)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []
    validation_details = {
        "unaddressed_gaps": [],
        "unaddressed_optimizations": [],
        "missing_components": []
    }

    # Check if logical gaps are addressed in implementation
    logical_gaps = architecture_review.get("logical_gaps", [])
    for gap in logical_gaps:
        # Extract affected components from logical gap
        affected_components = gap.get("affected_components", [])

        # Check if those components appear in implementation plan
        gap_addressed = False
        for component in affected_components:
            # Check if component is a file path
            if os.path.basename(component) in [os.path.basename(file) for file in implementation_plan.keys()]:
                gap_addressed = True
                break

        if not gap_addressed and affected_components:
            validation_details["unaddressed_gaps"].append({
                "description": gap.get("description", "Unknown gap"),
                "affected_components": affected_components
            })
            error_messages.append(f"Logical gap not addressed: {gap.get('description', 'Unknown gap')}")
            is_valid = False

    # Check if optimization suggestions are incorporated
    optimization_suggestions = architecture_review.get("optimization_suggestions", [])
    for suggestion in optimization_suggestions:
        # Extract affected components from suggestion
        affected_components = suggestion.get("affected_components", [])

        # Check if those components appear in implementation plan with the optimization
        suggestion_addressed = False
        for component in affected_components:
            # Check if component is a file path
            if os.path.basename(component) in [os.path.basename(file) for file in implementation_plan.keys()]:
                # Look for keywords from suggestion in implementation steps
                suggestion_keywords = _extract_keywords(suggestion.get("description", ""))
                for file_path, implementations in implementation_plan.items():
                    if os.path.basename(component) == os.path.basename(file_path):
                        for impl in implementations:
                            steps_text = " ".join(impl.get("steps", []))
                            if any(keyword in steps_text.lower() for keyword in suggestion_keywords):
                                suggestion_addressed = True
                                break

            if suggestion_addressed:
                break

        if not suggestion_addressed and affected_components and suggestion_keywords:
            validation_details["unaddressed_optimizations"].append({
                "description": suggestion.get("description", "Unknown suggestion"),
                "affected_components": affected_components
            })
            error_messages.append(f"Optimization not incorporated: {suggestion.get('description', 'Unknown suggestion')}")
            is_valid = False

    # Check for components in architecture review but missing in implementation
    all_components = set()
    for gap in logical_gaps:
        all_components.update(gap.get("affected_components", []))
    for suggestion in optimization_suggestions:
        all_components.update(suggestion.get("affected_components", []))

    # Filter actual file paths (not feature names)
    file_components = {c for c in all_components if os.path.basename(c) != c}
    implemented_files = {os.path.basename(f) for f in implementation_plan.keys()}

    missing_components = []
    for component in file_components:
        base_name = os.path.basename(component)
        if base_name not in implemented_files:
            missing_components.append(component)

    if missing_components:
        validation_details["missing_components"] = missing_components
        error_messages.append(f"Components mentioned in architecture but missing in implementation: {', '.join(missing_components)}")
        is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid", validation_details


def validate_test_coverage_against_risk(tests: Dict[str, Any], risk_assessment: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    """Validate that tests provide adequate coverage for identified risks.

    Args:
        tests: The test plan data
        risk_assessment: The risk assessment data

    Returns:
        Tuple of (is_valid, error_message, validation_details)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []
    validation_details = {
        "uncovered_critical_files": [],
        "uncovered_high_risk_areas": [],
        "missing_required_types": [],
        "missing_required_keywords": [],
        "missing_suggested_libraries": [],
        "total_risk_areas": 0,
        "covered_risk_areas": 0
    }

    # Extract critical files from risk assessment
    critical_files = risk_assessment.get("critical_files", [])
    high_risk_areas = risk_assessment.get("high_risk_areas", [])

    validation_details["total_risk_areas"] = len(high_risk_areas)

    # Check if critical files are tested
    all_test_files = set()
    for test_type, test_list in tests.items():
        for test in test_list:
            if "implementation_file" in test:
                all_test_files.add(test["implementation_file"])

    # Find critical files without tests
    uncovered_critical = []
    for critical_file in critical_files:
        if critical_file not in all_test_files:
            uncovered_critical.append(critical_file)

    if uncovered_critical:
        validation_details["uncovered_critical_files"] = uncovered_critical
        error_messages.append(f"Critical files without tests: {', '.join(uncovered_critical)}")
        is_valid = False

    # Check high risk areas coverage
    covered_risk_areas = []
    uncovered_risk_areas = []

    for risk_area in high_risk_areas:
        area_name = risk_area.get("name", "Unknown risk area")
        area_components = risk_area.get("components", [])

        # Check if any components are tested
        area_covered = False
        for component in area_components:
            if component in all_test_files:
                area_covered = True
                covered_risk_areas.append(area_name)
                break

        if not area_covered:
            uncovered_risk_areas.append({
                "name": area_name,
                "components": area_components
            })

    validation_details["covered_risk_areas"] = len(covered_risk_areas)

    if uncovered_risk_areas:
        validation_details["uncovered_high_risk_areas"] = uncovered_risk_areas
        error_messages.append(f"High risk areas without test coverage: {', '.join([area['name'] for area in uncovered_risk_areas])}")
        is_valid = False

    # Check test types coverage relative to risk assessment
    property_based_needed = "edge_cases" in risk_assessment and risk_assessment["edge_cases"]
    if property_based_needed and not tests.get("property_based_tests", []):
        error_messages.append("Risk assessment indicates edge cases, but no property-based tests found")
        is_valid = False

    integration_needed = "component_interactions" in risk_assessment and risk_assessment["component_interactions"]
    if integration_needed and not tests.get("integration_tests", []):
        error_messages.append("Risk assessment indicates component interactions, but no integration tests found")
        is_valid = False

    # Check required test characteristics if present
    required_test_characteristics = risk_assessment.get("required_test_characteristics", {})
    if required_test_characteristics:
        # 1. Check for required test types
        required_types = required_test_characteristics.get("required_types", [])
        if required_types:
            # For each required type, check if it exists in the tests
            missing_types = []
            for req_type in required_types:
                # We only support the core test types: unit, integration, property-based, acceptance
                # Security and performance tests must be represented as unit or integration tests
                if req_type in ["security", "security_tests", "performance", "performance_tests"]:
                    # Map security and performance to their corresponding core types
                    if req_type.startswith("security"):
                        # Check if any tests address security concerns
                        security_concern_addressed = False
                        for test_list in tests.values():
                            for test in test_list:
                                if "security" in test.get("description", "").lower() or "security" in test.get("test_name", "").lower():
                                    security_concern_addressed = True
                                    break
                            if security_concern_addressed:
                                break
                        if not security_concern_addressed:
                            missing_types.append("security_tests")
                    elif req_type.startswith("performance"):
                        # Check if any tests address performance concerns
                        performance_concern_addressed = False
                        for test_list in tests.values():
                            for test in test_list:
                                if "performance" in test.get("description", "").lower() or "performance" in test.get("test_name", "").lower():
                                    performance_concern_addressed = True
                                    break
                            if performance_concern_addressed:
                                break
                        if not performance_concern_addressed:
                            missing_types.append("performance_tests")
                else:
                    # Normalize type name for the core test types
                    normalized_type = f"{req_type}_tests" if not req_type.endswith("_tests") else req_type

                    # Check if we have this test type
                    if not tests.get(normalized_type, []):
                        missing_types.append(req_type)

            if missing_types:
                validation_details["missing_required_types"] = missing_types
                error_messages.append(f"Missing required test types: {', '.join(missing_types)}")
                is_valid = False

        # 2. Check for required keywords in test names/descriptions
        required_keywords = required_test_characteristics.get("required_keywords", [])
        if required_keywords:
            # For each required keyword, check if it appears in any test name or description
            missing_keywords = []
            for keyword in required_keywords:
                keyword_found = False

                # Check across all test types
                for test_type, test_list in tests.items():
                    for test in test_list:
                        # Look in test_name, description or test code
                        test_name = test.get("test_name", "").lower()
                        description = test.get("description", "").lower()
                        code = test.get("code", "").lower()

                        if (keyword.lower() in test_name or
                            keyword.lower() in description or
                            keyword.lower() in code):
                            keyword_found = True
                            break

                    if keyword_found:
                        break

                if not keyword_found:
                    missing_keywords.append(keyword)

            if missing_keywords:
                validation_details["missing_required_keywords"] = missing_keywords
                error_messages.append(f"Missing required test keywords: {', '.join(missing_keywords)}")
                is_valid = False

        # 3. Check for suggested libraries (if we have import/library information)
        suggested_libraries = required_test_characteristics.get("suggested_libraries", [])
        if suggested_libraries:
            missing_libraries = []
            for library in suggested_libraries:
                library_found = False

                # Look for library references across all tests
                for test_type, test_list in tests.items():
                    for test in test_list:
                        # Check in test code if available
                        code = test.get("code", "").lower()
                        setup = test.get("setup_requirements", "").lower()

                        if (f"import {library.lower()}" in code or
                            library.lower() in setup or
                            f"from {library.lower()}" in code):
                            library_found = True
                            break

                    if library_found:
                        break

                if not library_found:
                    missing_libraries.append(library)

            if missing_libraries:
                validation_details["missing_suggested_libraries"] = missing_libraries
                error_messages.append(f"Missing suggested test libraries: {', '.join(missing_libraries)}")
                is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid", validation_details


def validate_security_concerns(architecture_review: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    """Validate that security concerns in architecture review are properly addressed.

    Args:
        architecture_review: The architecture review data

    Returns:
        Tuple of (is_valid, error_message, validation_details)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []
    validation_details = {
        "missing_critical_security_aspects": [],
        "incomplete_security_concerns": [],
        "severity_issues": [],
        "total_security_concerns": 0,
        "properly_documented_concerns": 0
    }

    # Common OWASP Top 10 and other security concerns that should be considered
    common_security_aspects = [
        {"name": "Authentication", "keywords": ["auth", "login", "credentials", "password", "jwt", "token"]},
        {"name": "Authorization", "keywords": ["permission", "access control", "rbac", "acl", "privilege"]},
        {"name": "Data Validation", "keywords": ["input", "validation", "sanitize", "escape", "filter"]},
        {"name": "Injection Protection", "keywords": ["sql", "injection", "xss", "script", "sanitize", "escape"]},
        {"name": "Sensitive Data Exposure", "keywords": ["encrypt", "sensitive", "pii", "personal", "data", "leak"]},
        {"name": "CSRF Protection", "keywords": ["csrf", "forgery", "cross-site", "token"]},
        {"name": "Security Headers", "keywords": ["headers", "csp", "content-security", "hsts"]},
        {"name": "Session Management", "keywords": ["session", "cookie", "token", "timeout", "expire"]},
        {"name": "Error Handling", "keywords": ["error", "exception", "log", "trace", "debug"]},
        {"name": "Secure Communication", "keywords": ["tls", "ssl", "https", "encrypt", "certificate"]}
    ]

    # Extract security concerns from the architecture review
    security_concerns = architecture_review.get("security_concerns", [])
    validation_details["total_security_concerns"] = len(security_concerns)

    # Check if security concerns section exists and is not empty
    if not security_concerns:
        error_messages.append("No security concerns documented in architecture review")
        is_valid = False

        # Check if there are indications of security needs in other parts of the review
        other_sections = [
            "logical_gaps",
            "optimization_suggestions",
            "additional_considerations"
        ]

        security_keywords_found = False
        for section in other_sections:
            for item in architecture_review.get(section, []):
                item_text = item.get("description", "") + " " + item.get("recommendation", "")
                for aspect in common_security_aspects:
                    if any(keyword.lower() in item_text.lower() for keyword in aspect["keywords"]):
                        validation_details["missing_critical_security_aspects"].append(
                            f"{aspect['name']} (found in {section})"
                        )
                        security_keywords_found = True
                        break

        if security_keywords_found:
            error_messages.append(
                "Security concerns found in other sections but missing from security_concerns section"
            )

    # Check each security concern for completeness and proper severity
    for concern in security_concerns:
        # Check for required fields
        required_fields = ["description", "impact", "severity", "recommendation"]
        missing_fields = [field for field in required_fields if field not in concern or not concern[field]]

        if missing_fields:
            validation_details["incomplete_security_concerns"].append({
                "description": concern.get("description", "Unknown security concern"),
                "missing_fields": missing_fields
            })
            error_messages.append(
                f"Security concern '{concern.get('description', 'Unknown')}' is missing required fields: {', '.join(missing_fields)}"
            )
            is_valid = False
        else:
            validation_details["properly_documented_concerns"] += 1

        # Check severity appropriateness based on keywords
        description = concern.get("description", "").lower()
        impact = concern.get("impact", "").lower()
        severity = concern.get("severity", "Medium").lower()

        # Check if critical security issues have appropriate severity
        critical_keywords = ["critical", "severe", "high", "remote code execution", "rce", "data breach",
                            "authentication bypass", "privilege escalation", "unauthorized access"]

        critical_issue = any(keyword in description or keyword in impact for keyword in critical_keywords)
        if critical_issue and severity not in ["critical", "high"]:
            validation_details["severity_issues"].append({
                "description": concern.get("description", "Unknown security concern"),
                "current_severity": severity,
                "recommended_severity": "High or Critical"
            })
            error_messages.append(
                f"Security concern '{concern.get('description', 'Unknown')}' appears to be critical but has {severity} severity"
            )
            is_valid = False

    # Check for missing common security concerns
    if security_concerns:
        # Extract all text from security concerns
        all_security_text = " ".join([
            f"{concern.get('description', '')} {concern.get('impact', '')} {concern.get('recommendation', '')}"
            for concern in security_concerns
        ]).lower()

        # Check which common security aspects are not covered
        for aspect in common_security_aspects:
            aspect_covered = any(keyword.lower() in all_security_text for keyword in aspect["keywords"])
            if not aspect_covered:
                validation_details["missing_critical_security_aspects"].append(aspect["name"])

        # If critical security aspects are missing, add as error
        if validation_details["missing_critical_security_aspects"]:
            missing_aspects = ", ".join(validation_details["missing_critical_security_aspects"])
            error_messages.append(f"Missing critical security aspects in review: {missing_aspects}")
            is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid", validation_details


def _extract_keywords(text: str, min_length: int = 4) -> List[str]:
    """Extract meaningful keywords from text for pattern matching.

    Args:
        text: Text to extract keywords from
        min_length: Minimum length of keywords to include

    Returns:
        List of extracted keywords
    """
    # Split by non-alphanumeric characters and convert to lowercase
    words = re.findall(r'\b[a-zA-Z0-9]+\b', text.lower())

    # Filter out common words and short words
    common_words = {
        'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
        'with', 'by', 'about', 'from', 'as', 'into', 'like', 'through', 'after',
        'over', 'between', 'out', 'against', 'during', 'without', 'before',
        'under', 'around', 'among', 'than', 'within', 'along', 'across', 'behind',
        'beyond', 'plus', 'except', 'but', 'up', 'down', 'off', 'above', 'below',
        'should', 'would', 'could', 'may', 'might', 'must', 'can', 'will',
        'that', 'this', 'these', 'those', 'it', 'they', 'them', 'their', 'what',
        'which', 'who', 'whom', 'whose', 'when', 'where', 'why', 'how'
    }

    keywords = [word for word in words if word not in common_words and len(word) >= min_length]

    # Add special handling for security terminology - preserve important security terms even if short
    security_terms = {
        'xss', 'csrf', 'ssrf', 'sqli', 'rce', 'dos', 'jwt', 'auth', 'acl', 'rbac',
        'idor', 'cwe', 'owasp', 'csp', 'cors', 'tls', 'ssl', 'hash', 'salt',
        'mitm', 'csrf', 'xxe'
    }

    # Add specific security terms from the text, even if shorter than min_length
    security_keywords = re.findall(r'\b[a-zA-Z0-9]+\b', text.lower())
    security_matches = [word for word in security_keywords if word in security_terms]

    # Combine regular keywords with security terms
    keywords = list(set(keywords + security_matches))

    return keywords (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[12:551]
==agent_s3.tools.context_management.adaptive_config.config_templates:[12:551]
logger = logging.getLogger(__name__)

# Configuration schema for validation
CONFIG_SCHEMA = {
    "type": "object",
    "required": ["context_management"],
    "properties": {
        "context_management": {
            "type": "object",
            "properties": {
                "enabled": {"type": "boolean"},
                "background_enabled": {"type": "boolean"},
                "optimization_interval": {"type": "number", "minimum": 5, "maximum": 300},
                "embedding": {
                    "type": "object",
                    "properties": {
                        "chunk_size": {"type": "integer", "minimum": 100, "maximum": 3000},
                        "chunk_overlap": {"type": "integer", "minimum": 0, "maximum": 1000}
                    }
                },
                "search": {
                    "type": "object",
                    "properties": {
                        "bm25": {
                            "type": "object",
                            "properties": {
                                "k1": {"type": "number", "minimum": 0.1, "maximum": 5.0},
                                "b": {"type": "number", "minimum": 0.1, "maximum": 1.0}
                            }
                        }
                    }
                },
                "summarization": {
                    "type": "object",
                    "properties": {
                        "threshold": {"type": "integer", "minimum": 500, "maximum": 5000},
                        "compression_ratio": {"type": "number", "minimum": 0.1, "maximum": 0.9}
                    }
                },
                "importance_scoring": {
                    "type": "object",
                    "properties": {
                        "code_weight": {"type": "number", "minimum": 0.1, "maximum": 2.0},
                        "comment_weight": {"type": "number", "minimum": 0.1, "maximum": 2.0},
                        "metadata_weight": {"type": "number", "minimum": 0.1, "maximum": 2.0},
                        "framework_weight": {"type": "number", "minimum": 0.1, "maximum": 2.0}
                    }
                }
            }
        }
    }
}

# Base configuration templates
BASE_CONFIG_TEMPLATES = {
    "default": {
        "context_management": {
            "enabled": True,
            "background_enabled": True,
            "optimization_interval": 60,
            "embedding": {
                "chunk_size": 1000,
                "chunk_overlap": 200,
            },
            "search": {
                "bm25": {
                    "k1": 1.2,
                    "b": 0.75
                },
            },
            "summarization": {
                "threshold": 2000,
                "compression_ratio": 0.5
            },
            "importance_scoring": {
                "code_weight": 1.0,
                "comment_weight": 0.8,
                "metadata_weight": 0.7,
                "framework_weight": 0.9
            }
        }
    },

    # Small project template
    "small": {
        "context_management": {
            "enabled": True,
            "background_enabled": True,
            "optimization_interval": 30,
            "embedding": {
                "chunk_size": 800,
                "chunk_overlap": 150,
            },
            "search": {
                "bm25": {
                    "k1": 1.1,
                    "b": 0.7
                },
            },
            "summarization": {
                "threshold": 1500,
                "compression_ratio": 0.6
            },
            "importance_scoring": {
                "code_weight": 1.1,
                "comment_weight": 0.9,
                "metadata_weight": 0.8,
                "framework_weight": 0.8
            }
        }
    },

    # Large project template
    "large": {
        "context_management": {
            "enabled": True,
            "background_enabled": True,
            "optimization_interval": 90,
            "embedding": {
                "chunk_size": 1200,
                "chunk_overlap": 250,
            },
            "search": {
                "bm25": {
                    "k1": 1.3,
                    "b": 0.8
                },
            },
            "summarization": {
                "threshold": 2500,
                "compression_ratio": 0.4
            },
            "importance_scoring": {
                "code_weight": 1.0,
                "comment_weight": 0.7,
                "metadata_weight": 0.7,
                "framework_weight": 1.0
            }
        }
    },

    # Project type specific templates
    "web_frontend": {
        "context_management": {
            "optimization_interval": 45,
            "embedding": {
                "chunk_size": 800,
                "chunk_overlap": 250,
            },
            "importance_scoring": {
                "code_weight": 1.1,
                "framework_weight": 1.2,
                "metadata_weight": 0.8
            }
        }
    },

    "web_backend": {
        "context_management": {
            "embedding": {
                "chunk_size": 1200,
                "chunk_overlap": 200,
            },
            "search": {
                "bm25": {
                    "k1": 1.5,
                    "b": 0.75
                }
            },
            "importance_scoring": {
                "code_weight": 1.2,
                "metadata_weight": 0.6
            }
        }
    },

    "data_science": {
        "context_management": {
            "embedding": {
                "chunk_size": 1500,
                "chunk_overlap": 300,
            },
            "importance_scoring": {
                "comment_weight": 1.0,
                "metadata_weight": 0.9
            }
        }
    },

    "cli_tool": {
        "context_management": {
            "embedding": {
                "chunk_size": 900,
                "chunk_overlap": 180,
            },
            "importance_scoring": {
                "code_weight": 1.3,
                "metadata_weight": 0.6
            }
        }
    },

    "library": {
        "context_management": {
            "embedding": {
                "chunk_size": 1100,
                "chunk_overlap": 220,
            },
            "importance_scoring": {
                "code_weight": 1.1,
                "comment_weight": 1.0,
                "metadata_weight": 0.7
            }
        }
    },

    # Language specific templates
    "python": {
        "context_management": {
            "embedding": {
                "chunk_size": 900,  # Python tends to be more concise
            },
            "importance_scoring": {
                "code_weight": 1.0,
                "comment_weight": 0.9
            }
        }
    },

    "javascript": {
        "context_management": {
            "embedding": {
                "chunk_size": 950,
            },
            "search": {
                "bm25": {
                    "k1": 1.3
                }
            }
        }
    },

    "typescript": {
        "context_management": {
            "embedding": {
                "chunk_size": 950,
            },
            "search": {
                "bm25": {
                    "k1": 1.3
                }
            },
            "importance_scoring": {
                "code_weight": 1.1,
                "comment_weight": 0.85
            }
        }
    },

    "java": {
        "context_management": {
            "embedding": {
                "chunk_size": 1200,  # Java tends to be more verbose
            },
            "search": {
                "bm25": {
                    "b": 0.8  # More length normalization for Java
                }
            }
        }
    },

    "csharp": {
        "context_management": {
            "embedding": {
                "chunk_size": 1200,  # C# tends to be more verbose
            },
            "search": {
                "bm25": {
                    "b": 0.8
                }
            }
        }
    }
}


class ConfigTemplateManager:
    """
    Manages configuration templates and provides validation for configuration parameters.
    """

    def __init__(self):
        """Initialize the configuration template manager."""
        self.templates = BASE_CONFIG_TEMPLATES
        self.schema = CONFIG_SCHEMA

    def get_default_config(self) -> Dict[str, Any]:
        """
        Get the default configuration template.

        Returns:
            Default configuration template
        """
        return self.templates["default"].copy()

    def get_template(self, template_name: str) -> Dict[str, Any]:
        """
        Get a configuration template by name.

        Args:
            template_name: Name of the template

        Returns:
            Configuration template dictionary

        Raises:
            ValueError: If template name is not found
        """
        if template_name not in self.templates:
            raise ValueError(f"Template {template_name} not found")

        return self.templates[template_name].copy()

    def validate_config(self, config: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """
        Validate a configuration against the schema.

        Args:
            config: Configuration dictionary to validate

        Returns:
            Tuple of (is_valid, error_messages)
        """
        try:
            jsonschema.validate(instance=config, schema=self.schema)
            return True, []
        except jsonschema.exceptions.ValidationError as e:
            # Extract error messages
            path = " -> ".join([str(p) for p in e.path])
            message = f"Validation error at {path}: {e.message}"
            return False, [message]

    def merge_templates(self, templates: List[str]) -> Dict[str, Any]:
        """
        Merge multiple templates into a single configuration.

        Templates are applied in order, with later templates overriding earlier ones.
        Always starts with the default template.

        Args:
            templates: List of template names to merge

        Returns:
            Merged configuration dictionary

        Raises:
            ValueError: If any template name is not found
        """
        result = self.get_default_config()

        for template_name in templates:
            if template_name not in self.templates:
                raise ValueError(f"Template {template_name} not found")

            template = self.templates[template_name]
            self._deep_merge(result, template)

        return result

    def create_config_for_project(
        self,
        project_size: str,
        project_type: str,
        primary_language: str
    ) -> Dict[str, Any]:
        """
        Create a configuration optimized for a specific project profile.

        Args:
            project_size: Size category (small, medium, large)
            project_type: Type of project (web_frontend, web_backend, etc.)
            primary_language: Primary programming language

        Returns:
            Optimized configuration dictionary
        """
        templates = ["default"]

        # Add size template if valid
        if project_size in ["small", "large"]:
            templates.append(project_size)

        # Add project type template if valid
        if project_type in self.templates:
            templates.append(project_type)

        # Add language template if valid
        if primary_language in self.templates:
            templates.append(primary_language)

        # Merge templates
        config = self.merge_templates(templates)

        # Validate merged config
        is_valid, errors = self.validate_config(config)
        if not is_valid:
            logger.warning(f"Generated configuration has validation errors: {errors}")
            # Fall back to default if invalid
            return self.get_default_config()

        return config

    def _deep_merge(self, target: Dict[str, Any], source: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recursively merge source dictionary into target.

        Args:
            target: Target dictionary to merge into
            source: Source dictionary to merge from

        Returns:
            Merged dictionary (same reference as target)
        """
        for key, value in source.items():
            if key in target and isinstance(target[key], dict) and isinstance(value, dict):
                # Recursively merge nested dictionaries
                self._deep_merge(target[key], value)
            else:
                # Override or add value
                target[key] = value

        return target

    def register_template(self, name: str, template: Dict[str, Any]) -> None:
        """
        Register a new configuration template.

        Args:
            name: Template name
            template: Template configuration dictionary

        Raises:
            ValueError: If template is invalid
        """
        # Validate template
        is_valid, errors = self.validate_config(template)
        if not is_valid:
            raise ValueError(f"Invalid template: {errors}")

        # Register template
        self.templates[name] = template

    def load_templates_from_file(self, file_path: str) -> int:
        """
        Load templates from a JSON file.

        Args:
            file_path: Path to JSON file with templates

        Returns:
            Number of templates loaded

        Raises:
            FileNotFoundError: If file doesn't exist
            ValueError: If file contains invalid JSON or templates
        """
        try:
            with open(file_path, 'r') as f:
                templates = json.load(f)

            if not isinstance(templates, dict):
                raise ValueError("Templates file must contain a JSON object")

            count = 0
            for name, template in templates.items():
                self.register_template(name, template)
                count += 1

            return count
        except FileNotFoundError:
            raise FileNotFoundError(f"Templates file not found: {file_path}")
        except json.JSONDecodeError:
            raise ValueError(f"Invalid JSON in templates file: {file_path}")

    def save_templates_to_file(self, file_path: str) -> None:
        """
        Save all templates to a JSON file.

        Args:
            file_path: Path to save templates

        Raises:
            IOError: If file cannot be written
        """
        try:
            with open(file_path, 'w') as f:
                json.dump(self.templates, f, indent=2)
        except IOError as e:
            raise IOError(f"Failed to save templates to {file_path}: {e}")

    def create_new_template(
        self,
        name: str,
        base_template: str,
        overrides: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Create a new template based on an existing one with overrides.

        Args:
            name: Name for the new template
            base_template: Name of the template to base on
            overrides: Dictionary of values to override

        Returns:
            The new template

        Raises:
            ValueError: If base template doesn't exist or result is invalid
        """
        if base_template not in self.templates:
            raise ValueError(f"Base template {base_template} not found")

        # Start with base template
        new_template = self.get_template(base_template)

        # Apply overrides
        self._deep_merge(new_template, overrides)

        # Validate new template
        is_valid, errors = self.validate_config(new_template)
        if not is_valid:
            raise ValueError(f"Invalid template after overrides: {errors}")

        # Register new template
        self.templates[name] = new_template

        return new_template (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.adaptive_config_manager 4:[20:511]
==agent_s3.tools.context_management.adaptive_config.adaptive_config_manager:[20:511]
logger = logging.getLogger(__name__)


class AdaptiveConfigManager:
    """
    Manages the adaptive configuration lifecycle for context management.

    This class integrates project profiling, configuration templates, and
    performance metrics to create and optimize configurations.
    """

    def __init__(
        self,
        repo_path: str,
        config_dir: Optional[str] = None,
        metrics_dir: Optional[str] = None
    ):
        """
        Initialize the adaptive configuration manager.

        Args:
            repo_path: Path to the repository
            config_dir: Optional directory for configuration storage
            metrics_dir: Optional directory for metrics storage
        """
        self.repo_path = repo_path
        self.config_dir = config_dir or os.path.join(repo_path, ".agent_s3", "config")
        self.metrics_dir = metrics_dir or os.path.join(repo_path, ".agent_s3", "metrics")

        # Create directories if they don't exist
        os.makedirs(self.config_dir, exist_ok=True)
        os.makedirs(self.metrics_dir, exist_ok=True)

        # Initialize components
        self.profiler = ProjectProfiler(repo_path)
        self.template_manager = ConfigTemplateManager()
        self.metrics_collector = MetricsCollector(self.metrics_dir)

        # Current active configuration
        self.active_config = {}
        self.config_lock = threading.RLock()
        self.config_version = 0

        # Configuration optimization
        self.last_optimization_time = 0
        self.optimization_interval = 3600  # Default: optimize once per hour
        self.optimization_in_progress = False

        # Initialize with a default config
        self._initialize_configuration()

    def _initialize_configuration(self) -> None:
        """Initialize configuration based on repository profile."""
        try:
            # Check if we have a saved configuration
            config_path = os.path.join(self.config_dir, "active_config.json")
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    loaded_config = json.load(f)

                logger.info("Loaded existing configuration")
                with self.config_lock:
                    self.active_config = loaded_config
                    self.config_version += 1
                return

            # No existing config, create a new one based on repository profile
            logger.info("No existing configuration found, analyzing repository")
            self._create_initial_configuration()

        except Exception as e:
            logger.error(f"Error initializing configuration: {e}")
            logger.info("Falling back to default configuration")

            # Fall back to default configuration
            with self.config_lock:
                self.active_config = self.template_manager.get_default_config()
                self.config_version += 1

    def _create_initial_configuration(self) -> None:
        """Create initial configuration based on repository profile."""
        try:
            # Analyze repository
            repo_metrics = self.profiler.analyze_repository()

            # Generate configuration based on repository characteristics
            config = self.profiler.get_recommended_config()

            # Validate configuration
            is_valid, errors = self.template_manager.validate_config(config)
            if not is_valid:
                logger.warning(f"Generated configuration has validation errors: {errors}")
                logger.info("Falling back to default configuration")
                config = self.template_manager.get_default_config()

            # Set as active configuration
            with self.config_lock:
                self.active_config = config
                self.config_version += 1

            # Save configuration
            self._save_configuration()

            logger.info(f"Created initial configuration for {repo_metrics.get('project_type')} project")

        except Exception as e:
            logger.error(f"Error creating initial configuration: {e}")
            logger.info("Falling back to default configuration")

            # Fall back to default configuration
            with self.config_lock:
                self.active_config = self.template_manager.get_default_config()
                self.config_version += 1

    def get_current_config(self) -> Dict[str, Any]:
        """
        Get the current active configuration.

        Returns:
            Copy of the active configuration
        """
        with self.config_lock:
            return copy.deepcopy(self.active_config)

    def get_config_version(self) -> int:
        """
        Get the current configuration version number.

        Returns:
            Configuration version number
        """
        with self.config_lock:
            return self.config_version

    def update_configuration(self, new_config: Dict[str, Any], reason: str) -> bool:
        """
        Update the active configuration.

        Args:
            new_config: New configuration to apply
            reason: Reason for the update

        Returns:
            True if update was successful, False otherwise
        """
        # Validate new configuration
        is_valid, errors = self.template_manager.validate_config(new_config)
        if not is_valid:
            logger.error(f"Invalid configuration: {errors}")
            return False

        # Apply update
        with self.config_lock:
            self.active_config = new_config
            self.config_version += 1

        # Save configuration
        self._save_configuration(reason)

        logger.info(f"Updated configuration (v{self.config_version}): {reason}")

        return True

    def _save_configuration(self, reason: str = "initial") -> None:
        """
        Save current configuration to disk.

        Args:
            reason: Reason for the configuration update
        """
        try:
            # Save current active configuration
            config_path = os.path.join(self.config_dir, "active_config.json")
            with open(config_path, 'w') as f:
                json.dump(self.active_config, f, indent=2)

            # Save a versioned copy with metadata
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            versioned_config = {
                "config": copy.deepcopy(self.active_config),
                "metadata": {
                    "version": self.config_version,
                    "timestamp": timestamp,
                    "reason": reason
                }
            }

            versioned_path = os.path.join(
                self.config_dir,
                f"config_v{self.config_version}_{timestamp}.json"
            )

            with open(versioned_path, 'w') as f:
                json.dump(versioned_config, f, indent=2)

            # Clean up old versioned configs (keep last 10)
            self._cleanup_old_configs()

        except Exception as e:
            logger.error(f"Error saving configuration: {e}")

    def _cleanup_old_configs(self) -> None:
        """Clean up old versioned configurations."""
        try:
            # Get all versioned config files
            config_files = []
            for filename in os.listdir(self.config_dir):
                if filename.startswith("config_v") and filename.endswith(".json"):
                    file_path = os.path.join(self.config_dir, filename)
                    config_files.append((filename, os.path.getmtime(file_path), file_path))

            # Keep only the latest 10
            if len(config_files) > 10:
                # Sort by modification time (newest first)
                config_files.sort(key=lambda x: x[1], reverse=True)

                # Delete older files
                for _, _, file_path in config_files[10:]:
                    os.remove(file_path)

        except Exception as e:
            logger.error(f"Error cleaning up old configurations: {e}")

    def check_optimization_needed(self) -> bool:
        """
        Check if configuration optimization is needed.

        Returns:
            True if optimization is needed, False otherwise
        """
        # Don't optimize if already in progress
        if self.optimization_in_progress:
            return False

        current_time = time.time()
        time_since_last = current_time - self.last_optimization_time

        # Get optimization interval from current config or use default
        interval = self.active_config.get("context_management", {}) \
                                    .get("optimization_interval", self.optimization_interval)

        return time_since_last >= interval

    def optimize_configuration(self) -> bool:
        """
        Optimize configuration based on performance metrics.

        Returns:
            True if optimization was performed, False otherwise
        """
        if self.optimization_in_progress:
            return False

        try:
            self.optimization_in_progress = True

            # Get current configuration
            current_config = self.get_current_config()

            # Get recommendations based on performance metrics
            recommendations = self.metrics_collector.recommend_config_improvements(current_config)

            if recommendations.get("status") == "no_data" or not recommendations.get("recommendations"):
                logger.info("No configuration improvements recommended at this time")
                return False

            # Apply recommended improvements
            new_config = copy.deepcopy(current_config)
            applied_changes = []

            for rec in recommendations.get("recommendations", []):
                if rec.get("confidence") not in ["high", "medium"]:
                    continue  # Only apply high and medium confidence recommendations

                param_path = rec.get("suggested_change", {}).get("parameter")
                new_value = rec.get("suggested_change", {}).get("suggested_value")

                if not param_path or new_value is None:
                    continue

                # Apply change to config
                self._update_config_param(new_config, param_path, new_value)
                applied_changes.append({
                    "parameter": param_path,
                    "old_value": rec.get("suggested_change", {}).get("current_value"),
                    "new_value": new_value,
                    "reason": rec.get("recommendation")
                })

            # If changes were applied, update configuration
            if applied_changes:
                reason = f"Automatic optimization with {len(applied_changes)} improvements"
                if self.update_configuration(new_config, reason):
                    logger.info(f"Applied {len(applied_changes)} configuration improvements")
                    self.last_optimization_time = time.time()
                    return True

            return False

        except Exception as e:
            logger.error(f"Error optimizing configuration: {e}")
            return False

        finally:
            self.optimization_in_progress = False

    def _update_config_param(self, config: Dict[str, Any], param_path: str, value: Any) -> None:
        """
        Update a parameter in the configuration.

        Args:
            config: Configuration to update
            param_path: Parameter path (dot notation)
            value: New parameter value
        """
        parts = param_path.split('.')
        current = config

        # Navigate to the parent object
        for part in parts[:-1]:
            if part not in current:
                current[part] = {}
            current = current[part]

        # Update the parameter
        current[parts[-1]] = value

    def log_context_performance(
        self,
        task_type: str,
        relevance_score: float
    ) -> None:
        """
        Log context performance for the current configuration.

        Args:
            task_type: Type of task
            relevance_score: Relevance score (0-1)
        """
        try:
            self.metrics_collector.log_context_relevance(
                task_type=task_type,
                relevance_score=relevance_score,
                config_used=self.get_current_config()
            )
        except Exception as e:
            logger.error(f"Error logging context performance: {e}")

    def log_token_usage(
        self,
        total_tokens: int,
        available_tokens: int,
        allocated_tokens: Dict[str, int]
    ) -> None:
        """
        Log token usage metrics.

        Args:
            total_tokens: Total tokens used
            available_tokens: Available token budget
            allocated_tokens: Dictionary mapping context sections to token counts
        """
        try:
            self.metrics_collector.log_token_usage(
                total_tokens=total_tokens,
                available_tokens=available_tokens,
                allocated_tokens=allocated_tokens
            )

            # Check if optimization is needed
            if self.check_optimization_needed():
                # Run optimization in a separate thread
                threading.Thread(target=self.optimize_configuration).start()

        except Exception as e:
            logger.error(f"Error logging token usage: {e}")

    def get_config_history(self) -> List[Dict[str, Any]]:
        """
        Get configuration history.

        Returns:
            List of historical configurations with metadata
        """
        history = []

        try:
            for filename in os.listdir(self.config_dir):
                if filename.startswith("config_v") and filename.endswith(".json"):
                    file_path = os.path.join(self.config_dir, filename)
                    with open(file_path, 'r') as f:
                        config_data = json.load(f)

                    if "metadata" in config_data:
                        history.append({
                            "version": config_data["metadata"].get("version"),
                            "timestamp": config_data["metadata"].get("timestamp"),
                            "reason": config_data["metadata"].get("reason"),
                            "file": filename
                        })

            # Sort by version (newest first)
            history.sort(key=lambda x: x.get("version", 0), reverse=True)

        except Exception as e:
            logger.error(f"Error getting configuration history: {e}")

        return history

    def get_performance_summary(self) -> Dict[str, Any]:
        """
        Get a summary of performance metrics.

        Returns:
            Dictionary with performance metrics summary
        """
        try:
            summary = self.metrics_collector.get_metrics_summary()

            # Add config history
            history = self.get_config_history()
            if history:
                summary["config_history"] = {
                    "total_versions": len(history),
                    "latest_version": history[0].get("version") if history else 0,
                    "latest_update": history[0].get("timestamp") if history else None,
                    "latest_reason": history[0].get("reason") if history else None
                }

            return summary
        except Exception as e:
            logger.error(f"Error getting performance summary: {e}")
            return {"error": str(e)}

    def reset_to_version(self, version: int) -> bool:
        """
        Reset configuration to a specific version.

        Args:
            version: Configuration version to reset to

        Returns:
            True if reset was successful, False otherwise
        """
        try:
            # Find the configuration file for the specified version
            target_file = None
            for filename in os.listdir(self.config_dir):
                if filename.startswith(f"config_v{version}_") and filename.endswith(".json"):
                    target_file = os.path.join(self.config_dir, filename)
                    break

            if not target_file:
                logger.error(f"Configuration version {version} not found")
                return False

            # Load the configuration
            with open(target_file, 'r') as f:
                config_data = json.load(f)

            if "config" not in config_data:
                logger.error(f"Invalid configuration data in {target_file}")
                return False

            # Update configuration
            reason = f"Reset to version {version}"
            return self.update_configuration(config_data["config"], reason)

        except Exception as e:
            logger.error(f"Error resetting configuration to version {version}: {e}")
            return False

    def reset_to_default(self) -> bool:
        """
        Reset configuration to default profile-based configuration.

        Returns:
            True if reset was successful, False otherwise
        """
        try:
            # Generate new configuration based on repository characteristics
            repo_metrics = self.profiler.analyze_repository()
            config = self.profiler.get_recommended_config()

            # Update configuration
            reason = "Reset to default profile-based configuration"
            return self.update_configuration(config, reason)

        except Exception as e:
            logger.error(f"Error resetting to default configuration: {e}")
            return False (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.incremental_indexing_adapter 3:[18:425]
==agent_s3.tools.incremental_indexing_adapter:[18:425]
logger = logging.getLogger(__name__)

class IncrementalIndexingAdapter:
    """
    Adapter class to integrate the incremental indexing system with CodeAnalysisTool.

    This class provides a compatibility layer that allows the CodeAnalysisTool to use
    the incremental indexing system without significant changes to its API.
    """

    def __init__(self, code_analysis_tool, static_analyzer=None, config=None):
        """
        Initialize the incremental indexing adapter.

        Args:
            code_analysis_tool: Instance of CodeAnalysisTool
            static_analyzer: Optional instance of StaticAnalyzer
            config: Configuration dictionary
        """
        self.code_analysis_tool = code_analysis_tool
        self.static_analyzer = static_analyzer
        self.config = config or {}

        # Create indexer with dependencies from CodeAnalysisTool
        self.indexer = IncrementalIndexer(
            storage_path=self._get_storage_path(),
            embedding_client=getattr(code_analysis_tool, 'embedding_client', None),
            file_tool=getattr(code_analysis_tool, 'file_tool', None),
            static_analyzer=self.static_analyzer,
            config=self.config
        )

        # Create repository event system
        self.repo_event_system = RepositoryEventSystem()

        # File tracking for watch events
        self.file_change_tracker = self.indexer.file_change_tracker

        # Watch ID for cleanup
        self._watch_id = None

        # Cache overrides
        self._original_search_code = None
        self._original_embedding_cache = {}

        logger.info("Initialized incremental indexing adapter")

    def _get_storage_path(self) -> str:
        """
        Get storage path for index data.

        Returns:
            Path to store indexing data
        """
        # Try to use the same storage path as CodeAnalysisTool if available
        try:
            if hasattr(self.code_analysis_tool, '_cache_dir'):
                cache_dir = getattr(self.code_analysis_tool, '_cache_dir')
                if cache_dir:
                    return os.path.join(cache_dir, "incremental_index")
        except Exception as e:
            logger.error(f"Error accessing cache directory: {e}")

        # Default to a hidden directory in the user's home
        home = os.path.expanduser("~")
        return os.path.join(home, ".agent_s3", "incremental_index")

    def initialize(self) -> bool:
        """
        Initialize the adapter and connect to CodeAnalysisTool.

        Returns:
            True if successful, False otherwise
        """
        try:
            # Store original search_code method for chaining
            if hasattr(self.code_analysis_tool, 'search_code'):
                self._original_search_code = self.code_analysis_tool.search_code

            # Store original embedding cache
            if hasattr(self.code_analysis_tool, '_embedding_cache'):
                self._original_embedding_cache = getattr(self.code_analysis_tool, '_embedding_cache')

            # Inject our search method
            if hasattr(self.code_analysis_tool, 'search_code'):
                setattr(self.code_analysis_tool, 'search_code', self.search_code_wrapper)

            # Add our index update method
            if not hasattr(self.code_analysis_tool, 'update_index_incrementally'):
                setattr(self.code_analysis_tool, 'update_index_incrementally', self.update_index)

            # Add index stats method
            if not hasattr(self.code_analysis_tool, 'get_index_stats'):
                setattr(self.code_analysis_tool, 'get_index_stats', self.get_index_stats)

            logger.info("Successfully initialized incremental indexing adapter")
            return True
        except Exception as e:
            logger.error(f"Error initializing incremental indexing adapter: {e}")
            return False

    def enable_watch_mode(self, repo_path: str) -> str:
        """
        Enable watch mode for a repository to automatically update the index.

        Args:
            repo_path: Path to the repository to watch

        Returns:
            Watch ID or empty string if failed
        """
        try:
            # Stop any existing watch
            if self._watch_id:
                self.repo_event_system.stop_watching(self._watch_id)
                self._watch_id = None

            # Define callback for repository events
            def repo_event_callback(event_type: str, file_path: str):
                try:
                    # Only process changes to code files
                    ext = os.path.splitext(file_path)[1].lower()
                    extensions = ['.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.java', '.go', '.php']

                    if ext not in extensions:
                        return

                    logger.debug(f"Repository event: {event_type} - {file_path}")

                    # Only update on create or modify events
                    if event_type in ['create', 'modify']:
                        # Use a background thread to avoid blocking
                        thread = threading.Thread(
                            target=self.update_index,
                            args=([file_path],),
                            kwargs={'analyze_dependencies': True}
                        )
                        thread.daemon = True
                        thread.start()
                except Exception as e:
                    logger.error(f"Error in repository event callback: {e}")

            # Start watching
            extensions = ['.py', '.js', '.jsx', '.ts', '.tsx', '.html', '.css', '.java', '.go', '.php']
            watch_id = self.repo_event_system.watch_repository(
                repo_path=repo_path,
                callback=repo_event_callback,
                file_patterns=[f"*{ext}" for ext in extensions],
                recursive=True
            )

            if watch_id:
                self._watch_id = watch_id
                logger.info(f"Started watching repository: {repo_path}")
                return watch_id
            else:
                logger.error(f"Failed to start watching repository: {repo_path}")
                return ""
        except Exception as e:
            logger.error(f"Error enabling watch mode: {e}")
            return ""

    def disable_watch_mode(self) -> bool:
        """
        Disable watch mode for repositories.

        Returns:
            True if successful, False otherwise
        """
        if not self._watch_id:
            return True

        try:
            result = self.repo_event_system.stop_watching(self._watch_id)
            if result:
                self._watch_id = None
                logger.info("Stopped watching repository")
            return result
        except Exception as e:
            logger.error(f"Error disabling watch mode: {e}")
            return False

    def update_index(
        self,
        file_paths: Optional[List[str]] = None,
        analyze_dependencies: bool = False,
        force_full: bool = False,
        progress_callback: Optional[Callable] = None
    ) -> Dict[str, Any]:
        """
        Update the code search index incrementally.

        Args:
            file_paths: Optional list of file paths to update specifically
            analyze_dependencies: Whether to analyze dependencies of changed files
            force_full: Force a full reindex
            progress_callback: Optional callback for progress updates

        Returns:
            Dictionary with indexing statistics
        """
        try:
            # Determine workspace root
            workspace_root = None
            if hasattr(self.code_analysis_tool, 'file_tool') and hasattr(self.code_analysis_tool.file_tool, 'workspace_root'):
                workspace_root = self.code_analysis_tool.file_tool.workspace_root

            # If specific files are provided
            if file_paths and not force_full:
                logger.info(f"Updating index for {len(file_paths)} specific files")

                # If dependency analysis is enabled and static analyzer is available
                if analyze_dependencies and self.static_analyzer:
                    # Get dependency graph if not already built
                    if not hasattr(self.indexer.dependency_analyzer, 'forward_deps') or not self.indexer.dependency_analyzer.forward_deps:
                        if hasattr(self.static_analyzer, 'analyze_project') and workspace_root:
                            dependency_graph = self.static_analyzer.analyze_project(workspace_root)
                            self.indexer.dependency_analyzer.build_from_dependency_graph(dependency_graph)

                    # Calculate impact scope
                    impact_results = self.indexer.dependency_analyzer.calculate_impact_scope(file_paths)
                    impacted_files = impact_results.get('prioritized_impacts', [])

                    # Combined list of files to update (changed + impacted)
                    combined_files = list(set(file_paths + impacted_files))

                    logger.info(f"Updating {len(file_paths)} changed files and {len(impacted_files)} impacted files")

                    # Update files
                    return self.indexer.update_files(combined_files, progress_callback)
                else:
                    # Update only specified files
                    return self.indexer.update_files(file_paths, progress_callback)
            else:
                # Full index update
                logger.info(f"Performing {'full' if force_full else 'incremental'} index update")

                if workspace_root:
                    return self.indexer.index_repository(
                        workspace_root,
                        force_full=force_full,
                        progress_callback=progress_callback
                    )
                else:
                    logger.error("Workspace root not available")
                    return {
                        "status": "error",
                        "message": "Workspace root not available",
                        "files_indexed": 0
                    }
        except Exception as e:
            logger.error(f"Error updating index: {e}")
            return {
                "status": "error",
                "message": str(e),
                "files_indexed": 0
            }

    def search_code_wrapper(self, query: str, *args, **kwargs) -> List[Dict[str, Any]]:
        """
        Wrapper for CodeAnalysisTool.search_code that uses the incremental index.

        Args:
            query: Search query
            *args: Passed through to original search_code
            **kwargs: Passed through to original search_code

        Returns:
            List of search results
        """
        try:
            # Check if we have a query embedding
            query_embedding = None

            # Try to get query embedding from CodeAnalysisTool
            if hasattr(self.code_analysis_tool, 'embedding_client'):
                embedding_client = self.code_analysis_tool.embedding_client
                if embedding_client and hasattr(embedding_client, 'get_embedding'):
                    query_embedding = embedding_client.get_embedding(query)

            # If we have a query embedding, search using incremental index
            if query_embedding and self.indexer.partition_manager:
                logger.debug(f"Searching incremental index for: {query}")

                # Search across all partitions
                results = self.indexer.partition_manager.search_all_partitions(
                    query_embedding=query_embedding,
                    top_k=kwargs.get('top_k', 10) or 10
                )

                # Format results to match CodeAnalysisTool output
                formatted_results = []

                for result in results:
                    file_path = result['file_path']
                    score = result['score']
                    metadata = result.get('metadata', {})

                    # If file_tool is available, read file content
                    content = metadata.get('content', '')
                    if not content and hasattr(self.code_analysis_tool, 'file_tool'):
                        file_tool = self.code_analysis_tool.file_tool
                        if file_tool and hasattr(file_tool, 'read_file'):
                            content = file_tool.read_file(file_path)

                    formatted_results.append({
                        'file': file_path,
                        'score': score,
                        'content': content,
                        'metadata': metadata
                    })

                # If we didn't get enough results, fall back to original search
                if len(formatted_results) < kwargs.get('top_k', 10) and self._original_search_code:
                    logger.debug("Falling back to original search_code")

                    original_results = self._original_search_code(query, *args, **kwargs)

                    # Combine results, avoiding duplicates
                    existing_files = {r['file'] for r in formatted_results}
                    for result in original_results:
                        if result['file'] not in existing_files:
                            formatted_results.append(result)
                            existing_files.add(result['file'])

                    # Sort by score
                    formatted_results.sort(key=lambda x: x['score'], reverse=True)

                    # Trim to top-k
                    top_k = kwargs.get('top_k', 10) or 10
                    formatted_results = formatted_results[:top_k]

                return formatted_results
            elif self._original_search_code:
                # Fall back to original search_code
                return self._original_search_code(query, *args, **kwargs)
            else:
                logger.error("Original search_code method not available")
                return []
        except Exception as e:
            logger.error(f"Error in search_code_wrapper: {e}")

            # Fall back to original search_code
            if self._original_search_code:
                return self._original_search_code(query, *args, **kwargs)
            return []

    def get_index_stats(self) -> Dict[str, Any]:
        """
        Get statistics about the incremental index.

        Returns:
            Dictionary with index statistics
        """
        try:
            stats = self.indexer.get_index_stats() if self.indexer else {}

            # Add watch mode status
            stats['watch_mode'] = {
                'enabled': self._watch_id is not None,
                'watch_id': self._watch_id
            }

            return stats
        except Exception as e:
            logger.error(f"Error getting index stats: {e}")
            return {
                "error": str(e)
            }

    def teardown(self) -> bool:
        """
        Tear down the adapter and restore original CodeAnalysisTool state.

        Returns:
            True if successful, False otherwise
        """
        try:
            # Restore original search_code method
            if self._original_search_code and hasattr(self.code_analysis_tool, 'search_code'):
                setattr(self.code_analysis_tool, 'search_code', self._original_search_code)

            # Disable watch mode
            self.disable_watch_mode()

            logger.info("Successfully torn down incremental indexing adapter")
            return True
        except Exception as e:
            logger.error(f"Error tearing down incremental indexing adapter: {e}")
            return False


def install_incremental_indexing(code_analysis_tool, static_analyzer=None, config=None) -> IncrementalIndexingAdapter:
    """
    Install incremental indexing into an existing CodeAnalysisTool instance.

    Args:
        code_analysis_tool: Instance of CodeAnalysisTool
        static_analyzer: Optional instance of StaticAnalyzer
        config: Configuration dictionary

    Returns:
        Configured IncrementalIndexingAdapter instance
    """
    adapter = IncrementalIndexingAdapter(code_analysis_tool, static_analyzer, config)
    adapter.initialize()
    return adapter (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.repository_event_system 3:[14:324]
==agent_s3.tools.repository_event_system:[14:324]
logger = logging.getLogger(__name__)

# Try to import watchdog for file system monitoring
try:
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler, FileSystemEvent
    WATCHDOG_AVAILABLE = True
except ImportError:
    logger.warning("Watchdog not available. Real-time file monitoring won't work.")
    WATCHDOG_AVAILABLE = False
    # Define stub classes for type checking
    class Observer:
        def __init__(self, *args, **kwargs): pass
        def schedule(self, *args, **kwargs): pass
        def start(self): pass
        def stop(self): pass
        def join(self): pass

    class FileSystemEventHandler:
        def dispatch(self, event): pass

    class FileSystemEvent:
        def __init__(self, src_path=""):
            self.src_path = src_path
            self.is_directory = False
            self.event_type = "unknown"

# Event types
CREATE_EVENT = "create"
MODIFY_EVENT = "modify"
DELETE_EVENT = "delete"
MOVE_EVENT = "move"

class RepositoryEventHandler(FileSystemEventHandler):
    """
    Custom handler for repository file events.

    Implements debouncing and filtering for more efficient event processing.
    """

    def __init__(
        self,
        callback: Callable[[str, str], None],
        file_patterns: List[str] = None,
        debounce_seconds: float = 1.0,
        ignore_dirs: List[str] = None
    ):
        """
        Initialize the repository event handler.

        Args:
            callback: Function to call with (event_type, file_path) when a relevant change occurs
            file_patterns: List of file patterns to monitor (e.g., "*.py", "*.js")
            debounce_seconds: Time in seconds to wait before firing events (to avoid duplicates)
            ignore_dirs: List of directory patterns to ignore (e.g., "node_modules", "__pycache__")
        """
        self.callback = callback
        self.file_patterns = file_patterns or ["*.*"]
        self.debounce_seconds = debounce_seconds
        self.ignore_dirs = ignore_dirs or ["node_modules", "__pycache__", ".git", "venv", "env", "build", "dist"]

        # Event tracking for debouncing
        self._pending_events: Dict[str, Dict[str, Any]] = {}
        self._last_event_time = 0
        self._process_timer = None
        self._event_lock = threading.Lock()

    def dispatch(self, event: FileSystemEvent) -> None:
        """
        Process a file system event.

        Args:
            event: The file system event to process
        """
        if not hasattr(event, 'src_path'):
            return

        # Skip directories
        if getattr(event, 'is_directory', False):
            return

        # Check if in ignored directories
        file_path = event.src_path
        for ignore_dir in self.ignore_dirs:
            if ignore_dir in file_path.split(os.path.sep):
                return

        # Check file pattern matching
        file_matches = False
        for pattern in self.file_patterns:
            if pattern == "*.*" or file_path.endswith(pattern.replace("*", "")):
                file_matches = True
                break

        if not file_matches:
            return

        # Determine event type
        event_type = None
        if hasattr(event, 'event_type'):
            event_type = event.event_type
        else:
            # Try to infer type from class name
            class_name = event.__class__.__name__.lower()
            if 'create' in class_name:
                event_type = CREATE_EVENT
            elif 'modify' in class_name:
                event_type = MODIFY_EVENT
            elif 'delete' in class_name:
                event_type = DELETE_EVENT
            elif 'move' in class_name:
                event_type = MOVE_EVENT

        if not event_type:
            event_type = MODIFY_EVENT  # Default to modify

        # Add to pending events with lock
        with self._event_lock:
            self._pending_events[file_path] = {
                'event_type': event_type,
                'timestamp': time.time(),
                'path': file_path
            }

            # Schedule processing if not already scheduled
            if not self._process_timer:
                self._process_timer = threading.Timer(
                    self.debounce_seconds,
                    self._process_pending_events
                )
                self._process_timer.daemon = True
                self._process_timer.start()

    def _process_pending_events(self) -> None:
        """Process pending events after debounce period."""
        with self._event_lock:
            # Reset timer
            self._process_timer = None

            # Process events
            current_time = time.time()
            events_to_process = {}

            # Only process events that have settled (haven't been updated recently)
            for file_path, event_data in self._pending_events.items():
                if current_time - event_data['timestamp'] >= self.debounce_seconds:
                    events_to_process[file_path] = event_data

            # Remove processed events
            for file_path in events_to_process:
                del self._pending_events[file_path]

            # Schedule another processing round if we have remaining events
            if self._pending_events and not self._process_timer:
                self._process_timer = threading.Timer(
                    self.debounce_seconds,
                    self._process_pending_events
                )
                self._process_timer.daemon = True
                self._process_timer.start()

        # Call callback for each processed event (outside the lock)
        for file_path, event_data in events_to_process.items():
            try:
                self.callback(event_data['event_type'], file_path)
            except Exception as e:
                logger.error(f"Error in repository event callback: {e}")


class RepositoryEventSystem:
    """
    System for monitoring repository changes and triggering updates.

    Uses file system watchers to detect changes and dispatches events
    to registered handlers.
    """

    def __init__(self):
        """Initialize the repository event system."""
        self.observers: List[Observer] = []
        self.handlers: Dict[str, RepositoryEventHandler] = {}
        self.watched_paths: Dict[str, List[str]] = {}

    def watch_repository(
        self,
        repo_path: str,
        callback: Callable[[str, str], None],
        file_patterns: List[str] = None,
        recursive: bool = True,
        ignore_dirs: List[str] = None,
        watch_id: str = None
    ) -> str:
        """
        Start watching a repository for changes.

        Args:
            repo_path: Path to the repository to watch
            callback: Function to call when file changes are detected
            file_patterns: List of file patterns to watch (e.g. ["*.py", "*.js"])
            recursive: Whether to watch subdirectories
            ignore_dirs: List of directories to ignore
            watch_id: Optional ID for the watch (generated if not provided)

        Returns:
            ID of the watch (can be used to stop watching)
        """
        if not WATCHDOG_AVAILABLE:
            logger.error("Watchdog not available. Cannot watch repository.")
            return ""

        # Normalize path
        repo_path = os.path.abspath(repo_path)

        # Generate ID if not provided
        if not watch_id:
            watch_id = f"watch_{len(self.handlers)}_{int(time.time())}"

        try:
            # Create handler
            handler = RepositoryEventHandler(
                callback=callback,
                file_patterns=file_patterns or ["*.py", "*.js", "*.ts", "*.jsx", "*.tsx"],
                debounce_seconds=1.0,
                ignore_dirs=ignore_dirs
            )

            # Create observer
            observer = Observer()
            observer.schedule(
                handler,
                repo_path,
                recursive=recursive
            )

            # Start watching
            observer.start()

            # Store references
            self.observers.append(observer)
            self.handlers[watch_id] = handler
            self.watched_paths[watch_id] = repo_path

            logger.info(f"Started watching repository: {repo_path} (ID: {watch_id})")
            return watch_id
        except Exception as e:
            logger.error(f"Error setting up repository watcher: {e}")
            return ""

    def stop_watching(self, watch_id: str) -> bool:
        """
        Stop watching a repository.

        Args:
            watch_id: ID of the watch to stop

        Returns:
            True if successfully stopped, False otherwise
        """
        if not watch_id or watch_id not in self.handlers:
            return False

        try:
            # Find the observer for this handler
            handler = self.handlers[watch_id]

            for i, observer in enumerate(self.observers):
                # We can't directly match observers to handlers, so we stop them all
                # and recreate the ones we want to keep
                observer.stop()
                observer.join()

            # Remove the stopped watch
            del self.handlers[watch_id]
            if watch_id in self.watched_paths:
                del self.watched_paths[watch_id]

            # Recreate observers for remaining handlers
            new_observers = []
            for w_id, handler in self.handlers.items():
                if w_id in self.watched_paths:
                    observer = Observer()
                    observer.schedule(
                        handler,
                        self.watched_paths[w_id],
                        recursive=True
                    )
                    observer.start()
                    new_observers.append(observer)

            self.observers = new_observers
            return True
        except Exception as e:
            logger.error(f"Error stopping repository watcher: {e}")
            return False

    def stop_all(self) -> None:
        """Stop all repository watchers."""
        for observer in self.observers:
            try:
                observer.stop()
                observer.join()
            except Exception as e:
                logger.error(f"Error stopping observer: {e}")

        # Clear references
        self.observers = []
        self.handlers = {}
        self.watched_paths = {}

        logger.info("Stopped all repository watchers") (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.canonical_validator 3:[13:320]
==agent_s3.tools.canonical_validator:[13:320]
logger = logging.getLogger(__name__)


def validate_canonical_implementations(
    implementation_plan: Dict[str, Any],
    element_ids: Set[str]
) -> List[Dict[str, Any]]:
    """
    Validate that each element has exactly one canonical implementation.

    Args:
        implementation_plan: The implementation plan to validate
        element_ids: Set of element IDs from system design

    Returns:
        List of validation issues related to canonical implementations
    """
    issues = []

    # Track implementations by element ID
    implementations_by_element_id = defaultdict(list)

    # Find all implementations for each element ID
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function_idx, function in enumerate(functions):
            if not isinstance(function, dict):
                continue

            element_id = function.get("element_id")
            if element_id:
                implementations_by_element_id[element_id].append({
                    "file_path": file_path,
                    "function_idx": function_idx,
                    "function": function
                })

    # Check for duplicate implementations
    for element_id, implementations in implementations_by_element_id.items():
        if len(implementations) > 1:
            # Found duplicate implementations for an element
            duplicate_files = [impl["file_path"] for impl in implementations]

            issues.append({
                "issue_type": "duplicate_implementation",
                "severity": "critical",
                "description": f"Element {element_id} has multiple implementations in: {', '.join(duplicate_files)}",
                "element_id": element_id,
                "implementations": implementations,
                "recommendation": "Consolidate into a single canonical implementation"
            })

    # Check for missing canonical implementation paths in the implementation strategy
    if "implementation_strategy" in implementation_plan and "canonical_implementation_paths" in implementation_plan["implementation_strategy"]:
        canonical_paths = implementation_plan["implementation_strategy"]["canonical_implementation_paths"]

        # Check that all elements with implementations have a canonical path
        for element_id, implementations in implementations_by_element_id.items():
            if element_id not in canonical_paths and len(implementations) > 0:
                issues.append({
                    "issue_type": "missing_canonical_path",
                    "severity": "medium",
                    "description": f"Element {element_id} is implemented but missing a canonical path declaration",
                    "element_id": element_id,
                    "implementation_files": [impl["file_path"] for impl in implementations]
                })

        # Check that all canonical paths have a corresponding implementation
        for element_id, path in canonical_paths.items():
            if element_id not in implementations_by_element_id:
                issues.append({
                    "issue_type": "unused_canonical_path",
                    "severity": "medium",
                    "description": f"Canonical path defined for element {element_id}, but no implementation exists",
                    "element_id": element_id,
                    "canonical_path": path
                })
            elif not any(impl["file_path"] == path for impl in implementations_by_element_id[element_id]):
                # The canonical path doesn't match any implementation locations
                existing_paths = [impl["file_path"] for impl in implementations_by_element_id[element_id]]
                issues.append({
                    "issue_type": "mismatched_canonical_path",
                    "severity": "medium",
                    "description": f"Canonical path for element {element_id} is {path}, but implementations are in {', '.join(existing_paths)}",
                    "element_id": element_id,
                    "canonical_path": path,
                    "actual_paths": existing_paths
                })
    else:
        # No canonical implementation paths section
        if implementations_by_element_id:  # Only report if there are implementations
            issues.append({
                "issue_type": "missing_canonical_paths_section",
                "severity": "high",
                "description": "Implementation strategy is missing canonical_implementation_paths section",
                "recommendation": "Add canonical_implementation_paths section to implementation_strategy"
            })

    return issues


def repair_duplicate_implementations(
    plan: Dict[str, Any],
    issues: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Repair duplicate implementations by consolidating them into a single canonical implementation.

    Args:
        plan: The implementation plan to repair
        issues: List of duplicate implementation issues to address

    Returns:
        Repaired plan with consolidated implementations
    """
    repaired_plan = json.loads(json.dumps(plan))

    # Process each duplicate implementation issue
    for issue in issues:
        if issue.get("issue_type") != "duplicate_implementation":
            continue

        element_id = issue.get("element_id")
        if not element_id:
            continue

        implementations = issue.get("implementations", [])
        if not implementations:
            continue

        # Choose the canonical implementation (based on various heuristics)
        canonical_impl = find_optimal_implementation(implementations)
        canonical_file = canonical_impl["file_path"]

        # Remove duplicates from other files
        for impl in implementations:
            file_path = impl["file_path"]
            function_idx = impl["function_idx"]

            if file_path != canonical_file:
                # This is a duplicate to remove
                if file_path in repaired_plan:
                    # Filter out the duplicate implementation
                    repaired_plan[file_path] = [
                        func for i, func in enumerate(repaired_plan[file_path])
                        if i != function_idx
                    ]

                    # Remove the file if it's now empty
                    if not repaired_plan[file_path]:
                        del repaired_plan[file_path]

        # If strategy section exists, update canonical implementation paths
        if "implementation_strategy" in repaired_plan:
            if "canonical_implementation_paths" not in repaired_plan["implementation_strategy"]:
                repaired_plan["implementation_strategy"]["canonical_implementation_paths"] = {}

            repaired_plan["implementation_strategy"]["canonical_implementation_paths"][element_id] = canonical_file

    return repaired_plan


def repair_missing_canonical_paths(
    plan: Dict[str, Any],
    issues: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """
    Repair missing canonical path declarations in the implementation strategy.

    Args:
        plan: The implementation plan to repair
        issues: List of issues related to canonical paths

    Returns:
        Repaired plan with added canonical paths
    """
    repaired_plan = json.loads(json.dumps(plan))

    # Ensure the canonical paths section exists
    if "implementation_strategy" not in repaired_plan:
        repaired_plan["implementation_strategy"] = {}

    if "canonical_implementation_paths" not in repaired_plan["implementation_strategy"]:
        repaired_plan["implementation_strategy"]["canonical_implementation_paths"] = {}

    # Process each missing canonical path issue
    for issue in issues:
        if issue.get("issue_type") in ["missing_canonical_path", "mismatched_canonical_path"]:
            element_id = issue.get("element_id")
            implementation_files = issue.get("implementation_files") or []

            if element_id and implementation_files:
                # Choose the best file as the canonical path
                canonical_file = implementation_files[0]  # Default to first one
                repaired_plan["implementation_strategy"]["canonical_implementation_paths"][element_id] = canonical_file

        elif issue.get("issue_type") == "unused_canonical_path":
            # Remove unused canonical path
            element_id = issue.get("element_id")
            if element_id and element_id in repaired_plan["implementation_strategy"]["canonical_implementation_paths"]:
                del repaired_plan["implementation_strategy"]["canonical_implementation_paths"][element_id]

    return repaired_plan


def find_optimal_implementation(implementations: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Find the best implementation to use as the canonical one based on various heuristics.

    Current heuristics:
    1. Prefer implementations with more detailed steps
    2. Prefer implementations with more edge cases handled
    3. Prefer implementations that address more architecture issues

    Args:
        implementations: List of implementations to choose from

    Returns:
        The selected canonical implementation
    """
    if not implementations:
        raise ValueError("No implementations provided")

    if len(implementations) == 1:
        return implementations[0]

    # Score each implementation
    scored_impls = []
    for impl in implementations:
        function = impl["function"]

        # Calculate a score based on completeness and detail
        score = 0

        # Score based on number of steps
        steps = function.get("steps", [])
        score += len(steps) * 10

        # Score based on edge cases
        edge_cases = function.get("edge_cases", [])
        score += len(edge_cases) * 15

        # Score based on architecture issues addressed
        arch_issues = function.get("architecture_issues_addressed", [])
        score += len(arch_issues) * 20

        # Add detailed step information score
        for step in steps:
            if isinstance(step, dict):
                if step.get("pseudo_code"):
                    score += 5
                if step.get("relevant_data_structures"):
                    score += len(step.get("relevant_data_structures", [])) * 3
                if step.get("api_calls_made"):
                    score += len(step.get("api_calls_made", [])) * 3
                if step.get("error_handling_notes"):
                    score += 8

        scored_impls.append((score, impl))

    # Return the highest-scoring implementation
    best_impl = max(scored_impls, key=lambda x: x[0])[1]
    return best_impl


def validate_and_repair_canonical_implementations(
    implementation_plan: Dict[str, Any],
    element_ids: Set[str]
) -> Tuple[Dict[str, Any], List[Dict[str, Any]], bool]:
    """
    Validate canonical implementations and repair any issues found.

    Args:
        implementation_plan: The implementation plan to validate and repair
        element_ids: Set of element IDs from system design

    Returns:
        Tuple of (repaired_plan, validation_issues, needs_repair)
    """
    # Validate canonical implementations
    canonical_issues = validate_canonical_implementations(implementation_plan, element_ids)

    needs_repair = any(issue["severity"] in ["critical", "high"] for issue in canonical_issues)

    # If no critical/high issues, return the original plan
    if not needs_repair:
        return implementation_plan, canonical_issues, needs_repair

    # Repair the plan
    repaired_plan = json.loads(json.dumps(implementation_plan))

    # Group issues by type
    duplicate_issues = [i for i in canonical_issues if i["issue_type"] == "duplicate_implementation"]
    path_issues = [i for i in canonical_issues if i["issue_type"] in [
        "missing_canonical_path", "mismatched_canonical_path", "unused_canonical_path"
    ]]

    # Apply repairs in sequence
    if duplicate_issues:
        repaired_plan = repair_duplicate_implementations(repaired_plan, duplicate_issues)

    if path_issues:
        repaired_plan = repair_missing_canonical_paths(repaired_plan, path_issues)

    return repaired_plan, canonical_issues, needs_repair (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.dependency_impact_analyzer 3:[12:270]
==agent_s3.tools.dependency_impact_analyzer:[12:270]
logger = logging.getLogger(__name__)

class DependencyImpactAnalyzer:
    """
    Analyzer for determining the transitive impact of file changes.

    This class builds a reverse dependency graph and provides methods
    to efficiently determine which files are affected by changes to a given file.
    """

    def __init__(self):
        """Initialize the dependency impact analyzer."""
        # Forward dependencies: file -> files it depends on
        self.forward_deps: Dict[str, Set[str]] = defaultdict(set)

        # Reverse dependencies: file -> files that depend on it
        self.reverse_deps: Dict[str, Set[str]] = defaultdict(set)

        # File metadata
        self.file_metadata: Dict[str, Dict[str, Any]] = {}

        # Cached impact analysis results
        self._impact_cache: Dict[str, Dict[str, Any]] = {}

    def build_from_dependency_graph(self, graph: Dict[str, Any]) -> None:
        """
        Build dependency mappings from a dependency graph.

        Args:
            graph: Dependency graph with 'nodes' and 'edges'
        """
        # Reset existing data
        self.forward_deps = defaultdict(set)
        self.reverse_deps = defaultdict(set)
        self.file_metadata = {}

        if not graph or 'nodes' not in graph or 'edges' not in graph:
            logger.warning("Invalid dependency graph provided")
            return

        try:
            # Extract file paths from nodes
            nodes = graph.get('nodes', {})
            for node_id, node in nodes.items():
                if node.get('type') == 'file':
                    file_path = node.get('path') or node_id
                    self.file_metadata[file_path] = {
                        'id': node_id,
                        'language': node.get('language'),
                        'lines': node.get('lines'),
                        'type': node.get('type')
                    }

            # Process edges to build dependency maps
            edges = graph.get('edges', [])
            for edge in edges:
                edge_type = edge.get('type')

                # Skip edge types we don't care about
                if not edge_type or edge_type not in {'import', 'use', 'include', 'call', 'inherit', 'implement'}:
                    continue

                source_id = edge.get('source')
                target_id = edge.get('target')

                if not source_id or not target_id:
                    continue

                # Get file paths
                source_node = nodes.get(source_id, {})
                target_node = nodes.get(target_id, {})

                # Get file containing the source node
                source_file = None
                if source_node.get('type') == 'file':
                    source_file = source_node.get('path') or source_id
                elif 'parent' in source_node:
                    parent_id = source_node['parent']
                    parent_node = nodes.get(parent_id, {})
                    if parent_node.get('type') == 'file':
                        source_file = parent_node.get('path') or parent_id

                # Get file containing the target node
                target_file = None
                if target_node.get('type') == 'file':
                    target_file = target_node.get('path') or target_id
                elif 'parent' in target_node:
                    parent_id = target_node['parent']
                    parent_node = nodes.get(parent_id, {})
                    if parent_node.get('type') == 'file':
                        target_file = parent_node.get('path') or parent_id

                # Add to dependency maps if we have valid file paths
                if source_file and target_file and source_file != target_file:
                    # Forward dependency: source depends on target
                    self.forward_deps[source_file].add(target_file)

                    # Reverse dependency: target is depended on by source
                    self.reverse_deps[target_file].add(source_file)

            logger.info(f"Built dependency impact analyzer with {len(self.file_metadata)} files")
        except Exception as e:
            logger.error(f"Error building dependency impact analyzer: {e}")

    def get_dependent_files(self, file_path: str, max_depth: int = 3) -> List[str]:
        """
        Get files that depend on the specified file directly or indirectly.

        Args:
            file_path: Path to the file
            max_depth: Maximum depth to traverse in the dependency graph

        Returns:
            List of file paths that depend on the specified file
        """
        # Check cache first
        cache_key = f"{file_path}:{max_depth}"
        if cache_key in self._impact_cache:
            return self._impact_cache[cache_key]['dependent_files']

        # Normalize path
        file_path = os.path.abspath(file_path)

        # Find all dependent files through breadth-first search
        dependent_files = set()
        visited = set([file_path])
        queue = deque([(file_path, 0)])  # (file_path, depth)

        while queue:
            current_file, depth = queue.popleft()

            # Stop if we've reached max depth
            if depth >= max_depth:
                continue

            # Get direct dependents
            dependents = self.reverse_deps.get(current_file, set())

            for dependent in dependents:
                if dependent not in visited:
                    visited.add(dependent)
                    dependent_files.add(dependent)
                    queue.append((dependent, depth + 1))

        # Convert to sorted list
        result = sorted(list(dependent_files))

        # Cache the result
        self._impact_cache[cache_key] = {
            'dependent_files': result,
            'count': len(result),
            'file_path': file_path,
            'max_depth': max_depth
        }

        return result

    def calculate_impact_scope(self, changed_files: List[str], max_depth: int = 3) -> Dict[str, Any]:
        """
        Calculate the full impact scope of changes to multiple files.

        Args:
            changed_files: List of files that have changed
            max_depth: Maximum depth to traverse in the dependency graph

        Returns:
            Dictionary with impact analysis results
        """
        # Normalize paths
        changed_files = [os.path.abspath(f) for f in changed_files]

        # Build comprehensive impact set
        all_impacted = set()
        direct_impacts = {}

        for file_path in changed_files:
            dependents = self.get_dependent_files(file_path, max_depth)
            direct_impacts[file_path] = dependents
            all_impacted.update(dependents)

        # Remove the changed files themselves from the impacted set
        all_impacted -= set(changed_files)

        # Calculate priority scores based on dependency distance
        priority_scores = {}

        for impacted in all_impacted:
            # Higher priority if impacted by multiple changes
            impact_count = 0
            min_distance = max_depth + 1

            # Find minimum distance from any changed file
            for file_path in changed_files:
                if impacted in direct_impacts.get(file_path, []):
                    impact_count += 1

                    # Find distance (expensive but worthwhile for prioritization)
                    distance = self._find_distance(file_path, impacted)
                    if distance < min_distance:
                        min_distance = distance

            # Calculate priority score (higher is more important)
            # Formula: impact_count / (distance^2)
            if min_distance > 0:
                priority_scores[impacted] = impact_count / (min_distance * min_distance)
            else:
                priority_scores[impacted] = impact_count

        # Sort impacted files by priority
        prioritized_impacts = sorted(
            list(all_impacted),
            key=lambda x: priority_scores.get(x, 0),
            reverse=True
        )

        return {
            'changed_files': changed_files,
            'directly_impacted_files': list(all_impacted),
            'prioritized_impacts': prioritized_impacts,
            'impact_count': len(all_impacted),
            'priority_scores': priority_scores
        }

    def _find_distance(self, source: str, target: str) -> int:
        """
        Find shortest path distance between source and target files.

        Args:
            source: Source file path
            target: Target file path

        Returns:
            Shortest path distance or max_int if no path exists
        """
        # Simple BFS to find shortest path
        visited = set([source])
        queue = deque([(source, 0)])  # (file_path, distance)

        while queue:
            current, distance = queue.popleft()

            if current == target:
                return distance

            # Use reverse dependencies since we're looking for things that depend on us
            next_files = self.reverse_deps.get(current, set())

            for next_file in next_files:
                if next_file not in visited:
                    visited.add(next_file)
                    queue.append((next_file, distance + 1))

        # No path found
        return float('inf')

    def clear_cache(self) -> None:
        """Clear the impact analysis cache."""
        self._impact_cache = {} (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.file_change_tracker 3:[16:295]
==agent_s3.tools.file_change_tracker:[16:295]
logger = logging.getLogger(__name__)

class FileChangeTracker:
    """
    Tracks file changes using modification times and content hashing.

    This class maintains a persistent store of file metadata to detect changes
    between indexing operations, enabling efficient incremental updates.
    """

    def __init__(self, storage_path: Optional[str] = None):
        """
        Initialize the file change tracker.

        Args:
            storage_path: Path to store the file tracking data. If None, defaults to a
                          location within the user's home directory.
        """
        self.storage_path = storage_path
        if not self.storage_path:
            # Default to a hidden directory in the user's home
            home = os.path.expanduser("~")
            self.storage_path = os.path.join(home, ".agent_s3", "tracking")

        # Ensure storage directory exists
        os.makedirs(self.storage_path, exist_ok=True)

        # File state tracking
        self._file_state: Dict[str, Dict[str, Any]] = {}
        self._file_hashes: Dict[str, str] = {}

        # Load existing state if available
        self._load_state()

    def _load_state(self) -> None:
        """Load file state information from disk."""
        state_path = os.path.join(self.storage_path, "file_state.json")
        if os.path.exists(state_path):
            try:
                with open(state_path, 'r') as f:
                    data = json.load(f)
                    self._file_state = data.get('file_state', {})
                    self._file_hashes = data.get('file_hashes', {})
                logger.info(f"Loaded tracking information for {len(self._file_state)} files")
            except Exception as e:
                logger.error(f"Error loading file state information: {e}")
                # Reset state if corrupted
                self._file_state = {}
                self._file_hashes = {}

    def _save_state(self) -> None:
        """Save file state information to disk."""
        state_path = os.path.join(self.storage_path, "file_state.json")
        try:
            # Create a combined state object
            data = {
                'file_state': self._file_state,
                'file_hashes': self._file_hashes,
                'timestamp': time.time()
            }

            # Write to a temporary file first, then rename for atomic update
            temp_path = state_path + ".tmp"
            with open(temp_path, 'w') as f:
                json.dump(data, f)

            # Atomic replacement
            os.replace(temp_path, state_path)
            logger.debug(f"Saved tracking information for {len(self._file_state)} files")
        except Exception as e:
            logger.error(f"Error saving file state information: {e}")

    def compute_file_hash(self, file_path: str, content: Optional[str] = None) -> str:
        """
        Compute a hash for a file's content.

        Args:
            file_path: Path to the file
            content: Optional pre-loaded content (to avoid re-reading)

        Returns:
            Hash string for the file
        """
        try:
            if content is None:
                with open(file_path, 'rb') as f:
                    content = f.read()
            elif isinstance(content, str):
                content = content.encode('utf-8')

            # Use a fast hash function (murmurhash would be ideal, but hashlib is standard)
            return hashlib.md5(content).hexdigest()
        except Exception as e:
            logger.error(f"Error computing hash for {file_path}: {e}")
            # Return a timestamp-based hash as fallback
            return f"err-{int(time.time())}"

    def track_file(self, file_path: str, content: Optional[str] = None) -> bool:
        """
        Add or update a file in the tracking system.

        Args:
            file_path: Path to the file to track
            content: Optional pre-loaded content (to avoid re-reading)

        Returns:
            True if the file was successfully tracked, False otherwise
        """
        try:
            # Standardize path
            file_path = os.path.abspath(file_path)

            # Check if file exists
            if not os.path.isfile(file_path):
                return False

            # Get file metadata
            stat = os.stat(file_path)
            mtime = stat.st_mtime
            size = stat.st_size

            # Compute hash
            file_hash = self.compute_file_hash(file_path, content)

            # Update tracking information
            self._file_state[file_path] = {
                'mtime': mtime,
                'size': size,
                'last_indexed': time.time(),
                'hash': file_hash
            }

            # Store hash separately for quick access
            self._file_hashes[file_path] = file_hash

            return True
        except Exception as e:
            logger.error(f"Error tracking file {file_path}: {e}")
            return False

    def is_file_changed(self, file_path: str, content: Optional[str] = None) -> bool:
        """
        Check if a file has changed since it was last indexed.

        Args:
            file_path: Path to the file to check
            content: Optional pre-loaded content (to avoid re-reading)

        Returns:
            True if the file has changed or wasn't previously tracked, False otherwise
        """
        try:
            # Standardize path
            file_path = os.path.abspath(file_path)

            # Check if file exists
            if not os.path.isfile(file_path):
                # File doesn't exist, but we were tracking it before
                if file_path in self._file_state:
                    return True
                return False

            # Not tracked yet
            if file_path not in self._file_state:
                return True

            # Quick check - modification time
            prev_state = self._file_state[file_path]
            curr_mtime = os.stat(file_path).st_mtime

            # If modification time has changed, do a full check
            if curr_mtime > prev_state['mtime']:
                # Hash comparison for absolute confirmation
                curr_hash = self.compute_file_hash(file_path, content)
                return curr_hash != prev_state['hash']

            # File hasn't changed
            return False
        except Exception as e:
            logger.error(f"Error checking if file changed {file_path}: {e}")
            # Assume changed if error occurs
            return True

    def get_changed_files(self, directory: str, extensions: List[str] = None) -> List[str]:
        """
        Find all files that have changed in a directory since they were last tracked.

        Args:
            directory: Directory to scan for changed files
            extensions: Optional list of file extensions to check (e.g. ['.py', '.js'])

        Returns:
            List of paths to files that have changed
        """
        changed_files = []

        try:
            # Walk through directory
            for root, _, files in os.walk(directory):
                for filename in files:
                    # Filter by extension if specified
                    if extensions and not any(filename.endswith(ext) for ext in extensions):
                        continue

                    file_path = os.path.join(root, filename)

                    # Check if file has changed
                    if self.is_file_changed(file_path):
                        changed_files.append(file_path)
        except Exception as e:
            logger.error(f"Error getting changed files in {directory}: {e}")

        return changed_files

    def track_directory(self, directory: str, extensions: List[str] = None) -> int:
        """
        Track all files in a directory.

        Args:
            directory: Directory to scan and track files in
            extensions: Optional list of file extensions to track (e.g. ['.py', '.js'])

        Returns:
            Number of files successfully tracked
        """
        count = 0

        try:
            # Walk through directory
            for root, _, files in os.walk(directory):
                for filename in files:
                    # Filter by extension if specified
                    if extensions and not any(filename.endswith(ext) for ext in extensions):
                        continue

                    file_path = os.path.join(root, filename)

                    # Track the file
                    if self.track_file(file_path):
                        count += 1

            # Save state after tracking a directory
            self._save_state()
        except Exception as e:
            logger.error(f"Error tracking directory {directory}: {e}")

        return count

    def clear_tracking_data(self) -> None:
        """Clear all tracking data."""
        self._file_state = {}
        self._file_hashes = {}
        self._save_state()

    def get_stats(self) -> Dict[str, Any]:
        """
        Get statistics about tracked files.

        Returns:
            Dictionary with tracking statistics
        """
        if not self._file_state:
            return {
                'tracked_files': 0,
                'total_size': 0,
                'oldest_tracked': None,
                'newest_tracked': None
            }

        # Calculate stats
        total_size = sum(info.get('size', 0) for info in self._file_state.values())
        timestamps = [info.get('last_indexed', 0) for info in self._file_state.values()]

        return {
            'tracked_files': len(self._file_state),
            'total_size': total_size,
            'oldest_tracked': min(timestamps) if timestamps else None,
            'newest_tracked': max(timestamps) if timestamps else None
        } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.context_registry 4:[12:181]
==agent_s3.tools.context_management.context_registry:[12:181]
logger = logging.getLogger(__name__)

class ContextRegistry:
    """
    Central registry for accessing all context providers.
    Serves as a facade to all context sources.
    """
    def __init__(self):
        self._providers = {}
    def register_provider(self, name: str, provider: ContextProvider) -> None:
        self._providers[name] = provider
        logger.info(f"Registered context provider: {name}")
    def get_provider(self, name: str) -> Optional[ContextProvider]:
        return self._providers.get(name)
    def get_tech_stack(self) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, TechStackProvider) and hasattr(provider, "get_tech_stack"):
                return provider.get_tech_stack()
        logger.warning("No provider found for tech stack information")
        return {}
    def get_relevant_files(self, query: str, top_n: int = 10) -> List[Dict[str, Any]]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_relevant_files"):
                return provider.get_relevant_files(query, top_n)
        logger.warning(f"No provider found for relevant files: {query}")
        return []
    def get_file_history(self, file_path: str = None) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_file_history"):
                return provider.get_file_history(file_path)
        logger.warning(f"No provider found for file history: {file_path}")
        return {}
    def get_file_metadata(self, file_path: str = None) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_file_metadata"):
                return provider.get_file_metadata(file_path)
        logger.warning(f"No provider found for file metadata: {file_path}")
        return {}
    def get_project_structure(self) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, ProjectContextProvider) and hasattr(provider, "get_project_structure"):
                return provider.get_project_structure()
        logger.warning("No provider found for project structure")
        return {}
    def get_config_files(self) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, ProjectContextProvider) and hasattr(provider, "get_config_files"):
                return provider.get_config_files()
        logger.warning("No provider found for config files")
        return {}

    # --- Added Passthrough Methods ---

    def read_file(self, file_path: str) -> str:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "read_file"):
                return provider.read_file(file_path)
        logger.warning(f"No provider found for read_file: {file_path}")
        return ""

    def get_code_elements(self, file_path: str) -> List[Dict[str, Any]]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_code_elements"):
                return provider.get_code_elements(file_path)
        logger.warning(f"No provider found for get_code_elements: {file_path}")
        return []

    def get_file_imports(self, file_path: str) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_file_imports"):
                return provider.get_file_imports(file_path)
        logger.warning(f"No provider found for get_file_imports: {file_path}")
        return []

    def get_files_importing(self, file_path: str) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_files_importing"):
                return provider.get_files_importing(file_path)
        logger.warning(f"No provider found for get_files_importing: {file_path}")
        return []

    def get_convention_related_files(self, file_path: str) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_convention_related_files"):
                return provider.get_convention_related_files(file_path)
        logger.warning(f"No provider found for get_convention_related_files: {file_path}")
        return []

    def get_hotspot_files(self) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_hotspot_files"):
                return provider.get_hotspot_files()
        logger.warning("No provider found for get_hotspot_files")
        return []

    def get_code_ownership(self) -> Dict[str, List[str]]:
        for provider in self._providers.values():
            if isinstance(provider, FileContextProvider) and hasattr(provider, "get_code_ownership"):
                return provider.get_code_ownership()
        logger.warning("No provider found for get_code_ownership")
        return {}

    def get_project_root(self) -> str:
        for provider in self._providers.values():
            if isinstance(provider, ProjectContextProvider) and hasattr(provider, "get_project_root"):
                return provider.get_project_root()
        logger.warning("No provider found for get_project_root")
        return ""

    def get_coding_guidelines(self) -> Optional[str]:
        for provider in self._providers.values():
            if isinstance(provider, ProjectContextProvider) and hasattr(provider, "get_coding_guidelines"):
                return provider.get_coding_guidelines()
        logger.warning("No provider found for get_coding_guidelines")
        return None

    def find_test_files(self, impl_file_path: str) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, TestContextProvider) and hasattr(provider, "find_test_files"):
                return provider.find_test_files(impl_file_path)
        logger.warning(f"No provider found for find_test_files: {impl_file_path}")
        return []

    def suggest_unit_tests(self, code_element: Dict[str, Any]) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, TestContextProvider) and hasattr(provider, "suggest_unit_tests"):
                return provider.suggest_unit_tests(code_element)
        logger.warning("No provider found for suggest_unit_tests")
        return []

    def suggest_integration_tests(self, code_element: Dict[str, Any]) -> List[str]:
        for provider in self._providers.values():
            if isinstance(provider, TestContextProvider) and hasattr(provider, "suggest_integration_tests"):
                return provider.suggest_integration_tests(code_element)
        logger.warning("No provider found for suggest_integration_tests")
        return []

    def get_test_framework_dependencies(self, test_type: str, language: str) -> Dict[str, bool]:
        for provider in self._providers.values():
            if isinstance(provider, TestContextProvider) and hasattr(provider, "get_test_framework_dependencies"):
                return provider.get_test_framework_dependencies(test_type, language)
        logger.warning("No provider found for get_test_framework_dependencies")
        return {}

    def get_similar_tasks(self, query: str, top_n: int = 5) -> List[Dict[str, Any]]:
        for provider in self._providers.values():
            if isinstance(provider, MemoryContextProvider) and hasattr(provider, "get_similar_tasks"):
                return provider.get_similar_tasks(query, top_n)
        logger.warning(f"No provider found for get_similar_tasks: {query}")
        return []

    def get_dependency_graph(self, scope: Optional[str] = None) -> Dict[str, Any]:
        for provider in self._providers.values():
            if isinstance(provider, DependencyGraphProvider) and hasattr(provider, "get_dependency_graph"):
                return provider.get_dependency_graph(scope)
        logger.warning("No provider found for dependency graph")
        return {}

    # --- End Added Passthrough Methods ---

    def get_optimized_context(self, context_type: str = None) -> Dict[str, Any]:
        result = {}
        for provider in self._providers.values():
            if hasattr(provider, "get_optimized_context"):
                ctx = provider.get_optimized_context()
                for k, v in ctx.items():
                    if k not in result:
                        result[k] = v
        return result (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.test_critic.reporter 3:[13:143]
==agent_s3.tools.test_critic.reporter:[13:143]
logger = logging.getLogger(__name__)

class Reporter:
    """Reporter for test critic results."""

    def __init__(self, workspace: Path):
        """
        Initialize the reporter.

        Args:
            workspace: Path to the workspace directory
        """
        self.workspace = workspace

    def write(self, results: Dict[str, Any]) -> None:
        """
        Write test critic results to files.

        Args:
            results: Dictionary containing test critic results
        """
        try:
            # Write JSON results
            self._write_json(results)

            # Write JUnit XML results
            self._write_junit_xml(results)

            logger.info("Test critic reports written successfully")
        except Exception as e:
            logger.error(f"Error writing test critic reports: {str(e)}")

    def _write_json(self, results: Dict[str, Any]) -> None:
        """
        Write test critic results to a JSON file.

        Args:
            results: Dictionary containing test critic results
        """
        output_path = self.workspace / "critic.json"

        # Add timestamp and format values
        output_data = {
            "timestamp": datetime.now().isoformat(),
            "collect_errors": results.get("collect_errors", []),
            "smoke_passed": results.get("smoke_passed", False),
            "coverage_percent": float(results.get("coverage_percent", 0) or 0),
            "mutation_score": float(results.get("mutation_score", 0) or 0),
        }

        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(output_data, f, indent=2)

        logger.info(f"Test critic JSON report written to {output_path}")

    def _write_junit_xml(self, results: Dict[str, Any]) -> None:
        """
        Write test critic results to a JUnit XML file.

        This format is recognized by CI systems like GitHub Actions and GitLab CI,
        allowing test results to be displayed in the CI interface.

        Args:
            results: Dictionary containing test critic results
        """
        output_path = self.workspace / "junit.xml"

        # Create XML structure
        testsuite = ET.Element("testsuite")
        testsuite.set("name", "TestCritic")
        testsuite.set("timestamp", datetime.now().isoformat())

        # Add test cases

        # Collect errors test case
        collect_case = ET.SubElement(testsuite, "testcase")
        collect_case.set("name", "test_collection")
        collect_case.set("classname", "TestCritic")

        collect_errors = results.get("collect_errors", [])
        if collect_errors:
            failure = ET.SubElement(collect_case, "failure")
            failure.set("message", "Test collection errors")
            failure.set("type", "TestCollectionError")
            failure.text = "\n".join(collect_errors)

        # Smoke test case
        smoke_case = ET.SubElement(testsuite, "testcase")
        smoke_case.set("name", "smoke_tests")
        smoke_case.set("classname", "TestCritic")

        if not results.get("smoke_passed", False):
            failure = ET.SubElement(smoke_case, "failure")
            failure.set("message", "Smoke tests failed")
            failure.set("type", "SmokeTestFailure")

        # Coverage test case
        coverage_case = ET.SubElement(testsuite, "testcase")
        coverage_case.set("name", "code_coverage")
        coverage_case.set("classname", "TestCritic")

        coverage = results.get("coverage_percent", 0)
        if coverage is None:
            skipped = ET.SubElement(coverage_case, "skipped")
            skipped.set("message", "Coverage analysis not available")
        elif coverage < 80:  # Default threshold
            failure = ET.SubElement(coverage_case, "failure")
            failure.set("message", f"Coverage {coverage}% below threshold 80%")
            failure.set("type", "CoverageThresholdFailure")

        # Mutation test case
        mutation_case = ET.SubElement(testsuite, "testcase")
        mutation_case.set("name", "mutation_testing")
        mutation_case.set("classname", "TestCritic")

        mutation = results.get("mutation_score", 0)
        if mutation is None:
            skipped = ET.SubElement(mutation_case, "skipped")
            skipped.set("message", "Mutation testing not available")
        elif mutation < 60:  # Default threshold
            failure = ET.SubElement(mutation_case, "failure")
            failure.set("message", f"Mutation score {mutation}% below threshold 60%")
            failure.set("type", "MutationThresholdFailure")

        # Create XML tree and write to file
        tree = ET.ElementTree(testsuite)
        tree.write(output_path, encoding='utf-8', xml_declaration=True)

        logger.info(f"Test critic JUnit XML report written to {output_path}") (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.interfaces 3:[8:166]
==agent_s3.tools.context_management.interfaces:[8:166]
class ContextProvider(Protocol):
    """Base protocol for all context providers."""
    pass

class TechStackProvider(ContextProvider):
    """Provides information about the project's technology stack."""
    @abstractmethod
    def get_tech_stack(self) -> Dict[str, Any]:
        ...

class FileContextProvider(ContextProvider):
    """Provides context related to files and their history."""
    @abstractmethod
    def get_relevant_files(self, query: str, top_n: int = 10) -> List[Dict[str, Any]]:
        ...

    @abstractmethod
    def get_file_history(self, file_path: Optional[str] = None) -> Dict[str, Any]:
        ...

    @abstractmethod
    def get_file_metadata(self, file_path: Optional[str] = None) -> Dict[str, Any]:
        ...

    @abstractmethod
    def read_file(self, file_path: str) -> str:
        """Reads the content of a specific file."""
        ...

    @abstractmethod
    def get_code_elements(self, file_path: str) -> List[Dict[str, Any]]:
        """Gets detailed information about code elements (functions, classes) in a file."""
        ...

    @abstractmethod
    def get_file_imports(self, file_path: str) -> List[Dict[str, Any]]:
        """Gets the list of modules imported by a file."""
        ...

    @abstractmethod
    def get_files_importing(self, file_path: str) -> List[str]:
        """Gets the list of files that import the given file."""
        ...

    @abstractmethod
    def get_convention_related_files(self, file_path: str) -> List[str]:
        """Gets files related by naming convention."""
        ...

    @abstractmethod
    def get_hotspot_files(self) -> List[str]:
        """Gets files with high change frequency."""
        ...

    @abstractmethod
    def get_code_ownership(self) -> Dict[str, List[str]]:
        """Gets information about primary authors/contributors per file/module."""
        ...


class ProjectContextProvider(ContextProvider):
    """Provides context about the overall project structure and configuration."""
    @abstractmethod
    def get_project_structure(self) -> Dict[str, Any]:
        ...

    @abstractmethod
    def get_config_files(self) -> Dict[str, Any]:
        ...

    @abstractmethod
    def get_project_root(self) -> str:
        """Gets the absolute path to the project root directory."""
        ...

    @abstractmethod
    def get_coding_guidelines(self) -> Optional[str]:
        """Gets project-specific coding guidelines."""
        ...

class TestContextProvider(ContextProvider):
    """Provides context related to testing."""
    @abstractmethod
    def find_test_files(self, impl_file_path: str) -> List[str]:
        """Locates corresponding test files for an implementation file."""
        ...

    @abstractmethod
    def suggest_unit_tests(self, code_element: Dict[str, Any]) -> List[str]:
        """Generates basic unit test ideas based on a code element."""
        ...

    @abstractmethod
    def suggest_integration_tests(self, code_element: Dict[str, Any]) -> List[str]:
        """Generates basic integration test ideas based on a code element."""
        ...

    @abstractmethod
    def get_test_framework_dependencies(self, test_type: str, language: str) -> Dict[str, bool]:
        """Checks if necessary testing libraries are installed for a given test type and language."""
        ...

class MemoryContextProvider(ContextProvider):
    """Provides historical context from past tasks and interactions."""
    @abstractmethod
    def get_similar_tasks(self, query: str, top_n: int = 5) -> List[Dict[str, Any]]:
        """Retrieves summaries or details of previously completed similar tasks."""
        ...

class DependencyNode(TypedDict):
    """Represents a node in the project dependency graph.

    Attributes:
      id: Unique node identifier (e.g., file path or file_path:ClassName).
      type: Node type ('file', 'class', 'function', 'module', 'variable').
      name: Human-readable name of the node.
      path: File path where the node is defined.
      language: Programming language (e.g., 'python', 'javascript').
      line: Line number of definition (0-based), if known.
      framework_role: Optional role within a framework (e.g., 'FastAPI route handler').
    """
    id: str
    type: Literal["file", "class", "function", "module", "variable"]
    name: str
    path: Optional[str]
    language: Optional[str]
    line: Optional[int]
    framework_role: Optional[str]

class DependencyEdge(TypedDict):
    """Represents a directed dependency between two nodes in the graph.

    Attributes:
      source: ID of the source DependencyNode.
      target: ID of the target DependencyNode.
      type: Dependency type ('import', 'call', 'inherit', 'route_handler', 'component_usage', etc.).
      location: Optional line number where the dependency occurs (0-based).
    """
    source: str
    target: str
    type: Literal[
        "import", "call", "inherit", "contains",
        "route_handler", "component_usage",
        "di_injection", "data_fetcher", "module_dependency"
    ]
    location: Optional[int]

class DependencyGraphProvider(ContextProvider):
    """Protocol to provide a project dependency graph.

    Method:
      get_dependency_graph(scope: Optional[str] = None) -> Dict[str, Any]
    Returns:
      A dictionary with 'nodes' (mapping IDs to DependencyNode) and 'edges' (list of DependencyEdge).
    """
    @abstractmethod
    def get_dependency_graph(self, scope: Optional[str] = None) -> Dict[str, Any]:
        ... (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.test_spec_validator:[48:93]
==agent_s3.tools.implementation_validator:[341:378]
    return element_ids


def _extract_architecture_issues(architecture_review: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract all architecture issues from the architecture review."""
    issues = []

    # Extract from logical_gaps section
    for issue in architecture_review.get("logical_gaps", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"),
                "issue_type": "logical_gap"
            })

    # Extract from security_concerns section
    for issue in architecture_review.get("security_concerns", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "High"),
                "issue_type": "security_concern"
            })

    # Extract from optimization_opportunities section
    for issue in architecture_review.get("optimization_opportunities", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"),
                "issue_type": "optimization"
            })
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates:[68:93]
==agent_s3.tools.context_management.adaptive_config.project_profiler 4:[143:168]
            "context_management": {
                "enabled": True,
                "background_enabled": True,
                "optimization_interval": 60,
                "embedding": {
                    "chunk_size": 1000,
                    "chunk_overlap": 200,
                },
                "search": {
                    "bm25": {
                        "k1": 1.2,
                        "b": 0.75
                    },
                },
                "summarization": {
                    "threshold": 2000,
                    "compression_ratio": 0.5
                },
                "importance_scoring": {
                    "code_weight": 1.0,
                    "comment_weight": 0.8,
                    "metadata_weight": 0.7,
                    "framework_weight": 0.9
                }
            } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[68:93]
==agent_s3.tools.context_management.adaptive_config.project_profiler:[143:168]
            "context_management": {
                "enabled": True,
                "background_enabled": True,
                "optimization_interval": 60,
                "embedding": {
                    "chunk_size": 1000,
                    "chunk_overlap": 200,
                },
                "search": {
                    "bm25": {
                        "k1": 1.2,
                        "b": 0.75
                    },
                },
                "summarization": {
                    "threshold": 2000,
                    "compression_ratio": 0.5
                },
                "importance_scoring": {
                    "code_weight": 1.0,
                    "comment_weight": 0.8,
                    "metadata_weight": 0.7,
                    "framework_weight": 0.9
                }
            } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.pre_planner_json_enforced:[764:788]
==agent_s3.schema_validator:[34:58]
            }
          },
          "dependencies": {
            "internal": [string],
            "external": [string],
            "feature_dependencies": [
              {
                "feature_name": string,
                "dependency_type": string,
                "reason": string
              }
            ]
          },
          "risk_assessment": {
            "critical_files": [string],
            "potential_regressions": [string],
            "backward_compatibility_concerns": [string],
            "mitigation_strategies": [string],
            "required_test_characteristics": {
              "required_types": [string],
              "required_keywords": [string],
              "suggested_libraries": [string]
            }
          }, (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[334:369]
==agent_s3.tools.test_implementation_validator:[208:242]
    element_ids = set()

    # Extract from code_elements
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict) and "element_id" in element:
            element_ids.add(element["element_id"])

    return element_ids


def _extract_architecture_issues(architecture_review: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract all architecture issues from the architecture review."""
    issues = []

    # Extract from logical_gaps section
    for issue in architecture_review.get("logical_gaps", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"),
                "issue_type": "logical_gap"
            })

    # Extract from security_concerns section
    for issue in architecture_review.get("security_concerns", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "High"),
                "issue_type": "security_concern"
            })

    # Extract from optimization_opportunities section (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.planner:[294:467]
==agent_s3.planner_json_enforced:[307:535]
        try:
            personas_path = Path("personas.md")
            if personas_path.exists():
                return personas_path.read_text(encoding='utf-8')
            else:
                logger.warning("personas.md file not found, using default personas")
                # Default personas
                return """
                ## Business Development Manager
                Clarify why we're building this feature, whom it serves, and what real-world scenarios it must cover.

                ## Expert Coder
                Define how the feature will be builtstep by step, with tech choices, data models, and file breakdown.

                ## Reviewer
                Ensure the proposed solution is logically consistent and covers all functional scenarios.

                ## Validator
                Confirm the solution adheres to best practices and organizational guidelines.
                """
        except Exception as e:
            logger.error(f"Error loading personas content: {str(e)}")
            return "Error loading personas content. Using default expert personas."

    def get_coding_guidelines(self) -> str:
        """Load the coding guidelines from .github/copilot-instructions.md file."""
        try:
            guidelines_path = Path(".github/copilot-instructions.md")
            if guidelines_path.exists():
                return guidelines_path.read_text(encoding='utf-8')
            else:
                logger.warning("copilot-instructions.md file not found, using default guidelines")
                # Default guidelines
                return """
                # Coding Guidelines

                - Follow best practices for security, performance, and code quality
                - Write clean, modular code with proper error handling
                - Include comprehensive tests for all functionality
                - Follow project-specific conventions and patterns
                """
        except Exception as e:
            logger.error(f"Error loading coding guidelines: {str(e)}")
            return "Error loading coding guidelines. Using default standards."



    def _call_llm_with_retry(self, system_prompt: str, user_prompt: str, llm_params: Dict[str, Any], retries: int = 2) -> str:
        """
        Call LLM with retry logic.

        Args:
            system_prompt: System prompt for LLM
            user_prompt: User prompt for LLM
            llm_params: Parameters for LLM call
            retries: Number of retries (default: 2)

        Returns:
            LLM response text

        Raises:
            PlanningError: If all retries fail
        """
        last_error = None

        for attempt in range(retries + 1):
            try:
                if isinstance(self.llm, dict):
                    # If llm is a dictionary of parameters
                    response = cached_call_llm(
                        prompt=user_prompt,
                        system=system_prompt,
                        **llm_params
                    )
                    return response.get('response', '')
                else:
                    # Assume it's router_agent or similar
                    role = 'planner'
                    response = self.llm.call_llm_by_role(
                        role=role,
                        system_prompt=system_prompt,
                        user_prompt=user_prompt,
                        config=llm_params,
                        scratchpad=self.scratchpad
                    )

                    if not response:
                        raise ValueError("LLM returned an empty response")

                    return response

            except Exception as e:
                last_error = str(e)
                logger.warning(f"LLM call attempt {attempt + 1}/{retries + 1} failed: {e}")

                if attempt < retries:
                    # Wait before retry with exponential backoff
                    import time
                    time.sleep(2 ** attempt)
                else:
                    logger.error(f"All LLM call attempts failed: {e}")

        raise PlanningError(f"LLM call failed after {retries + 1} attempts: {last_error}")


    def generate_architecture_review(self, feature_group: Dict[str, Any], task_description: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate architecture review for a feature group's system design.

        Args:
            feature_group: The feature group data
            task_description: The original task description
            context: Optional context information

        Returns:
            Dictionary with architecture_review and discussion fields
        """
        logger.info(f"Generating architecture review for feature group: {feature_group.get('group_name', 'Unknown')}")

        if not self.llm:
            raise PlanningError("No LLM client available")

        # Extract system design from feature group
        system_design = {}
        for feature in feature_group.get("features", []):
            if isinstance(feature, dict) and "system_design" in feature:
                feature_system_design = feature.get("system_design", {})
                # Merge system design from all features
                for key, value in feature_system_design.items():
                    if key not in system_design:
                        system_design[key] = value
                    elif isinstance(value, list) and isinstance(system_design[key], list):
                        system_design[key].extend(value)

        # Create system prompt for architecture review
        system_prompt = """You are a senior software architect specializing in architecture review.
Your task is to analyze a feature group's system design and identify logical gaps, optimization opportunities, and architectural considerations.

CRITICAL INSTRUCTION: You MUST respond in valid JSON format ONLY, conforming EXACTLY to this schema:
{
  "architecture_review": {
    "logical_gaps": [
      {
        "description": "Description of the logical gap (e.g., Authentication system lacks CSRF protection)",
        "impact": "Potential impact of the gap (e.g., Vulnerable to cross-site request forgery attacks)",
        "recommendation": "Recommendation to address the gap (e.g., Implement CSRF tokens in all forms)"
      }
    ],
    "optimization_suggestions": [
      {
        "description": "Description of the optimization (e.g., Database queries not optimized for pagination)",
        "benefit": "Potential benefit of the optimization (e.g., Reduced memory usage and query time for large datasets)",
        "implementation_approach": "Suggested approach for implementation (e.g., Add LIMIT/OFFSET or cursor-based pagination)"
      }
    ],
    "additional_considerations": [
      "Any other relevant considerations (e.g., Consider implementing rate limiting to prevent abuse)"
    ]
  },
  "discussion": "Overall assessment of the architecture, explaining key findings and recommendations"
}

Your task is to:
1. Analyze the system design with a focus on its architecture, interfaces, and overall coherence
2. Identify logical gaps in the design that could lead to issues or failures
3. Suggest optimizations that could improve performance, security, or maintainability
4. Provide additional considerations that might not be covered in the logical gaps or optimizations

Be concise and direct in your analysis. Focus on substantive issues rather than style or naming conventions.
Each identified issue should be clear, specific, and actionable, with a clear description, impact/benefit, and recommendation.
"""

        # Create the user prompt (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.test_spec_validator:[48:83]
==agent_s3.tools.test_implementation_validator:[215:242]
    return element_ids


def _extract_architecture_issues(architecture_review: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract all architecture issues from the architecture review."""
    issues = []

    # Extract from logical_gaps section
    for issue in architecture_review.get("logical_gaps", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"),
                "issue_type": "logical_gap"
            })

    # Extract from security_concerns section
    for issue in architecture_review.get("security_concerns", []):
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "High"),
                "issue_type": "security_concern"
            })
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.system_design_validator 3:[275:297]
==agent_s3.tools.system_design_validator:[751:771]
    requirement_ids = _extract_requirement_ids(requirements)
    covered_requirements = set()

    # Check code elements for requirement coverage
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict):
            # Check explicit requirements addressed
            if "requirements_addressed" in element:
                addressed = element.get("requirements_addressed", [])
                if isinstance(addressed, list):
                    covered_requirements.update(addressed)

            # Check descriptions
            description = element.get("description", "")
            if description:
                for req_id in requirement_ids:
                    if req_id in description:
                        covered_requirements.add(req_id)

    # Calculate requirements coverage score (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.system_design_validator 3:[751:771]
==agent_s3.tools.system_design_validator:[275:297]
    requirement_ids = _extract_requirement_ids(requirements)
    covered_requirements = set()

    # Check code elements for requirement coverage
    for element in system_design.get("code_elements", []):
        if isinstance(element, dict):
            # Check explicit requirements addressed
            if "requirements_addressed" in element:
                addressed = element.get("requirements_addressed", [])
                if isinstance(addressed, list):
                    covered_requirements.update(addressed)

            # Check descriptions
            description = element.get("description", "")
            if description:
                for req_id in requirement_ids:
                    if req_id in description:
                        covered_requirements.add(req_id)

    # Calculate requirements coverage score (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.pre_planner_json_enforced:[718:730]
==agent_s3.schema_validator:[10:22]
{
  "original_request": string,
  "feature_groups": [
    {
      "group_name": string,
      "group_description": string,
      "features": [
        {
          "name": string,
          "description": string,
          "files_affected": [string],
          "test_requirements": { (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.planner_json_enforced:[242:253]
==agent_s3.pre_planner_json_enforced:[129:140]
                "files_affected": [],
                "test_requirements": {
                    "unit_tests": [],
                    "integration_tests": [],
                    "property_based_tests": [],
                    "acceptance_tests": [],
                    "test_strategy": {
                        "coverage_goal": "80%",
                        "ui_test_approach": "manual"
                    }
                }, (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[285:295]
==agent_s3.tools.context_management.adaptive_config.config_templates:[272:282]
        "context_management": {
            "embedding": {
                "chunk_size": 1200,  # Java tends to be more verbose
            },
            "search": {
                "bm25": {
                    "b": 0.8  # More length normalization for Java
                }
            }
        } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[272:282]
==agent_s3.tools.context_management.adaptive_config.config_templates:[285:295]
        "context_management": {
            "embedding": {
                "chunk_size": 1200,  # Java tends to be more verbose
            },
            "search": {
                "bm25": {
                    "b": 0.8  # More length normalization for Java
                }
            }
        } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.code_analysis_tool:[926:936]
==agent_s3.tools.plan_validator:[170:180]
        if not language:
            if hasattr(self.file_tool, 'get_language_from_extension'):
                language = self.file_tool.get_language_from_extension(file_path)
            if not language:
                language = Path(file_path).suffix[1:].lower() if Path(file_path).suffix else 'unknown'
        parser = self.parser_registry.get_parser(language_name=language, file_path=file_path)
        if parser:
            try:
                logger.info(f"Analyzing {file_path} with {type(parser).__name__} for language '{language}'.")
                structure = parser.parse_code(content, file_path) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.coherence_validator:[94:106]
==agent_s3.tools.implementation_validator:[846:858]
    snake_case_pattern = r'^[a-z][a-z0-9_]*$'
    camel_case_pattern = r'^[a-z][a-zA-Z0-9]*$'
    pascal_case_pattern = r'^[A-Z][a-zA-Z0-9]*$'

    # Count occurrences of each naming style
    naming_styles = {
        "snake_case": 0,
        "camel_case": 0,
        "pascal_case": 0,
        "other": 0
    }
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.command_processor:[1122:1131]
==agent_s3.enhanced_scratchpad_manager:[418:427]
            if isinstance(level, str):
                level_map = {
                    "debug": LogLevel.DEBUG,
                    "info": LogLevel.INFO,
                    "warning": LogLevel.WARNING,
                    "warn": LogLevel.WARNING,
                    "error": LogLevel.ERROR,
                    "critical": LogLevel.CRITICAL
                } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[255:263]
==agent_s3.tools.context_management.adaptive_config.config_templates:[242:250]
        "context_management": {
            "embedding": {
                "chunk_size": 950,
            },
            "search": {
                "bm25": {
                    "k1": 1.3
                } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_templates 4:[242:250]
==agent_s3.tools.context_management.adaptive_config.config_templates:[255:263]
        "context_management": {
            "embedding": {
                "chunk_size": 950,
            },
            "search": {
                "bm25": {
                    "k1": 1.3
                } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.dependency_analyzer:[69:77]
==agent_s3.tools.plan_validator:[170:178]
        if not language:
            if hasattr(self.file_tool, 'get_language_from_extension'):
                language = self.file_tool.get_language_from_extension(file_path)
            if not language:
                language = Path(file_path).suffix[1:].lower() if Path(file_path).suffix else 'unknown'
        parser = self.parser_registry.get_parser(language_name=language, file_path=file_path)
        if parser:
            try: (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.json_utils:[108:116]
==agent_s3.pre_planner_json_enforced:[451:459]
        json_text = extract_json_from_text(response)
        if json_text:
            try:
                data = json.loads(json_text)
                error_message = None # Reset error if extraction and parsing succeeded
            except json.JSONDecodeError as e:
                error_message = f"Extracted text is not valid JSON: {e}"
                logger.warning(error_message) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.planner_json_enforced:[168:176]
==agent_s3.pre_planner_json_enforced:[131:139]
                    "unit_tests": [],
                    "integration_tests": [],
                    "property_based_tests": [],
                    "acceptance_tests": [],
                    "test_strategy": {
                        "coverage_goal": "80%",
                        "ui_test_approach": "manual"
                    } (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.coherence_validator:[80:90]
==agent_s3.tools.implementation_validator:[833:843]
            if not isinstance(function, dict) or "function" not in function:
                continue

            function_signature = function["function"]

            # Extract just the name part from the signature
            name_match = re.search(r'(?:def|class)\s+(\w+)', function_signature)
            if name_match:
                name = name_match.group(1)
                function_names.append(name) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.incremental_indexer:[673:685]
==agent_s3.tools.incremental_indexing_adapter:[379:395]
            }

            return stats
        except Exception as e:
            logger.error(f"Error getting index stats: {e}")
            return {
                "error": str(e)
            }

    def start_distributed_indexing(self, repo_path: str, worker_count: int = 2) -> Dict[str, Any]:
        """Run indexing in multiple processes and merge results."""
        from multiprocessing import Process (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.file_history_analyzer:[151:158]
==agent_s3.tech_stack_detector:[150:157]
        else:
            if level.lower() == "error":
                logging.error(message)
            elif level.lower() == "warning":
                logging.warning(message)
            else:
                logging.info(message) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.signature_normalizer:[57:68]
==agent_s3.tools.static_plan_checker:[135:146]
            if not isinstance(group, dict):
                continue

            group_name = group.get("group_name", f"Group {group_idx}")

            # Process each feature
            for feature_idx, feature in enumerate(group.get("features", [])):
                if not isinstance(feature, dict):
                    continue

                feature_name = feature.get("name", f"Feature {feature_idx}") (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.json_utils:[89:99]
==agent_s3.pre_planner_json_enforced:[432:442]
    error_message = None

    # Try to parse the response as JSON directly
    try:
        if isinstance(response, str):
            data = json.loads(response)
        elif isinstance(response, dict):
            # Response might already be parsed JSON
            data = response
        else: (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.json_utils:[306:314]
==agent_s3.planner_json_enforced:[287:298]
    return {
        "response_format": {"type": "json_object"},  # Force JSON output format
        "headers": {"Accept": "application/json"},   # Request JSON MIME type
        "temperature": 0.1,                          # Lower temperature for consistent formatting
        "max_tokens": 4096,                          # Ensure enough space for full JSON response
        "top_p": 0.2                                 # Narrow token selection for consistent formatting
    }

# Add import for implementation validator
from agent_s3.tools.implementation_validator import validate_implementation_plan, repair_implementation_plan
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.task_resumer:[469:476]
==agent_s3.workspace_initializer:[468:483]
        else:
            if level.lower() == "error":
                logging.error(message)
            elif level.lower() == "warning":
                logging.warning(message)
            else:
                logging.info(message) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[990:998]
==agent_s3.tools.security_validator:[62:71]
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function in functions:
            if not isinstance(function, dict):
                continue
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[922:930]
==agent_s3.tools.security_validator 3:[62:71]
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function in functions:
            if not isinstance(function, dict):
                continue
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.canonical_validator 3:[36:44]
==agent_s3.tools.coherence_validator:[432:440]
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function_idx, function in enumerate(functions):
            if not isinstance(function, dict):
                continue
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.canonical_validator:[36:44]
==agent_s3.tools.coherence_validator:[188:197]
    for file_path, functions in implementation_plan.items():
        if not isinstance(functions, list):
            continue

        for function_idx, function in enumerate(functions):
            if not isinstance(function, dict):
                continue
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.repository_event_system 3:[168:176]
==agent_s3.tools.repository_event_system:[140:149]
                self._process_timer = threading.Timer(
                    self.debounce_seconds,
                    self._process_pending_events
                )
                self._process_timer.daemon = True
                self._process_timer.start()

    def _process_pending_events(self) -> None:
        """Process pending events after debounce period.""" (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.repository_event_system 3:[140:149]
==agent_s3.tools.repository_event_system:[168:176]
                self._process_timer = threading.Timer(
                    self.debounce_seconds,
                    self._process_pending_events
                )
                self._process_timer.daemon = True
                self._process_timer.start()

    def _process_pending_events(self) -> None:
        """Process pending events after debounce period.""" (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.system_design_validator 3:[559:568]
==agent_s3.tools.system_design_validator:[1090:1098]
                    if not isinstance(element, dict) or "element_id" not in element:
                        continue

                    element_id = element["element_id"]
                    component = None

                    if "target_file" in element:
                        file_path = element["target_file"] (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.system_design_validator 3:[1090:1098]
==agent_s3.tools.system_design_validator:[559:568]
        if not isinstance(element, dict) or "element_id" not in element:
            continue

        element_id = element["element_id"]

        # Infer component from file path or element type
        component = None
        if "target_file" in element:
            file_path = element["target_file"] (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.file_change_tracker 3:[243:254]
==agent_s3.tools.file_change_tracker:[212:223]
        try:
            # Walk through directory
            for root, _, files in os.walk(directory):
                for filename in files:
                    # Filter by extension if specified
                    if extensions and not any(filename.endswith(ext) for ext in extensions):
                        continue

                    file_path = os.path.join(root, filename)

                    # Track the file (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.file_change_tracker 3:[212:223]
==agent_s3.tools.file_change_tracker:[243:254]
        try:
            # Walk through directory
            for root, _, files in os.walk(directory):
                for filename in files:
                    # Filter by extension if specified
                    if extensions and not any(filename.endswith(ext) for ext in extensions):
                        continue

                    file_path = os.path.join(root, filename)

                    # Check if file has changed (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.planner_json_enforced:[2578:2586]
==agent_s3.tools.implementation_validator:[176:186]
    metrics = _calculate_implementation_metrics(
        validated_plan,
        element_ids,
        architecture_issues,
        test_requirements
    )

    # Run additional validation checks with new specialized functions

    # Validate implementation quality based on metrics (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.command_processor:[1137:1143]
==agent_s3.workspace_initializer:[469:483]
            if level.lower() == "error":
                logging.error(message)
            elif level.lower() == "warning":
                logging.warning(message)
            else:
                logging.info(message)

    def _notify_user(self, message: str, level: str = "info") -> None:
        """Notify the user through prompt_moderator if available, otherwise print.

        Args:
            message: The message to notify the user with
            level: The notification level (info, warning, error)
        """ (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.test_critic.adapters.js_jest:[143:165]
==agent_s3.tools.test_critic.adapters.php_pest:[182:204]
            return False

        finally:
            # Change back to original directory
            os.chdir(original_dir)

    def coverage(self, workspace: Path) -> Optional[float]:
        """
        Run code coverage analysis.

        Args:
            workspace: Path to the workspace directory

        Returns:
            Coverage percentage or None if coverage analysis is not available
        """
        try:
            # Change to workspace directory
            original_dir = Path.cwd()
            os.chdir(workspace)

            # Run Jest with coverage option and JSON reporter (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.test_critic.adapters.js_jest:[145:165]
==agent_s3.tools.test_critic.adapters.php_pest:[252:272]
        finally:
            # Change back to original directory
            os.chdir(original_dir)

    def mutation(self, workspace: Path) -> Optional[float]:
        """
        Run mutation testing.

        Args:
            workspace: Path to the workspace directory

        Returns:
            Mutation score percentage or None if mutation testing is not available
        """
        try:
            # Change to workspace directory
            original_dir = Path.cwd()
            os.chdir(workspace)

            # Check if infection is installed (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.test_critic.adapters.js_jest:[115:135]
==agent_s3.tools.test_critic.adapters.php_pest:[149:169]
        finally:
            # Change back to original directory
            os.chdir(original_dir)

    def smoke_run(self, workspace: Path) -> bool:
        """
        Run a smoke test to check if tests pass.

        Args:
            workspace: Path to the workspace directory

        Returns:
            True if tests pass, False otherwise
        """
        try:
            # Change to workspace directory
            original_dir = Path.cwd()
            os.chdir(workspace)

            # Run Jest with bail option (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.test_critic.adapters.js_jest:[74:94]
==agent_s3.tools.test_critic.adapters.php_pest:[103:123]
            return True

        return False

    def collect_only(self, workspace: Path) -> List[str]:
        """
        Run a test collection to check for syntax errors.

        Args:
            workspace: Path to the workspace directory

        Returns:
            List of error messages (empty if no errors)
        """
        try:
            # Change to workspace directory
            original_dir = Path.cwd()
            os.chdir(workspace)

            # Determine the test command (Pest or PHPUnit) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_explainer 3:[171:178]
==agent_s3.tools.context_management.adaptive_config.config_explainer:[686:692]
            for change in changes:
                param_path = change["path"]
                old_value = change["old_value"]
                new_value = change["new_value"]

                explanation = self._explain_parameter_change(param_path, old_value, new_value) (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.context_management.adaptive_config.config_explainer 3:[686:692]
==agent_s3.tools.context_management.adaptive_config.config_explainer:[171:178]
        for change in changes:
            param_path = change["path"]
            old_value = change["old_value"]
            new_value = change["new_value"]

            explanation = self._explain_parameter_change(param_path, old_value, new_value)
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.phase_validator 4:[211:231]
==agent_s3.tools.phase_validator:[416:435]
                is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid", validation_details


def validate_security_concerns(architecture_review: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    """Validate that security concerns in architecture review are properly addressed.

    Args:
        architecture_review: The architecture review data

    Returns:
        Tuple of (is_valid, error_message, validation_details)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []
    validation_details = { (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.phase_validator 4:[416:435]
==agent_s3.tools.phase_validator:[211:231]
        is_valid = False

    # Return validation result
    return is_valid, "; ".join(error_messages) if error_messages else "Valid", validation_details


def validate_test_coverage_against_risk(tests: Dict[str, Any], risk_assessment: Dict[str, Any]) -> Tuple[bool, str, Dict[str, Any]]:
    """Validate that tests provide adequate coverage for identified risks.

    Args:
        tests: The test plan data
        risk_assessment: The risk assessment data

    Returns:
        Tuple of (is_valid, error_message, validation_details)
    """
    # Initialize validation state
    is_valid = True
    error_messages = []
    validation_details = { (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[2135:2143]
==agent_s3.tools.security_validator 3:[63:71]
        if not isinstance(functions, list):
            continue

        for function in functions:
            if not isinstance(function, dict):
                continue

            # Check architecture_issues_addressed field for explicit references to security concerns (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.plan_validator:[230:238]
==agent_s3.tools.static_plan_checker:[358:367]
            if not isinstance(group, dict):
                continue

            # Process features
            for feature_idx, feature in enumerate(group.get("features", [])):
                if not isinstance(feature, dict):
                    continue

                # Process system_design.code_elements (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[32:63]
==agent_s3.tools.test_implementation_validator:[20:51]
    pass


def validate_implementation_plan(
    implementation_plan: Dict[str, Any],
    system_design: Dict[str, Any],
    architecture_review: Dict[str, Any],
    test_implementations: Dict[str, Any]
) -> Tuple[Dict[str, Any], List[Dict[str, Any]], bool]:
    """
    Validate implementation plan against system design, architecture review, and test implementations.

    Args:
        implementation_plan: The implementation plan to validate
        system_design: The system design data
        architecture_review: The architecture review data
        test_implementations: The test implementations data

    Returns:
        Tuple of (validated_plan, validation_issues, needs_repair)
    """
    validation_issues = []
    needs_repair = False

    # Extract element IDs from system design for validation
    element_ids = _extract_element_ids_from_system_design(system_design)

    # Extract architecture issues for validation
    architecture_issues = _extract_architecture_issues(architecture_review)

    # Extract test requirements for validation (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.tools.implementation_validator:[1074:1082]
==agent_s3.tools.system_design_validator:[626:634]
            return

        if node in visited:
            return

        visited.add(node)
        path.append(node)
 (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.test_spec_validator:[64:69]
==agent_s3.tools.implementation_validator:[370:375]
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"), (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0801: Similar lines in 2 files
==agent_s3.test_spec_validator:[84:89]
==agent_s3.tools.test_implementation_validator:[224:229]
        if isinstance(issue, dict):
            issues.append({
                "id": issue.get("id", ""),
                "description": issue.get("description", ""),
                "severity": issue.get("severity", "Medium"), (duplicate-code)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.tools.test_critic.adapters.python_pytest -> agent_s3.tools.test_critic.core) (cyclic-import)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.json_utils -> agent_s3.planner_json_enforced) (cyclic-import)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.pre_planner_json_enforced -> agent_s3.pre_planner_json_validator) (cyclic-import)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.json_utils -> agent_s3.planner_json_enforced -> agent_s3.test_spec_validator) (cyclic-import)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.tools.test_critic.adapters.js_jest -> agent_s3.tools.test_critic.core) (cyclic-import)
agent_s3/communication/vscode_bridge.py:1:0: R0401: Cyclic import (agent_s3.tools.test_critic.adapters.php_pest -> agent_s3.tools.test_critic.core) (cyclic-import)

------------------------------------------------------------------
Your code has been rated at 5.24/10 (previous run: 5.24/10, +0.00)

