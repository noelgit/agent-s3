diff --git a/README.md b/README.md
index 2decd7b..c571ea0 100644
--- a/README.md
+++ b/README.md
@@ -128,50 +128,51 @@ Agent-S3 is not just a tool for automation; it is a partner in development that
 - Advanced semantic caching for LLM calls:
   - TTL-based expiration, vector similarity search, and prefix-aware eviction
   - Atomic disk persistence under `.cache/semantic_cache/`
   - Metrics: hits, misses, semantic_hits (via `get_cache_stats()`)
   - Asynchronous cache storage to avoid blocking LLM calls
   - vLLM KV cache reuse for improved inference performance
   - Hybrid caching strategy combining semantic hits with tensor prefix reuse
   - Automatic tensor size tracking and hit counting for performance metrics
 
 ## Validated LLM Summarization System
 
 Agent-S3 now uses a validated LLM-based summarization system for all code and context summarization. This system:
 - Uses language- and task-specific prompt generation
 - Validates summaries for faithfulness, detail preservation, and structural coherence
 - Refines summaries that do not meet quality thresholds
 - Caches validated summaries for efficiency
 - Includes a benchmark and evaluation tool for summary quality
 
 See `docs/summarization.md` for details.
 
 **VS Code Extension (`vscode`):**
 - Command Palette integration: Initialize workspace, Make change request, Show help, Show config, Reload LLM config, Explain last LLM interaction, Open Chat Window
 - Status bar item (`$(sparkle) Agent-S3`) to start change requests
 - Dedicated terminal panel for backend interactions
 - Real-time status updates via WebSocket; `progress_log.jsonl` is retained only as a log file
+- Server shuts down automatically on exit, removing the connection file
 - Optional Copilot-style chat UI for input; terminal shows actual outputs
 - WebView panels for structured information display:
   - Code change plan reviews
   - Diff visualization
   - Design documentation
 
 ## Streaming UI
 
 Agent-S3 features a real-time streaming UI for chat and progress updates, powered by a WebSocket-based architecture:
 
 - **WebSocket Client/Server:** The backend and VS Code extension communicate via enhanced WebSocket protocols, supporting streaming message types (e.g., `stream_start`, `stream_content`, `stream_end`, `thinking`).
 - **Streaming Chat UI:** The `ChatView` React component in the extension displays real-time agent responses, partial message rendering, and thinking indicators.
 - **Backend Integration:** The backend emits streaming updates for progress, terminal output, and chat, eliminating the need for file polling.
 - **Robust Error Handling:** Includes reconnection logic, buffering, and error logging for reliable user experience.
 - **Extensible Protocol:** The message protocol supports future UI features like syntax highlighting, progress bars, and operation cancellation.
 
 This architecture enables a Copilot-like, interactive experience with immediate feedback and smooth agent interaction.
 
 ## Prerequisites
 
 - Python 3.10+ installed
 - VS Code 1.60+ for extension features
 - Git installed
 - Required packages: `sqlalchemy` with optional adapters
   - `psycopg2-binary` for PostgreSQL
diff --git a/agent_s3/vscode_integration.py b/agent_s3/vscode_integration.py
index 69cf4ca..8377a32 100644
--- a/agent_s3/vscode_integration.py
+++ b/agent_s3/vscode_integration.py
@@ -1,134 +1,151 @@
 """VS Code Chat UI Integration Module for Agent-S3."""
 
 import json
 import logging
 import os
-from typing import Dict, Any, Optional, List, Callable
+from typing import Dict, Any, Optional, List
 import threading
 import time
 import websockets
 import asyncio
 from queue import Queue
 import uuid  # For session IDs
+import atexit
 
 # Message Protocol Definition
 MESSAGE_TYPES = {
     "auth": {"desc": "Authenticate client session", "fields": ["token"]},
     "auth_failed": {"desc": "Authentication failed", "fields": ["message"]},
     "connection_established": {"desc": "Connection success", "fields": ["message"]},
     "ping": {"desc": "Heartbeat ping", "fields": []},
     "pong": {"desc": "Heartbeat pong", "fields": ["timestamp"]},
     "status": {"desc": "Backend status", "fields": ["status", "connections"]},
     "plan": {"desc": "Show plan to user", "fields": ["summary", "plan"]},
     "discussion": {"desc": "Show discussion transcript", "fields": ["discussion"]},
     "code": {"desc": "Show code block", "fields": ["code", "language", "file_path"]},
     "diff": {"desc": "Show file diff", "fields": ["diff", "file_path"]},
     "progress": {"desc": "Progress update", "fields": ["phase", "status", "details"]},
     "request_input": {"desc": "Request user input", "fields": ["request"]},
     "approval": {"desc": "Request approval", "fields": ["message", "options"]},
     "response": {"desc": "User response", "fields": ["selection", "input"]},
     "command": {"desc": "Command from client", "fields": ["command", "args"]},
     # Add more as needed
 }
 
 # Configure logging
 logger = logging.getLogger(__name__)
 
 class VSCodeIntegration:
     """
     Handles communication between Agent-S3 backend and the VS Code extension chat UI.
     
     This class provides methods to send data to the VS Code Chat UI and receive user responses
     through a WebSocket connection.
     """
     
     def __init__(self, port: int = 3939, host: str = "127.0.0.1"):
         """
         Initialize the VS Code Integration.
         
         Args:
             port: WebSocket server port (default: 3939)
             host: WebSocket server host (default: 127.0.0.1/localhost)
         """
         self.port = port
         self.host = host
         self.server = None
         self.active_connections = set()
         self.message_queue = Queue()
         self.response_queue = Queue()
         self.is_running = False
         self.server_thread = None
         self.connect_file_path = self._get_connect_file_path()
+        self._atexit_registered = False
         
         # Authentication token for VS Code clients
         self.auth_token = os.getenv('VSCODE_AUTH_TOKEN', None)
         # Map websockets to session info
         self.connection_sessions: Dict[Any, Dict[str, Any]] = {}
+
+    def __enter__(self) -> "VSCodeIntegration":
+        """Start the server when entering a context."""
+        self.start_server()
+        return self
+
+    def __exit__(self, exc_type, exc, tb) -> None:
+        """Ensure the server is stopped when leaving a context."""
+        self.stop_server()
         
     def _get_connect_file_path(self) -> str:
         """Get the path to the VS Code connection file."""
         # Determine the appropriate location based on OS
         if os.name == 'nt':  # Windows
             base_dir = os.path.join(os.environ['APPDATA'], 'agent-s3')
         else:  # Unix/Linux/Mac
             base_dir = os.path.join(os.path.expanduser('~'), '.agent-s3')
             
         # Create directory if it doesn't exist
         if not os.path.exists(base_dir):
             os.makedirs(base_dir)
             
         return os.path.join(base_dir, 'vscode-connection.json')
     
     def start_server(self) -> bool:
         """
         Start the WebSocket server in a separate thread.
         
         Returns:
             True if server started successfully, False otherwise
         """
         if self.is_running:
             logger.warning("WebSocket server is already running")
             return True
             
         # Start server in a separate thread
         self.server_thread = threading.Thread(target=self._run_server)
         self.server_thread.daemon = True
         self.server_thread.start()
         
         # Wait for server to start up
         time_waited = 0
         while not self.is_running and time_waited < 5:  # Wait up to 5 seconds
             time.sleep(0.1)
             time_waited += 0.1
             
         if not self.is_running:
             logger.error("Failed to start WebSocket server within timeout")
             return False
             
         # Write connection info to file for VS Code to discover
         self._write_connection_info()
+
+        # Ensure server shutdown on process exit
+        if not self._atexit_registered:
+            atexit.register(self.stop_server)
+            self._atexit_registered = True
+
         logger.info(f"WebSocket server started on {self.host}:{self.port}")
         return True
         
     def _run_server(self) -> None:
         """Run the WebSocket server in the event loop."""
         async def handler(websocket, path):
             """Handle incoming WebSocket connections with authentication and session management."""
             # Authentication handshake
             try:
                 auth_msg = await asyncio.wait_for(websocket.recv(), timeout=5)
                 auth_data = json.loads(auth_msg)
                 if auth_data.get('type') != 'auth' or auth_data.get('token') != self.auth_token:
                     await websocket.send(json.dumps({"type":"auth_failed","message":"Invalid auth token"}))
                     return
                 # Register session
                 session_id = str(uuid.uuid4())
                 self.connection_sessions[websocket] = {"session_id": session_id, "start_time": time.time()}
             except Exception:
                 await websocket.close()
                 return
             self.active_connections.add(websocket)
             logger.info(f"New VS Code connection established: {path}")
             
             try:
                 # Send a welcome message
@@ -259,58 +276,62 @@ class VSCodeIntegration:
                 "port": self.port,
                 "protocol": "ws",
                 "timestamp": time.time()
             }
             
             with open(self.connect_file_path, 'w') as f:
                 json.dump(connection_info, f)
                 
             logger.info(f"Connection info written to {self.connect_file_path}")
         except Exception as e:
             logger.error(f"Failed to write connection info: {e}")
             
     def stop_server(self) -> None:
         """Stop the WebSocket server."""
         if not self.is_running:
             logger.warning("WebSocket server is not running")
             return
             
         # Close server
         if self.server:
             asyncio.run(self.server.close())
             
         # Wait for server thread to end
         if self.server_thread and self.server_thread.is_alive():
             self.server_thread.join(timeout=5)
+            if self.server_thread.is_alive():
+                logger.warning("WebSocket server thread did not terminate")
+            self.server_thread = None
             
         self.is_running = False
         logger.info("WebSocket server stopped")
         
         # Remove connection file
         try:
             if os.path.exists(self.connect_file_path):
                 os.remove(self.connect_file_path)
+                logger.info("Connection file removed")
         except Exception as e:
             logger.error(f"Failed to remove connection file: {e}")
     
     def send_to_chat_ui(self, message: Dict[str, Any]) -> bool:
         """
         Send a message to the VS Code Chat UI.
         
         Args:
             message: The message to send
             
         Returns:
             True if message was queued successfully, False otherwise
         """
         if not self.is_running:
             logger.warning("Cannot send message, WebSocket server is not running")
             return False
             
         try:
             self.message_queue.put(message)
             return True
         except Exception as e:
             logger.error(f"Failed to queue message: {e}")
             return False
     
     def get_user_response(self, request: Dict[str, Any], timeout: int = 300) -> Optional[Dict[str, Any]]:
diff --git a/docs/streaming_ui_implementation.md b/docs/streaming_ui_implementation.md
index 0530dac..4176dc0 100644
--- a/docs/streaming_ui_implementation.md
+++ b/docs/streaming_ui_implementation.md
@@ -51,50 +51,51 @@ This document describes the implementation of a real-time streaming UI for Agent
    - Added support for handling streaming messages
 
 ## Implementation Details
 
 ### Message Flow
 
 1. Agent generates a response:
    ```
    Agent -> publish_thinking() -> WebSocket -> UI shows thinking indicator
    Agent -> publish_stream_start() -> WebSocket -> UI prepares for stream
    Agent -> publish_stream_content() -> WebSocket -> UI displays content incrementally
    Agent -> publish_stream_end() -> WebSocket -> UI finalizes message
    ```
 
 2. Progress updates:
    ```
    ProgressTracker -> send_streaming_update() -> WebSocket -> UI shows progress
    ```
 
 ### Authentication and Security
 
 1. **Connection File**
    - Connection information stored in `.agent_s3_ws_connection.json`
    - Contains authentication token for secure connection
    - Created during VS Code Bridge initialization
+   - Removed automatically when the backend exits
 
 2. **Authentication Flow**
    - Client reads connection file to get authentication token
    - Client sends token to server during connection establishment
    - Server verifies token before accepting messages
    - Reconnection uses the same token for continuity
 
 ### Error Handling and Reliability
 
 1. **Reconnection Strategy**
    - Exponential backoff for reconnection attempts
    - Buffering of messages during disconnections
    - Automatic recovery from temporary network issues
 
 2. **Heartbeat Mechanism**
    - Regular heartbeat messages to verify connection health
    - Automatic reconnection if heartbeats fail
    - Timeout detection for stale connections
 
 ## Files Modified
 
 ### Python Backend
 
 1. `/agent_s3/communication/message_protocol.py`
    - Added streaming message types
diff --git a/tests/test_vscode_integration.py b/tests/test_vscode_integration.py
new file mode 100644
index 0000000..44fb7db
--- /dev/null
+++ b/tests/test_vscode_integration.py
@@ -0,0 +1,30 @@
+import os
+import unittest
+import socket
+from agent_s3.vscode_integration import VSCodeIntegration
+
+
+def get_free_port() -> int:
+    s = socket.socket()
+    s.bind(("", 0))
+    port = s.getsockname()[1]
+    s.close()
+    return port
+
+
+class TestVSCodeIntegrationShutdown(unittest.TestCase):
+    """Verify VSCodeIntegration cleans up resources on shutdown."""
+
+    def test_server_thread_and_connection_file_cleanup(self):
+        port = get_free_port()
+        with VSCodeIntegration(port=port) as integration:
+            self.assertTrue(integration.is_running)
+            self.assertTrue(os.path.exists(integration.connect_file_path))
+            server_thread = integration.server_thread
+        # Context exit should stop server
+        self.assertFalse(server_thread.is_alive())
+        self.assertFalse(os.path.exists(integration.connect_file_path))
+
+
+if __name__ == "__main__":
+    unittest.main()
